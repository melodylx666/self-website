
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="li-xiao的个人网站">
      
      
        <meta name="author" content="li-xiao">
      
      
        <link rel="canonical" href="https://melodylx666.github.io/lx-bigdata/LANG/DS-leetcode/">
      
      
        <link rel="prev" href="../JUC-SUC/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>数据结构与算法 - lx-bigdata</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="lx-bigdata" class="md-header__button md-logo" aria-label="lx-bigdata" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            lx-bigdata
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              数据结构与算法
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至夜间模式"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="切换至夜间模式" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="orange"  aria-label="切换至日间模式"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="切换至日间模式" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/melodylx666/lx-bigdata" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    lx-bigdata
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../TEST/" class="md-tabs__link">
          
  
    
  
  考试

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../Project/" class="md-tabs__link">
          
  
    
  
  风控项目

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../" class="md-tabs__link">
          
  
    
  
  语言基础

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="lx-bigdata" class="md-nav__button md-logo" aria-label="lx-bigdata" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    lx-bigdata
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/melodylx666/lx-bigdata" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    lx-bigdata
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../TEST/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    考试
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            考试
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../TEST/javaweb/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    javaweb
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../TEST/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数字图像处理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../TEST/blockchain/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    blockchain
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../TEST/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    软件工程
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../../Project/" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    风控项目
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_3" id="__nav_3_label" tabindex="0">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            风控项目
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Project/dynamic-Cep/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    动态CEP实现
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Project/econ-rule-engine/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    金融风控引擎
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Project/AbstractStreamOperatorDesign/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    自定义StreamOperator
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="../" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    语言基础
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_4" id="__nav_4_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            语言基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../JUC-SUC/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    JUC-SUC
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    数据结构与算法
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    数据结构与算法
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      工具类：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="工具类：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arrays" class="md-nav__link">
    <span class="md-ellipsis">
      Arrays：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collections" class="md-nav__link">
    <span class="md-ellipsis">
      Collections：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      集合框架：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="集合框架：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#collection" class="md-nav__link">
    <span class="md-ellipsis">
      Collection接口：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      接口的方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    <span class="md-ellipsis">
      List
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    <span class="md-ellipsis">
      Set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    <span class="md-ellipsis">
      Map接口：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Map接口：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      接口的方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2hashmap" class="md-nav__link">
    <span class="md-ellipsis">
      2.HashMap最常用
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      数据结构：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="数据结构：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      栈
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      队列与双端队列与优先队列
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      工具类：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="工具类：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arrays" class="md-nav__link">
    <span class="md-ellipsis">
      Arrays：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#collections" class="md-nav__link">
    <span class="md-ellipsis">
      Collections：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      集合框架：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="集合框架：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#collection" class="md-nav__link">
    <span class="md-ellipsis">
      Collection接口：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      接口的方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    <span class="md-ellipsis">
      List
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    <span class="md-ellipsis">
      Set
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map" class="md-nav__link">
    <span class="md-ellipsis">
      Map接口：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Map接口：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      接口的方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2hashmap" class="md-nav__link">
    <span class="md-ellipsis">
      2.HashMap最常用
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      数据结构：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="数据结构：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      栈
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      队列与双端队列与优先队列
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/melodylx666/lx-bigdata/edit/main/docs/LANG/DS-leetcode.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"/></svg>
    </a>
  
  


<h1 id="_1">数据结构与算法<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<blockquote>
<p>部分目录缺失</p>
</blockquote>
<p><img alt="image.png" src="../assets/ds-collection.png" /></p>
<h3 id="_2">工具类：<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>全部都是静态方法</p>
<h4 id="arrays">Arrays：<a class="headerlink" href="#arrays" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>数组元素拼接：</p>
</li>
<li>
<p>static String toString(Object[] a) ：对数组中每个元素调用toString打印，并用","拼接</p>
</li>
<li>排序：</li>
<li>static void sort(int[] a, int fromIndex, int toIndex) ：对数据进行部分升序排序</li>
<li>static void sort(T[] a, Comparator&lt;? super T&gt; c)：对数据元素进行定制排序</li>
<li>static void sort(Object[] a) ：对数组元素进行自然排序</li>
<li>数组复制：</li>
<li>static T[] copyOf(T[] original,int newLength)：从原数组复制长度为newLength的数组并返回新数组</li>
<li>static T[] copyOfRange(T[] original,int from,int to)：复制原数组的[from,to）的数组元素并返回新数组</li>
<li>比较：</li>
<li>static boolean equals(Object[] a,Object[] a2)：判断两个数组元素以及长度是否完全相同。</li>
<li>填充数组：</li>
<li>static void fill(Object[] a,Object val)：将所有位置设置为val</li>
<li>static void fill(Object[] a, int fromIndex, int toIndex, Object val) ：[from,to)位置设置为val</li>
</ol>
<h4 id="collections">Collections：<a class="headerlink" href="#collections" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>排序操作：</p>
</li>
<li>
<p>sort(List)：对列表元素进行自然升序排序</p>
</li>
<li>sort(List，Comparator):定制排序</li>
<li>reverse(List)：翻转列表元素位置</li>
<li>swap(List，int， int)：将List的i位置和j位置元素交换</li>
<li>查找：</li>
<li>Object max(Collection)：自然排序下的最大值。也可以传入Compatator进行定制排序</li>
<li>int frequency(Collection c，Object o)：返回列表中元素出现的次数</li>
<li>添加：</li>
<li>boolean addAll(Collection c,T... elements):将所有指定元素添加到集合中</li>
</ol>
<h3 id="_3">集合框架：<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p><img alt="image.png" src="../assets/ds-map.png" /></p>
<h4 id="collection">Collection接口：<a class="headerlink" href="#collection" title="Permanent link">&para;</a></h4>
<h4 id="_4">接口的方法<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<ol>
<li>添加：add(E obj)：添加元素对象到当前集合中。addAll(Collection other)：this = this ∪ other</li>
<li>判断：</li>
<li>int size()：长度</li>
<li>boolean isEmpty()：是否为空</li>
<li>boolean contains(Object obj)：通过equals进行判断</li>
<li>boolean containsAll(Collection coll)：判断元素是否都包含</li>
<li>删除：</li>
<li>clear()：清空</li>
<li>remove(),removeAll()：删除第一个匹配的元素。删除全部匹配的元素。</li>
</ol>
<h4 id="list">List<a class="headerlink" href="#list" title="Permanent link">&para;</a></h4>
<p>主要使用ArrayList，以及LinkedList</p>
<ol>
<li>
<p>插入:</p>
</li>
<li>
<p><em>void add(int index, Object ele)</em>:在 index 位置插入 ele 元素</p>
</li>
<li>获取：</li>
<li><em>Object get(int index)</em>:获取指定 index 位置的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合</li>
<li>位置：</li>
<li>int indexOf(Object obj):返回 obj 在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置</li>
<li>删除替换：</li>
<li><em>Object remove(int index)</em>:移除指定 index 位置的元素</li>
<li><em>Object set(int index, Object ele)</em>:设置指定 index 位置的元素为ele</li>
</ol>
<h4 id="set">Set<a class="headerlink" href="#set" title="Permanent link">&para;</a></h4>
<p>主要使用HashSet</p>
<h3 id="map">Map接口：<a class="headerlink" href="#map" title="Permanent link">&para;</a></h3>
<p><img alt="image.png" src="../assets/map01.png" /></p>
<h4 id="_5">接口的方法<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<ol>
<li>
<p>添加</p>
</li>
<li>
<p>Object put(Object key,Object value)：将指定 key-value 添加到(或修改)当前的Map对象中。</p>
</li>
<li>void putAll(Map m):将 m 中的所有 key-value 对存放到当前 map 中</li>
<li>删除</li>
<li>Object remove(Object key)：移除指定 key 的 key-value 对，并返回 value</li>
<li>void clear()：清空当前 map 中的所有数据</li>
<li>查询</li>
</ol>
<h4 id="2hashmap">2.HashMap最常用<a class="headerlink" href="#2hashmap" title="Permanent link">&para;</a></h4>
<ol>
<li>线程不安全</li>
<li>允许key和value是null值</li>
<li>key相等：通过hashcode判断。value相等：通过equals方法判断。</li>
</ol>
<h2 id="_6">数据结构：<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<h3 id="_7">栈<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<ol>
<li>类：Stack</li>
<li>方法：</li>
<li>peek()：查看栈顶元素</li>
<li>pop()：弹出并返回栈顶元素</li>
<li>push()：将元素压栈</li>
</ol>
<h3 id="_8">队列与双端队列与优先队列<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<ol>
<li>类：接口：</li>
<li>队列：Queue，实现类LinkedList</li>
<li>双端队列：Deque<T> deque = new ArrayDeque&lt;&gt;();</li>
<li>优先队列：PriorityQueue<T> heap = new PriorityQueue&lt;&gt;((a,b)-&gt;a[1]-b[1])</li>
<li>方法：</li>
<li>添加：add,offer</li>
<li>查看队列头部：peek</li>
<li>获取并出队头部:poll</li>
</ol>
<h1 id="_9">数据量与对应算法<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h1>
<ol>
<li>平台运行要求：</li>
<li>c/c++运行时间1s，java/python/go等语言运行时间1-2s</li>
<li>对应的常数指令操作量是10^8以内，必须限制在这个数量级，和平台无关</li>
<li>假设n = 10^6,则O(n^2)算法必然TLE</li>
<li>对应算法</li>
</ol>
<p>2^n常对应递归展开(每个位置暴力枚举)</p>
<p><img alt="image.png" src="../assets/O.png" /></p>
<p><img alt="image.png" src="../assets/o1.png" /></p>
<h3 id="_10">选择排序：<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<p>i\~n-1范围上，找到最小值并放在i位置，然后i+1\~n-1范围上继续</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-0-1">     //选择排序
</span><span id="__span-0-2">    public static void selectionSort(int[] arr) {
</span><span id="__span-0-3">        if (arr == null || arr.length &lt; 2) {
</span><span id="__span-0-4">            return;
</span><span id="__span-0-5">        }
</span><span id="__span-0-6">        for (int minIndex, i = 0; i &lt; arr.length - 1; i++) {
</span><span id="__span-0-7">            minIndex = i;
</span><span id="__span-0-8">            for (int j = i + 1; j &lt; arr.length; j++) {
</span><span id="__span-0-9">                if (arr[j] &lt; arr[minIndex]) {
</span><span id="__span-0-10">                    minIndex = j;
</span><span id="__span-0-11">                }
</span><span id="__span-0-12">            }
</span><span id="__span-0-13">            swap(arr, i, minIndex);
</span><span id="__span-0-14">        }
</span><span id="__span-0-15">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_11">冒泡排序：<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>0\~i范围上，相邻位置较大的数滚下去，最大值最终来到i位置，然后0\~i-1范围上继续</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-1-1">    public static void bubbleSort(int[] arr) {
</span><span id="__span-1-2">        if (arr == null || arr.length &lt; 2) {
</span><span id="__span-1-3">            return;
</span><span id="__span-1-4">        }
</span><span id="__span-1-5">        for (int end = arr.length - 1; end &gt; 0; end--) {
</span><span id="__span-1-6">            for (int i = 0; i &lt; end; i++) {
</span><span id="__span-1-7">                if (arr[i] &gt; arr[i + 1]) {
</span><span id="__span-1-8">                    swap(arr, i, i + 1);
</span><span id="__span-1-9">                }
</span><span id="__span-1-10">            }
</span><span id="__span-1-11">        }
</span><span id="__span-1-12">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_12">插入排序：<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>0\~i范围上已经有序，新来的数从右到左滑到不再小的位置插入，然后继续</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-2-1">    public static void insertionSort(int[] arr) {
</span><span id="__span-2-2">        if (arr == null || arr.length &lt; 2) {
</span><span id="__span-2-3">            return;
</span><span id="__span-2-4">        }
</span><span id="__span-2-5">        for (int i = 1; i &lt; arr.length; i++) {
</span><span id="__span-2-6">        //从0到i-1部分，进行滑动插入
</span><span id="__span-2-7">        //每次都能保证0到i-1部分有序，新来的是arr[i],在下面的循环中新来的数一直是arr[j+1].
</span><span id="__span-2-8">            for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {
</span><span id="__span-2-9">                swap(arr, j, j + 1);
</span><span id="__span-2-10">            }
</span><span id="__span-2-11">        }
</span><span id="__span-2-12">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_13">快速排序<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<ol>
<li>基本思路：</li>
<li>将数列划分为两部分，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。也就是划分为前一部分&lt;=nums[x],后一部分&gt;nums[x]。则此时将x位置的数移动到&lt;=位置的最后一个，也就是两个序列中间，意味着nums[x]已经排好序了。</li>
<li>递归到两个子序列中进行a操作。每一次划分就会排序好一个数</li>
<li>不用合并，此时序列已经完全有序</li>
<li>时间复杂度：O(n*logn),最差O(n^2)</li>
<li>经典模板：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-3-1">class Solution {
</span><span id="__span-3-2">    public int[] sortArray(int[] nums) {
</span><span id="__span-3-3">        quickSort(nums, 0, nums.length-1);
</span><span id="__span-3-4">        return nums;
</span><span id="__span-3-5">    }
</span><span id="__span-3-6">    public static void quickSort(int[] nums, int l, int r){
</span><span id="__span-3-7">        if(l&gt;=r) return;
</span><span id="__span-3-8">        int x = nums[l + (int)(Math.random()*(r-l+1))];
</span><span id="__span-3-9">        int mid = partition(nums, x,l,r);
</span><span id="__span-3-10">        quickSort(nums, l,mid-1);
</span><span id="__span-3-11">        quickSort(nums, mid+1,r);
</span><span id="__span-3-12">    }
</span><span id="__span-3-13">    public static int partition(int[] nums, int x,int l, int r){
</span><span id="__span-3-14">        //[l,cnt)是&lt;=x的数组
</span><span id="__span-3-15">        int cnt = l;
</span><span id="__span-3-16">        int xIndex = 0;
</span><span id="__span-3-17">        for(int i=l; i&lt;=r;i++){
</span><span id="__span-3-18">            if(nums[i] &lt;= x){
</span><span id="__span-3-19">                swap(nums,i,cnt);
</span><span id="__span-3-20">                //被交换到了cnt位置
</span><span id="__span-3-21">                if(nums[cnt] == x) xIndex = cnt;
</span><span id="__span-3-22">                cnt++;
</span><span id="__span-3-23">            }
</span><span id="__span-3-24">        }
</span><span id="__span-3-25">        swap(nums,xIndex,cnt-1);
</span><span id="__span-3-26">        return cnt-1;
</span><span id="__span-3-27">    }
</span><span id="__span-3-28">    public static void swap(int[] nums, int a, int b){
</span><span id="__span-3-29">        int temp = nums[a];
</span><span id="__span-3-30">        nums[a] = nums[b];
</span><span id="__span-3-31">        nums[b] = temp;
</span><span id="__span-3-32">    }
</span><span id="__span-3-33">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>优化(三路快速排序，基于荷兰国旗问题)：</li>
<li>思路：将数组划分为<x,=x,>x三个部分。直接确定了=x的位置，而不是一次一次确定。在有重复值数据上表现更好。</li>
<li>时间复杂度:O(n*logn)，最优为O(n)，最差情况O(n^2)</li>
<li>划分步骤：<ol>
<li>使用两个变量first，last记录<x和>x的更新的数组位置</li>
<li>如果nums[i]&lt;x，则进行swap(nums,i,first),并将first++,然后i++;</li>
<li>如果nums[i]&gt;x，则进行swap(nums,i,last),并将last--,但是i不变 ，需要再次进行进行判断是否需要进行交换。</li>
<li>整体就是从左往右，每一个数字依次都是经过检查的，从后面交换的没有check过，所以i不变。</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-4-1">class Solution {
</span><span id="__span-4-2">    public int[] sortArray(int[] nums) {
</span><span id="__span-4-3">        quickSort(nums, 0, nums.length-1);
</span><span id="__span-4-4">        return nums;
</span><span id="__span-4-5">    }
</span><span id="__span-4-6">    public static void quickSort(int[] nums, int l, int r){
</span><span id="__span-4-7">        if(l&gt;=r) return;
</span><span id="__span-4-8">        int x = nums[l + (int)(Math.random()*(r-l+1))];
</span><span id="__span-4-9">        int[] bound = partition(nums, x,l,r);
</span><span id="__span-4-10">        int lmid = bound[0], rmid = bound[1];
</span><span id="__span-4-11">        quickSort(nums, l,lmid-1);
</span><span id="__span-4-12">        quickSort(nums, rmid+1,r);
</span><span id="__span-4-13">    }
</span><span id="__span-4-14">    //partition部分是O(n)
</span><span id="__span-4-15">    public static int[] partition(int[] nums, int x,int l, int r){
</span><span id="__span-4-16">        int first = l;
</span><span id="__span-4-17">        int last = r;
</span><span id="__span-4-18">        int i = l;
</span><span id="__span-4-19">        while(i&lt;=last){
</span><span id="__span-4-20">            if(nums[i] &lt; x){
</span><span id="__span-4-21">                swap(nums, first, i);
</span><span id="__span-4-22">                first++;
</span><span id="__span-4-23">                i++;
</span><span id="__span-4-24">            }else if(nums[i] &gt; x){
</span><span id="__span-4-25">                swap(nums, i, last);
</span><span id="__span-4-26">                last--;
</span><span id="__span-4-27">            }else{
</span><span id="__span-4-28">                i++;
</span><span id="__span-4-29">            }
</span><span id="__span-4-30">        }
</span><span id="__span-4-31">        return new int[]{first,last};
</span><span id="__span-4-32">    }
</span><span id="__span-4-33">    public static void swap(int[] nums, int a, int b){
</span><span id="__span-4-34">        int temp = nums[a];
</span><span id="__span-4-35">        nums[a] = nums[b];
</span><span id="__span-4-36">        nums[b] = temp;
</span><span id="__span-4-37">    }
</span><span id="__span-4-38">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_14">随机选择算法<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>原理：</p>
</li>
<li>
<p>基于随机快速排序</p>
</li>
<li>如果partition之后=x的部分是[first,last]，这一部分是排序好的。如果这一部分下标包含target，则直接返回。</li>
<li>如果没有命中，可以根据大小关系只进行一侧的递归查找</li>
<li>复杂度：</li>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
<li>例题：leetcode215 第k大的数</li>
<li>思路：排序：O(n*logn)。随机选择：O(n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-5-1">class Solution {
</span><span id="__span-5-2">    public int findKthLargest(int[] nums, int k) {
</span><span id="__span-5-3">        return randomSelect(nums, nums.length-k);
</span><span id="__span-5-4">    }
</span><span id="__span-5-5">    //nums排序，在i位置上的数是什么
</span><span id="__span-5-6">    public static int randomSelect(int[] nums,int i){
</span><span id="__span-5-7">        int l = 0, r = nums.length-1;
</span><span id="__span-5-8">        int ans = 0;
</span><span id="__span-5-9">        while(l&lt;=r){
</span><span id="__span-5-10">            int x = nums[l+(int)(Math.random()*(r-l+1))];
</span><span id="__span-5-11">            int[] bound = partition(nums, x, l, r);
</span><span id="__span-5-12">            int lmid = bound[0], rmid = bound[1];
</span><span id="__span-5-13">            if(i &lt; lmid){
</span><span id="__span-5-14">                r = lmid-1;
</span><span id="__span-5-15">            }else if( i &gt; rmid){
</span><span id="__span-5-16">                l = rmid+1;
</span><span id="__span-5-17">            }else{
</span><span id="__span-5-18">                ans = nums[i];
</span><span id="__span-5-19">                break;
</span><span id="__span-5-20">            }
</span><span id="__span-5-21">        }
</span><span id="__span-5-22">        return ans;
</span><span id="__span-5-23">    }
</span><span id="__span-5-24">    public static int[] partition(int[] nums, int x, int l, int r){
</span><span id="__span-5-25">        int first = l;
</span><span id="__span-5-26">        int last = r;
</span><span id="__span-5-27">        int i = l;
</span><span id="__span-5-28">        while(i&lt;=last){
</span><span id="__span-5-29">            if(nums[i] &lt; x){
</span><span id="__span-5-30">                swap(nums, first,i);
</span><span id="__span-5-31">                first++;
</span><span id="__span-5-32">                i++;
</span><span id="__span-5-33">            }else if(nums[i] &gt; x){
</span><span id="__span-5-34">                swap(nums,i,last);
</span><span id="__span-5-35">                last--;
</span><span id="__span-5-36">            }else{
</span><span id="__span-5-37">                i++;
</span><span id="__span-5-38">            }
</span><span id="__span-5-39">        }
</span><span id="__span-5-40">        return new int[]{first,last};
</span><span id="__span-5-41">    }
</span><span id="__span-5-42">    public static void swap(int[] nums, int l, int r){
</span><span id="__span-5-43">        int temp = nums[l];
</span><span id="__span-5-44">        nums[l] = nums[r];
</span><span id="__span-5-45">        nums[r] = temp;
</span><span id="__span-5-46">    }
</span><span id="__span-5-47">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_15">对数器：<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h2>
<p>场景：对于测试用例不够的场景，用来自我验证</p>
<p>基本思路：先实现暴力解，再实现最优解，然后生成随机数据，然后 验证暴力解和最优解的结果是否一致，这就是对数器。</p>
<p>对数器的门槛其实是比较高的，因为往往需要在两种不同思路下实现功能相同的两个方法，暴力一个、想象中的最优解是另一个。</p>
<p>以后的很多题目都会用到对数器，几乎可以验证任何方法，尤其在验证贪心、观察规律方面很有用</p>
<p>到时候会丰富很多对数器的实战用法，这里只是一个简单易懂的示例</p>
<h2 id="_16">二分搜索：<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h2>
<p><strong>👋</strong></p>
<p>前三种情况必须要数组体现有序才可以使用</p>
<h3 id="num-target">情况一：num == target<a class="headerlink" href="#num-target" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-6-1">    public static boolean exist(int[] arr, int num) {
</span><span id="__span-6-2">        if (arr == null || arr.length == 0) {
</span><span id="__span-6-3">            return false;
</span><span id="__span-6-4">        }
</span><span id="__span-6-5">        int l = 0, r = arr.length - 1, m = 0;
</span><span id="__span-6-6">        while (l &lt;= r) {
</span><span id="__span-6-7">            m = (l + r) / 2;
</span><span id="__span-6-8">            if (arr[m] == num) {
</span><span id="__span-6-9">                return true;
</span><span id="__span-6-10">            } else if (arr[m] &gt; num) {
</span><span id="__span-6-11">                r = m - 1;
</span><span id="__span-6-12">            } else {
</span><span id="__span-6-13">                l = m + 1;
</span><span id="__span-6-14">            }
</span><span id="__span-6-15">        }
</span><span id="__span-6-16">        return false;
</span><span id="__span-6-17">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="num-target_1">情况二: num &gt;= target的最左边位置<a class="headerlink" href="#num-target_1" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-7-1">    public static int findLeft(int[] arr, int num) {
</span><span id="__span-7-2">        int l = 0, r = arr.length - 1, m = 0;
</span><span id="__span-7-3">        int ans = -1;
</span><span id="__span-7-4">        while (l &lt;= r) {
</span><span id="__span-7-5">            // m = (l + r) / 2;
</span><span id="__span-7-6">            // m = l + (r - l) / 2;
</span><span id="__span-7-7">            m = l + ((r - l) &gt;&gt; 1);
</span><span id="__span-7-8">
</span><span id="__span-7-9">            if (arr[m] &gt;= num) {
</span><span id="__span-7-10">                ans = m;
</span><span id="__span-7-11">                r = m - 1;
</span><span id="__span-7-12">            } else {
</span><span id="__span-7-13">                l = m + 1;
</span><span id="__span-7-14">            }
</span><span id="__span-7-15">        }
</span><span id="__span-7-16">        return ans;
</span><span id="__span-7-17">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="num-target_2">情况三： num &lt;= target的最右边位置<a class="headerlink" href="#num-target_2" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-8-1">    public static int findRight(int[] arr, int num) {
</span><span id="__span-8-2">        int l = 0, r = arr.length - 1, m = 0;
</span><span id="__span-8-3">        int ans = -1;
</span><span id="__span-8-4">        while (l &lt;= r) {
</span><span id="__span-8-5">            //防止精度溢出
</span><span id="__span-8-6">            m = l + ((r - l) &gt;&gt; 1); 
</span><span id="__span-8-7">            if (arr[m] &lt;= num) {
</span><span id="__span-8-8">                ans = m;
</span><span id="__span-8-9">                l = m + 1;
</span><span id="__span-8-10">            } else {
</span><span id="__span-8-11">                r = m - 1;
</span><span id="__span-8-12">            }
</span><span id="__span-8-13">        }
</span><span id="__span-8-14">        return ans;
</span><span id="__span-8-15">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_17">情况四： 峰值问题：<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<p>思路：</p>
<ol>
<li>验证0位置和n-1位置的数，如果有符合峰值的情况，直接返回</li>
<li>如果没有，那么开头是上升的，结尾是下降的，一定存在转折点，也就是峰值。</li>
<li>二分查找到中点，看与左右边界构成的区间如果是上升+下降组合，那么峰值必然在区间内，在区间内二分即可。</li>
</ol>
<p>示例：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-9-1">// 峰值元素是指其值严格大于左右相邻值的元素
</span><span id="__span-9-2">// 给你一个整数数组 nums，已知任何两个相邻的值都不相等
</span><span id="__span-9-3">// 找到峰值元素并返回其索引
</span><span id="__span-9-4">// 数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
</span><span id="__span-9-5">// 你可以假设 nums[-1] = nums[n] = 无穷小
</span><span id="__span-9-6">// 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
</span><span id="__span-9-7">public class Code04_FindPeakElement {
</span><span id="__span-9-8">
</span><span id="__span-9-9">    // 测试链接 : https://leetcode.cn/problems/find-peak-element/
</span><span id="__span-9-10">    class Solution {
</span><span id="__span-9-11">
</span><span id="__span-9-12">        public static int findPeakElement(int[] arr) {
</span><span id="__span-9-13">            int n = arr.length;
</span><span id="__span-9-14">            if (arr.length == 1) {
</span><span id="__span-9-15">                return 0;
</span><span id="__span-9-16">            }
</span><span id="__span-9-17">            if (arr[0] &gt; arr[1]) {
</span><span id="__span-9-18">                return 0;
</span><span id="__span-9-19">            }
</span><span id="__span-9-20">            if (arr[n - 1] &gt; arr[n - 2]) {
</span><span id="__span-9-21">                return n - 1;
</span><span id="__span-9-22">            }
</span><span id="__span-9-23">            int l = 1, r = n - 2, m = 0, ans = -1;
</span><span id="__span-9-24">            while (l &lt;= r) {
</span><span id="__span-9-25">                m = (l + r) / 2;
</span><span id="__span-9-26">                if (arr[m - 1] &gt; arr[m]) {
</span><span id="__span-9-27">                    r = m - 1;
</span><span id="__span-9-28">                } else if (arr[m] &lt; arr[m + 1]) {
</span><span id="__span-9-29">                    l = m + 1;
</span><span id="__span-9-30">                } else {
</span><span id="__span-9-31">                    ans = m;
</span><span id="__span-9-32">                    break;
</span><span id="__span-9-33">                }
</span><span id="__span-9-34">            }
</span><span id="__span-9-35">            return ans;
</span><span id="__span-9-36">        }
</span><span id="__span-9-37">    }
</span><span id="__span-9-38">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_18">二分答案法：<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h2>
<h3 id="_19">步骤<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<ol>
<li>估计最终答案可能的范围是什么</li>
<li>分析问题和给定条件之间的单调性</li>
<li>建立一个check函数，在答案固定的情况下，判断给定的条件是否达标(也就是答案需要满足的性质)</li>
<li>不断调整范围，直到二分结束找到答案</li>
</ol>
<h3 id="_20">例题<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<ol>
<li>leetcode 875</li>
</ol>
<p>珂珂喜欢吃香蕉。这里有 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 堆香蕉，第 <code>&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;</code> 堆中有 <code>&lt;span class="color_font"&gt;&lt;span&gt;piles[i]&lt;/span&gt;&lt;/span&gt;</code> 根香蕉。警卫已经离开了，将在 <code>&lt;span class="color_font"&gt;&lt;span&gt;h&lt;/span&gt;&lt;/span&gt;</code> 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 根。如果这堆香蕉少于 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 <code>&lt;span class="color_font"&gt;&lt;span&gt;h&lt;/span&gt;&lt;/span&gt;</code> 小时内吃掉所有香蕉的最小速度 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code>（<code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 为整数）。</p>
<ul>
<li>思路：要求的是最小速度，思考速度的范围[l,r]。</li>
<li>r最大只需要就只用数组中最大值就可以了，再大了就没收益，和r的效果一样。</li>
<li>l最小的情况，根据实际情况判断。</li>
<li>单调性：如果速度增加，则所用的耗时只会减小或者不变。</li>
<li>接着二分：在速度数组中进行二分，不断缩小范围。如果x速度满足，则只用在[l,x-1]范围内继续二分就可以。</li>
</ul>
<p><strong>🔔</strong></p>
<p>这里的整体模型就是满足性质的最左位置，是上面的二分搜索情况二的推广。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-10-1">class Solution {
</span><span id="__span-10-2">    //区间长度10^9,如果使用O(n)必然超时，需要二分
</span><span id="__span-10-3">    public int minEatingSpeed(int[] piles, int h) {
</span><span id="__span-10-4">        int l = 1, r = 0;
</span><span id="__span-10-5">        for(int pile : piles){
</span><span id="__span-10-6">            r = Math.max(r,pile);
</span><span id="__span-10-7">        }   
</span><span id="__span-10-8">        int ans = Integer.MIN_VALUE;
</span><span id="__span-10-9">        while(l&lt;=r){
</span><span id="__span-10-10">            int mid = l + (r-l)/2;
</span><span id="__span-10-11">            if(check(piles,mid,h)){
</span><span id="__span-10-12">                ans = mid;
</span><span id="__span-10-13">                r = mid-1;
</span><span id="__span-10-14">            }else{
</span><span id="__span-10-15">                l = mid+1;
</span><span id="__span-10-16">            }
</span><span id="__span-10-17">        }
</span><span id="__span-10-18">        return ans;
</span><span id="__span-10-19">    }
</span><span id="__span-10-20">    public static boolean check(int[]piles, int mid, int h){
</span><span id="__span-10-21">        //注意数据量到了10^9了。int类型范围到[-2亿，2亿]，换为long更保险
</span><span id="__span-10-22">        long cost = 0L;
</span><span id="__span-10-23">        for(int pile : piles){
</span><span id="__span-10-24">            cost += Math.ceilDiv(pile, mid);
</span><span id="__span-10-25">        }
</span><span id="__span-10-26">        return cost &lt;= h;
</span><span id="__span-10-27">    }
</span><span id="__span-10-28">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 410画匠问题</li>
</ol>
<p>给定一个非负整数数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;nums&lt;/span&gt;&lt;/span&gt;</code> 和一个整数 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> ，你需要将这个数组分成 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 个非空的连续子数组。</p>
<p>设计一个算法使得这 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 个子数组各自和的最大值最小。</p>
<p>抽象为画匠问题就是每个画家负责连续的一段，并行进行画作，最后结束的时间就是画家中耗时最久的时间。求最终任务结束的最小时间。</p>
<ol>
<li>思路：</li>
<li>s问题：每部分的累加和求出的最大值最小。</li>
<li>[l,r]计算：答案的可能值的最小值是0，最大值可以定的比较粗，可以假设为整个数组的累加和。</li>
<li>check函数：在每个部分的值不超过mid的情况下，则k最小值为多少就可以做到。</li>
<li>单调性：<ol>
<li>每一部分limit的增加，对应着k的最小值减小。我们要考虑的肯定是最值情况，而不是中间值的情况。</li>
<li>如果每一部分要求的结果的最大值limit增加，则对应的k值的最小值必然减小。</li>
</ol>
</li>
</ol>
<p>则如果目前的mid对应的k的最小值满足性质(至多k段)，则可以向mid减小的方向缩小范围继续二分。</p>
<p>否则需要向mid增加的方向缩小。</p>
<p><strong>💡</strong></p>
<p>题目要求划分成 k 段，但其实如果能划分成小于 k 段，也可以划分成 k 段。比如划分成 k−1 段，那么把其中的一个长度至少为 2 的段分成两段，这两段的元素和都比原来的一段小，也满足要求。所以题目相当于：把数组划分成至多 k 段，分别计算每一段的元素和，最小化元素和的最大值</p>
<p>遇到最大化最小值或最小化最大值，就是二分题型。</p>
<p>时间复杂度O(n * logsum)。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-11-1">class Solution {
</span><span id="__span-11-2">    public int splitArray(int[] nums, int k) {
</span><span id="__span-11-3">        int sum = 0;
</span><span id="__span-11-4">        for(int item : nums){
</span><span id="__span-11-5">            sum += item;
</span><span id="__span-11-6">        }
</span><span id="__span-11-7">        int l = 0, r = sum;
</span><span id="__span-11-8">        int ans = 0;
</span><span id="__span-11-9">        while(l&lt;=r){
</span><span id="__span-11-10">            int mid = l + (r-l)/2;
</span><span id="__span-11-11">            if(check(nums,mid,k)){
</span><span id="__span-11-12">                ans = mid;
</span><span id="__span-11-13">                r = mid-1;
</span><span id="__span-11-14">            }else{
</span><span id="__span-11-15">                l = mid+1;
</span><span id="__span-11-16">            }
</span><span id="__span-11-17">        }
</span><span id="__span-11-18">        return ans;
</span><span id="__span-11-19">    }
</span><span id="__span-11-20">    public static boolean check(int[] nums, int limit, int k){
</span><span id="__span-11-21">        int cnt = 1;
</span><span id="__span-11-22">        int cur = 0;
</span><span id="__span-11-23">        for(int item : nums){
</span><span id="__span-11-24">            if(item &gt; limit) return false;
</span><span id="__span-11-25">            if(cur + item &gt; limit){
</span><span id="__span-11-26">                cnt++;
</span><span id="__span-11-27">                cur = item;
</span><span id="__span-11-28">            }else{
</span><span id="__span-11-29">                cur += item;
</span><span id="__span-11-30">            }
</span><span id="__span-11-31">        }
</span><span id="__span-11-32">        return cnt&lt;=k;
</span><span id="__span-11-33">    }
</span><span id="__span-11-34">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 719 第k小的数对距离</li>
<li>题目：数对 <code>&lt;span&gt;(a,b)&lt;/span&gt;</code> 由整数 <code>&lt;span&gt;a&lt;/span&gt;</code> 和 <code>&lt;span&gt;b&lt;/span&gt;</code> 组成，其数对距离定义为 <code>&lt;span&gt;a&lt;/span&gt;</code> 和 <code>&lt;span&gt;b&lt;/span&gt;</code> 的绝对差值。返回第k小的数对距离。</li>
<li>思路：<ol>
<li>暴力：存储所有的数对，然后使用快速选择算法进行选择第k小。空间会被卡。</li>
<li>二分+空间优化：<ol>
<li>数组：任意两个数的距离</li>
<li>范围[l,r]: l=0, r = max-min</li>
<li>check:距离&lt;=mid的数量有几个</li>
<li>单调性：距离增加，则满足的数量必然增加。因为是求&lt;=某个距离的数量。 如果差值&lt;=mid，数量不足k个，则需要向[mid+1,r]搜索。否则如果数量&gt;=k个，则说明&gt;=mid的范围均满足，则向[l,mid-1]范围搜索。则最后结束就是dis&lt;=mid 刚好为k个的距离。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="_21">链表<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h2>
<h3 id="_22">按值传递和按引用传递：<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>int ,byte,short,long,char,float double,boolean 以及String是按值传递</p>
<p>其他是按照引用传递，比如所有的引用类型(数组，类，等)</p>
<h3 id="_23">单链表翻转：<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<p>三步曲：对于当前节点cur，</p>
<ol>
<li>保存cur.next的位置</li>
<li>改变指针也就是next指向，指向pre</li>
<li>pre向后移动</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-12-1">//单链表翻转：
</span><span id="__span-12-2">        public static ListNode reverseList(ListNode head) {
</span><span id="__span-12-3">            ListNode pre = null;
</span><span id="__span-12-4">            ListNode next = null;
</span><span id="__span-12-5">            while (head != null) {
</span><span id="__span-12-6">                next = head.next;
</span><span id="__span-12-7">//head.next = pre 最开始表示的是让head指向null
</span><span id="__span-12-8">                head.next = pre;
</span><span id="__span-12-9">                pre = head;
</span><span id="__span-12-10">//head随着每一步往后移动
</span><span id="__span-12-11">                head = next;
</span><span id="__span-12-12">            }
</span><span id="__span-12-13">            return pre;
</span><span id="__span-12-14">        }
</span><span id="__span-12-15">//也就是有pre = null,next = null;然后的话让两者同时平移到head和head.next
</span></code></pre></div></td></tr></table></div>
<h3 id="_24">双链表翻转：<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-13-1">    public static class DoubleListNode {
</span><span id="__span-13-2">        public int value;
</span><span id="__span-13-3">        public DoubleListNode last; //上一个
</span><span id="__span-13-4">        public DoubleListNode next; //下一个
</span><span id="__span-13-5">
</span><span id="__span-13-6">        public DoubleListNode(int v) {
</span><span id="__span-13-7">            value = v;
</span><span id="__span-13-8">        }
</span><span id="__span-13-9">    }
</span><span id="__span-13-10">
</span><span id="__span-13-11">    public static DoubleListNode reverseDoubleList(DoubleListNode head) {
</span><span id="__span-13-12">        DoubleListNode pre = null;
</span><span id="__span-13-13">        DoubleListNode next = null;
</span><span id="__span-13-14">        while (head != null) {
</span><span id="__span-13-15">            next = head.next;
</span><span id="__span-13-16">            head.next = pre;
</span><span id="__span-13-17">            head.last = next;
</span><span id="__span-13-18">            pre = head;
</span><span id="__span-13-19">
</span><span id="__span-13-20">            head = next;
</span><span id="__span-13-21">        }
</span><span id="__span-13-22">        return pre;
</span><span id="__span-13-23">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_25">合并两个有序链表：<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<p>一共三个变量：</p>
<ol>
<li>pre指向的是当前最新的排好的节点。</li>
<li>c1指向第一个等待排序的链表头</li>
<li>c2指向第二个等待排序的链表头</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-14-1">public static ListNode mergeTwoLists(ListNode head1, ListNode head2) {
</span><span id="__span-14-2">            if (head1 == null || head2 == null) {
</span><span id="__span-14-3">                return head1 == null ? head2 : head1;
</span><span id="__span-14-4">            }
</span><span id="__span-14-5">            ListNode head = head1.val &lt;= head2.val ? head1 : head2;
</span><span id="__span-14-6">            ListNode cur1 = head.next;
</span><span id="__span-14-7">            ListNode cur2 = head == head1 ? head2 : head1;
</span><span id="__span-14-8">            ListNode pre = head;
</span><span id="__span-14-9">            while (cur1 != null &amp;&amp; cur2 != null) {
</span><span id="__span-14-10">                if (cur1.val &lt;= cur2.val) {
</span><span id="__span-14-11">                    pre.next = cur1;
</span><span id="__span-14-12">                    cur1 = cur1.next;
</span><span id="__span-14-13">                } else {
</span><span id="__span-14-14">                    pre.next = cur2;
</span><span id="__span-14-15">                    cur2 = cur2.next;
</span><span id="__span-14-16">                }
</span><span id="__span-14-17">                pre = pre.next;
</span><span id="__span-14-18">            }
</span><span id="__span-14-19">            pre.next = cur1 != null ? cur1 : cur2;
</span><span id="__span-14-20">            return head;
</span><span id="__span-14-21">        }
</span><span id="__span-14-22">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_26">链表相加：<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>其实就是高精度大数相加，是一道模拟</p>
<p>注意留在本位的数字是sum % 10,而进位的是carry = sum / 10;</p>
<p>最后的进位由于都时空值已经退出循环了。所以需要特判。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-15-1">public static ListNode addTwoNumbers(ListNode h1, ListNode h2) {
</span><span id="__span-15-2">            ListNode ans = null, cur = null;
</span><span id="__span-15-3">            int carry = 0;
</span><span id="__span-15-4">            for (int sum, val; // 声明变量
</span><span id="__span-15-5">                    h1 != null || h2 != null; // 终止条件
</span><span id="__span-15-6">                    h1 = h1 == null ? null : h1.next, // 每一步h1的跳转
</span><span id="__span-15-7">                    h2 = h2 == null ? null : h2.next // 每一步h2的跳转
</span><span id="__span-15-8">                    ) {
</span><span id="__span-15-9">
</span><span id="__span-15-10">                sum = (h1 == null ? 0 : h1.val)
</span><span id="__span-15-11">                        + (h2 == null ? 0 : h2.val)
</span><span id="__span-15-12">                        + carry;
</span><span id="__span-15-13">
</span><span id="__span-15-14">                val = sum % 10;
</span><span id="__span-15-15">                carry = sum / 10;
</span><span id="__span-15-16">                if (ans == null) {
</span><span id="__span-15-17">                    ans = new ListNode(val);
</span><span id="__span-15-18">                    cur = ans;
</span><span id="__span-15-19">                } else {
</span><span id="__span-15-20">                    cur.next = new ListNode(val);
</span><span id="__span-15-21">                    cur = cur.next;
</span><span id="__span-15-22">                }
</span><span id="__span-15-23">            }
</span><span id="__span-15-24">            if (carry == 1) {
</span><span id="__span-15-25">                cur.next = new ListNode(1);
</span><span id="__span-15-26">            }
</span><span id="__span-15-27">            return ans;
</span><span id="__span-15-28">        }
</span></code></pre></div></td></tr></table></div>
<h3 id="_27">链表划分：<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p>给你一个链表的头节点 head 和一个特定值 x</p>
<p>请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置</p>
<p>核心思路：开两个链表，一个保存小的部分，一个保存大的部分，最后前一部分的next指向后一部分你的头。使用了一个next变量来保存遍历到节点的next指针。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-16-1">public static ListNode partition(ListNode head, int x) {
</span><span id="__span-16-2">            ListNode leftHead = null, leftTail = null; // &lt; x的区域
</span><span id="__span-16-3">            ListNode rightHead = null, rightTail = null; // &gt;=x的区域
</span><span id="__span-16-4">            ListNode next = null;
</span><span id="__span-16-5">            while (head != null) {
</span><span id="__span-16-6">                next = head.next;
</span><span id="__span-16-7">                head.next = null;
</span><span id="__span-16-8">                if (head.val &lt; x) {
</span><span id="__span-16-9">                    if (leftHead == null) {
</span><span id="__span-16-10">                        leftHead = head;
</span><span id="__span-16-11">                    } else {
</span><span id="__span-16-12">                        leftTail.next = head;
</span><span id="__span-16-13">                    }
</span><span id="__span-16-14">                    leftTail = head;
</span><span id="__span-16-15">                } else {
</span><span id="__span-16-16">                    if (rightHead == null) {
</span><span id="__span-16-17">                        rightHead = head;
</span><span id="__span-16-18">                    } else {
</span><span id="__span-16-19">                        rightTail.next = head;
</span><span id="__span-16-20">                    }
</span><span id="__span-16-21">                    rightTail = head;
</span><span id="__span-16-22">                }
</span><span id="__span-16-23">                head = next;
</span><span id="__span-16-24">            }
</span><span id="__span-16-25">            if (leftHead == null) {
</span><span id="__span-16-26">                return rightHead;
</span><span id="__span-16-27">            }
</span><span id="__span-16-28">            // &lt; x的区域有内容！
</span><span id="__span-16-29">            leftTail.next = rightHead;
</span><span id="__span-16-30">            return leftHead;
</span><span id="__span-16-31">        }
</span></code></pre></div></td></tr></table></div>
<h3 id="_28">***链表的高频题目总结<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>注意点：</p>
</li>
<li>
<p>一般通过核心代码模式进行</p>
</li>
<li>如果空间不严格，可以直接使用容器进行解决。</li>
<li>如果空间严格，需要优化空间，比如O(1)。</li>
<li>最常见技巧：快慢指针</li>
<li>核心考察点：coding能力</li>
<li>题目：</li>
<li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">返回两个无环链表相交的第一个节点 </a></li>
<li>题目：给定两个链表，判断结构上是不是有相交。</li>
<li>思路：</li>
<li>只判断是否相交：因为无环，所以结尾必然是相交的(同一个节点).单链表只有一个next指针，也不会有人字形的结构出现。</li>
<li>判断相交的第一个节点：如果长度分别是a,b 并且(b&gt;a)。则可以使b先走b-a步。然后两个链表同步走，必然会同时走到相交的位置。也可以通过使用HashSet来进行对象是否相等的判断，方法是先将一个结点全部存入HashSet中。在遍历另一个的时候进行判断。</li>
<li><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">k个一组翻转链表</a></li>
<li>给定一个链表，每k个节点一组进行调整。</li>
<li>思路：</li>
<li>使用容器：将链表所有节点的值放入数组中，然后对数组进行每k个翻转，最后再构建链表。</li>
<li>不使用容器：假设链表头部为a-&gt;b-&gt;c-&gt;d...，同时k=3则过程：先记住头c，反转后记住尾a,并将a-&gt;d。每次都要记住上一次的尾，因为上一个的尾会指向下一个新调整的头。</li>
</ol>
<p><img alt="image.png" src="../assets/listnode-01.png" /></p>
<ol>
<li>
<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">复制带随机指针的链表</a></p>
</li>
<li>
<p>题目背景：原来的单链表节点的指针多了一个random指针，可以指向该链表的任何节点或者null。要求对该链表进行深拷贝。</p>
</li>
<li>思路：<ol>
<li>使用容器：使用map结构。对原来的链表的节点作为key，新构造的节点作为value。然后遍历map在，对于一个k-v来说，新构造节点的next和random指针，可以通过查找key来确定。利用map对v的指针域赋值上对应的新构造的节点地址，从而达到深拷贝。</li>
</ol>
</li>
<li><a href="https://leetcode.cn/problems/palindrome-linked-list/">判断链表是否是回文结构</a></li>
<li>回文链表示例：30-&gt;100-&gt;30-&gt;null</li>
<li>思路：</li>
<li>使用栈进行判断：现将节点全部入栈，同时弹出节点和遍历链表，一一判断。</li>
<li>使用快慢指针：</li>
<li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">返回一个链表的入环节点</a></li>
<li>思路：</li>
<li>使用容器：使用HashSet。变量链表，如果不在就添加进去，当再次遍历的时候在了，就返回该节点</li>
<li>不使用容器(结论)：</li>
<li>先使用快慢指针(一个走两步，一个走一步)，到达第一个相遇的点</li>
<li>然后快指针回到开头，快慢指针同时走(同时走一步)，则必然在入环节点处相遇。</li>
</ol>
<h2 id="_29">队列和栈<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h2>
<p>队列和栈都是一种逻辑结构，物理结构可以用数组或者链表进行实现。</p>
<p>队列：先进先出,从尾进，从头出。</p>
<p>栈：先进后出</p>
<p>插入删除都是O(1)的时间复杂度</p>
<h3 id="_30">队列的实现：<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-17-1">public static class Queue1 {
</span><span id="__span-17-2">
</span><span id="__span-17-3">        // java中的双向链表LinkedList
</span><span id="__span-17-4">        // 单向链表就足够了
</span><span id="__span-17-5">        public Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
</span><span id="__span-17-6">
</span><span id="__span-17-7">        // 调用任何方法之前，先调用这个方法来判断队列内是否有东西
</span><span id="__span-17-8">        public boolean isEmpty() {
</span><span id="__span-17-9">            return queue.isEmpty();
</span><span id="__span-17-10">        }
</span><span id="__span-17-11">
</span><span id="__span-17-12">        // 向队列中加入num，加到尾巴
</span><span id="__span-17-13">        public void offer(int num) {
</span><span id="__span-17-14">            queue.offer(num);
</span><span id="__span-17-15">        }
</span><span id="__span-17-16">
</span><span id="__span-17-17">        // 从队列拿，从头拿
</span><span id="__span-17-18">        public int poll() {
</span><span id="__span-17-19">            return queue.poll();
</span><span id="__span-17-20">        }
</span><span id="__span-17-21">
</span><span id="__span-17-22">        // 返回队列头的元素但是不弹出
</span><span id="__span-17-23">        public int peek() {
</span><span id="__span-17-24">            return queue.peek();
</span><span id="__span-17-25">        }
</span><span id="__span-17-26">
</span><span id="__span-17-27">        // 返回目前队列里有几个数
</span><span id="__span-17-28">        public int size() {
</span><span id="__span-17-29">            return queue.size();
</span><span id="__span-17-30">        }
</span><span id="__span-17-31">
</span><span id="__span-17-32">    }
</span><span id="__span-17-33">
</span><span id="__span-17-34">//数组实现：
</span><span id="__span-17-35">// 实际刷题时更常见的写法，常数时间好
</span><span id="__span-17-36">    // 如果可以确定加入操作的总次数不超过n，那么可以用
</span><span id="__span-17-37">    // 一般笔试、面试都会有一个明确数据量，所以这是最常用的方式
</span><span id="__span-17-38">    // 队列的存储范围是[l,r)
</span><span id="__span-17-39">    public static class Queue2 {
</span><span id="__span-17-40">
</span><span id="__span-17-41">        public int[] queue;
</span><span id="__span-17-42">        public int l;
</span><span id="__span-17-43">        public int r;
</span><span id="__span-17-44">
</span><span id="__span-17-45">        // 加入操作的总次数上限是多少，一定要明确
</span><span id="__span-17-46">        public Queue2(int n) {
</span><span id="__span-17-47">            queue = new int[n];
</span><span id="__span-17-48">            l = 0;
</span><span id="__span-17-49">            r = 0;
</span><span id="__span-17-50">        }
</span><span id="__span-17-51">
</span><span id="__span-17-52">        // 调用任何方法之前，先调用这个方法来判断队列内是否有东西
</span><span id="__span-17-53">        public boolean isEmpty() {
</span><span id="__span-17-54">            return l == r;
</span><span id="__span-17-55">        }
</span><span id="__span-17-56">
</span><span id="__span-17-57">        public void offer(int num) {
</span><span id="__span-17-58">            queue[r++] = num;
</span><span id="__span-17-59">        }
</span><span id="__span-17-60">
</span><span id="__span-17-61">        public int poll() {
</span><span id="__span-17-62">            return queue[l++];
</span><span id="__span-17-63">        }
</span><span id="__span-17-64">        // ?
</span><span id="__span-17-65">        // l...r-1 r
</span><span id="__span-17-66">        // [l..r)
</span><span id="__span-17-67">        public int head() {
</span><span id="__span-17-68">            return queue[l];
</span><span id="__span-17-69">        }
</span><span id="__span-17-70">
</span><span id="__span-17-71">        public int tail() {
</span><span id="__span-17-72">            return queue[r - 1];
</span><span id="__span-17-73">        }
</span><span id="__span-17-74">
</span><span id="__span-17-75">        public int size() {
</span><span id="__span-17-76">            return r - l;
</span><span id="__span-17-77">        }
</span><span id="__span-17-78">
</span><span id="__span-17-79">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_31">栈的实现<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-18-1">// 直接用java内部的实现
</span><span id="__span-18-2">    // 其实就是动态数组，不过常数时间并不好
</span><span id="__span-18-3">    public static class Stack1 {
</span><span id="__span-18-4">
</span><span id="__span-18-5">        public Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
</span><span id="__span-18-6">
</span><span id="__span-18-7">        // 调用任何方法之前，先调用这个方法来判断栈内是否有东西
</span><span id="__span-18-8">        public boolean isEmpty() {
</span><span id="__span-18-9">            return stack.isEmpty();
</span><span id="__span-18-10">        }
</span><span id="__span-18-11">
</span><span id="__span-18-12">        public void push(int num) {
</span><span id="__span-18-13">            stack.push(num);
</span><span id="__span-18-14">        }
</span><span id="__span-18-15">
</span><span id="__span-18-16">        public int pop() {
</span><span id="__span-18-17">            return stack.pop();
</span><span id="__span-18-18">        }
</span><span id="__span-18-19">
</span><span id="__span-18-20">        public int peek() {
</span><span id="__span-18-21">            return stack.peek();
</span><span id="__span-18-22">        }
</span><span id="__span-18-23">
</span><span id="__span-18-24">        public int size() {
</span><span id="__span-18-25">            return stack.size();
</span><span id="__span-18-26">        }
</span><span id="__span-18-27">
</span><span id="__span-18-28">    }
</span><span id="__span-18-29">
</span><span id="__span-18-30">// 实际刷题时更常见的写法，常数时间好
</span><span id="__span-18-31">    // 如果可以保证同时在栈里的元素个数不会超过n，那么可以用
</span><span id="__span-18-32">    // 也就是发生弹出操作之后，空间可以复用
</span><span id="__span-18-33">    // 一般笔试、面试都会有一个明确数据量，所以这是最常用的方式
</span><span id="__span-18-34">    public static class Stack2 {
</span><span id="__span-18-35">
</span><span id="__span-18-36">        public int[] stack;
</span><span id="__span-18-37">        public int size;
</span><span id="__span-18-38">
</span><span id="__span-18-39">        // 同时在栈里的元素个数不会超过n
</span><span id="__span-18-40">        public Stack2(int n) {
</span><span id="__span-18-41">            stack = new int[n];
</span><span id="__span-18-42">            size = 0;
</span><span id="__span-18-43">        }
</span><span id="__span-18-44">
</span><span id="__span-18-45">        // 调用任何方法之前，先调用这个方法来判断栈内是否有东西
</span><span id="__span-18-46">        public boolean isEmpty() {
</span><span id="__span-18-47">            return size == 0;
</span><span id="__span-18-48">        }
</span><span id="__span-18-49">
</span><span id="__span-18-50">        public void push(int num) {
</span><span id="__span-18-51">            stack[size++] = num;
</span><span id="__span-18-52">        }
</span><span id="__span-18-53">
</span><span id="__span-18-54">        public int pop() {
</span><span id="__span-18-55">            return stack[--size];
</span><span id="__span-18-56">        }
</span><span id="__span-18-57">
</span><span id="__span-18-58">        public int peek() {
</span><span id="__span-18-59">            return stack[size - 1];
</span><span id="__span-18-60">        }
</span><span id="__span-18-61">
</span><span id="__span-18-62">        public int size() {
</span><span id="__span-18-63">            return size;
</span><span id="__span-18-64">        }
</span><span id="__span-18-65">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_32">环形队列的实现<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<p>底层还是使用数组。共有4个变量：l,r,size,limit。使用size来限制加入和弹出的操作</p>
<p>如果size &gt;0,可以弹出。如果size &lt; limit，可以加入。</p>
<p>队列的范围还是始终是[l,r)</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-19-1">class MyCircularQueue {
</span><span id="__span-19-2">
</span><span id="__span-19-3">        public int[] queue;
</span><span id="__span-19-4">
</span><span id="__span-19-5">        public int l, r, size, limit;
</span><span id="__span-19-6">
</span><span id="__span-19-7">        // 同时在队列里的数字个数，不要超过k
</span><span id="__span-19-8">        public MyCircularQueue(int k) {
</span><span id="__span-19-9">            queue = new int[k];
</span><span id="__span-19-10">            l = r = size = 0;
</span><span id="__span-19-11">            limit = k;
</span><span id="__span-19-12">        }
</span><span id="__span-19-13">
</span><span id="__span-19-14">        // 如果队列满了，什么也不做，返回false
</span><span id="__span-19-15">        // 如果队列没满，加入value，返回true
</span><span id="__span-19-16">        public boolean enQueue(int value) {
</span><span id="__span-19-17">            if (isFull()) {
</span><span id="__span-19-18">                return false;
</span><span id="__span-19-19">            } else {
</span><span id="__span-19-20">                queue[r] = value;
</span><span id="__span-19-21">                // r++, 结束了，跳回0
</span><span id="__span-19-22">                r = r == limit - 1 ? 0 : (r + 1);
</span><span id="__span-19-23">                size++;
</span><span id="__span-19-24">                return true;
</span><span id="__span-19-25">            }
</span><span id="__span-19-26">        }
</span><span id="__span-19-27">
</span><span id="__span-19-28">        // 如果队列空了，什么也不做，返回false
</span><span id="__span-19-29">        // 如果队列没空，弹出头部的数字，返回true
</span><span id="__span-19-30">        public boolean deQueue() {
</span><span id="__span-19-31">            if (isEmpty()) {
</span><span id="__span-19-32">                return false;
</span><span id="__span-19-33">            } else {
</span><span id="__span-19-34">                // l++, 结束了，跳回0
</span><span id="__span-19-35">                l = l == limit - 1 ? 0 : (l + 1);
</span><span id="__span-19-36">                size--;
</span><span id="__span-19-37">                return true;
</span><span id="__span-19-38">            }
</span><span id="__span-19-39">        }
</span><span id="__span-19-40">
</span><span id="__span-19-41">        // 返回队列头部的数字（不弹出），如果没有数返回-1
</span><span id="__span-19-42">        public int Front() {
</span><span id="__span-19-43">            if (isEmpty()) {
</span><span id="__span-19-44">                return -1;
</span><span id="__span-19-45">            } else {
</span><span id="__span-19-46">                return queue[l];
</span><span id="__span-19-47">            }
</span><span id="__span-19-48">        }
</span><span id="__span-19-49">        //返回队列尾部的数字，不弹出
</span><span id="__span-19-50">        public int Rear() {
</span><span id="__span-19-51">            if (isEmpty()) {
</span><span id="__span-19-52">                return -1;
</span><span id="__span-19-53">            } else {
</span><span id="__span-19-54">                int last = r == 0 ? (limit - 1) : (r - 1);
</span><span id="__span-19-55">                return queue[last];
</span><span id="__span-19-56">            }
</span><span id="__span-19-57">        }
</span><span id="__span-19-58">
</span><span id="__span-19-59">        public boolean isEmpty() {
</span><span id="__span-19-60">            return size == 0;
</span><span id="__span-19-61">        }
</span><span id="__span-19-62">
</span><span id="__span-19-63">        public boolean isFull() {
</span><span id="__span-19-64">            return size == limit;
</span><span id="__span-19-65">        }
</span><span id="__span-19-66">
</span><span id="__span-19-67">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_33">栈和队列相互实现<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h3>
<h4 id="_34">使用栈实现队列：<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h4>
<p>方法：使用in, out两个栈</p>
<ol>
<li>out 必须为空，in才能倒入数据</li>
<li>in只要倒入数据，就必须倒完</li>
<li>自己封装的时候，无论是push,pop还是peek都调用inToOut，能不能执行方法体取决于上面两个条件。push的方法在in中操作，pop和peek在out中操作。</li>
<li>时间复杂度：每个数顶多都只会执行4次操作。所以为O(1)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-20-1">class MyQueue {
</span><span id="__span-20-2">
</span><span id="__span-20-3">        public Stack&lt;Integer&gt; in;
</span><span id="__span-20-4">
</span><span id="__span-20-5">        public Stack&lt;Integer&gt; out;
</span><span id="__span-20-6">
</span><span id="__span-20-7">        public MyQueue() {
</span><span id="__span-20-8">            in = new Stack&lt;Integer&gt;();
</span><span id="__span-20-9">            out = new Stack&lt;Integer&gt;();
</span><span id="__span-20-10">        }
</span><span id="__span-20-11">
</span><span id="__span-20-12">        // 倒数据
</span><span id="__span-20-13">        // 从in栈，把数据倒入out栈
</span><span id="__span-20-14">        // 1) out空了，才能倒数据
</span><span id="__span-20-15">        // 2) 如果倒数据，in必须倒完
</span><span id="__span-20-16">        private void inToOut() {
</span><span id="__span-20-17">            if (out.empty()) {
</span><span id="__span-20-18">                while (!in.empty()) {
</span><span id="__span-20-19">                    out.push(in.pop());
</span><span id="__span-20-20">                }
</span><span id="__span-20-21">            }
</span><span id="__span-20-22">        }
</span><span id="__span-20-23">
</span><span id="__span-20-24">        public void push(int x) {
</span><span id="__span-20-25">            in.push(x);
</span><span id="__span-20-26">            inToOut();
</span><span id="__span-20-27">        }
</span><span id="__span-20-28">
</span><span id="__span-20-29">        public int pop() {
</span><span id="__span-20-30">            inToOut();
</span><span id="__span-20-31">            return out.pop();
</span><span id="__span-20-32">        }
</span><span id="__span-20-33">
</span><span id="__span-20-34">        public int peek() {
</span><span id="__span-20-35">            inToOut();
</span><span id="__span-20-36">            return out.peek();
</span><span id="__span-20-37">        }
</span><span id="__span-20-38">
</span><span id="__span-20-39">        public boolean empty() {
</span><span id="__span-20-40">            return in.isEmpty() &amp;&amp; out.isEmpty();
</span><span id="__span-20-41">        }
</span><span id="__span-20-42">
</span><span id="__span-20-43">    }
</span></code></pre></div></td></tr></table></div>
<h4 id="_35">队列实现栈：<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h4>
<p>队列：尾进头出</p>
<p>核心思想：队列出队是顺序的，而栈弹出的话为倒序。所以每次都把队列新加入的数前面的数全部从队列头弹出，再从尾部进入，也就是逆序。</p>
<p>单次push的时间复杂度是O(n)；</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-21-1">class MyStack {
</span><span id="__span-21-2">
</span><span id="__span-21-3">        Queue&lt;Integer&gt; queue;
</span><span id="__span-21-4">
</span><span id="__span-21-5">        public MyStack() {
</span><span id="__span-21-6">            queue = new LinkedList&lt;Integer&gt;();
</span><span id="__span-21-7">        }
</span><span id="__span-21-8">
</span><span id="__span-21-9">        // O(n)
</span><span id="__span-21-10">        public void push(int x) {
</span><span id="__span-21-11">            int n = queue.size();
</span><span id="__span-21-12">            queue.offer(x);
</span><span id="__span-21-13">            for (int i = 0; i &lt; n; i++) {
</span><span id="__span-21-14">                queue.offer(queue.poll());
</span><span id="__span-21-15">            }
</span><span id="__span-21-16">        }
</span><span id="__span-21-17">
</span><span id="__span-21-18">        public int pop() {
</span><span id="__span-21-19">            return queue.poll();
</span><span id="__span-21-20">        }
</span><span id="__span-21-21">
</span><span id="__span-21-22">        public int top() {
</span><span id="__span-21-23">            return queue.peek();
</span><span id="__span-21-24">        }
</span><span id="__span-21-25">
</span><span id="__span-21-26">        public boolean empty() {
</span><span id="__span-21-27">            return queue.isEmpty();
</span><span id="__span-21-28">        }
</span><span id="__span-21-29">
</span><span id="__span-21-30">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_36">最小栈<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h3>
<p>除了实现常规的栈功能，还需要实现getmin方法，这个方法需要可以在任何时候用O(1)的时间复杂度内找到最小值</p>
<p>方法</p>
<ol>
<li>使用两个栈 data 和 min</li>
<li>min随着data的压入数据，每一次和最小栈的栈顶对比。</li>
<li>如果当前数字大于min栈顶，重复压入min的栈顶。如果小于min栈顶，则压入data中新加入的数据。</li>
<li>初始情况：如果min为空，则data栈也必然为空，同步压入数据就可以。</li>
<li>每次弹出的时候，data和min同步弹出</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-22-1">//使用数组实现的部分
</span><span id="__span-22-2">class MinStack2 {
</span><span id="__span-22-3">        // leetcode的数据在测试时，同时在栈里的数据不超过这个值
</span><span id="__span-22-4">        // 这是几次提交实验出来的，哈哈
</span><span id="__span-22-5">        // 如果leetcode补测试数据了，超过这个量导致出错，就调大
</span><span id="__span-22-6">        public final int MAXN = 8001;
</span><span id="__span-22-7">
</span><span id="__span-22-8">        public int[] data;
</span><span id="__span-22-9">        public int[] min;
</span><span id="__span-22-10">        int size;
</span><span id="__span-22-11">
</span><span id="__span-22-12">        public MinStack2() {
</span><span id="__span-22-13">            data = new int[MAXN];
</span><span id="__span-22-14">            min = new int[MAXN];
</span><span id="__span-22-15">            size = 0;
</span><span id="__span-22-16">        }
</span><span id="__span-22-17">
</span><span id="__span-22-18">        public void push(int val) {
</span><span id="__span-22-19">            data[size] = val;
</span><span id="__span-22-20">            if (size == 0 || val &lt;= min[size - 1]) {
</span><span id="__span-22-21">                min[size] = val;
</span><span id="__span-22-22">            } else {
</span><span id="__span-22-23">                min[size] = min[size - 1];
</span><span id="__span-22-24">            }
</span><span id="__span-22-25">            size++;
</span><span id="__span-22-26">        }
</span><span id="__span-22-27">
</span><span id="__span-22-28">        public void pop() {
</span><span id="__span-22-29">            size--;
</span><span id="__span-22-30">        }
</span><span id="__span-22-31">
</span><span id="__span-22-32">        public int top() {
</span><span id="__span-22-33">            return data[size - 1];
</span><span id="__span-22-34">        }
</span><span id="__span-22-35">
</span><span id="__span-22-36">        public int getMin() {
</span><span id="__span-22-37">            return min[size - 1];
</span><span id="__span-22-38">        }
</span><span id="__span-22-39">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_37">双端队列：<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>可以直接使用内部的LinkedList实现Deque接口，也可以使用数组实现。</p>
<p>数组实现的效率比较高，LinkedList实现比较简洁。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  1</span>
<span class="normal">  2</span>
<span class="normal">  3</span>
<span class="normal">  4</span>
<span class="normal">  5</span>
<span class="normal">  6</span>
<span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-23-1">class MyCircularDeque1 {
</span><span id="__span-23-2">
</span><span id="__span-23-3">        public Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); //
</span><span id="__span-23-4">        public int size;
</span><span id="__span-23-5">        public int limit;
</span><span id="__span-23-6">
</span><span id="__span-23-7">        public MyCircularDeque1(int k) {
</span><span id="__span-23-8">            size = 0;
</span><span id="__span-23-9">            limit = k;
</span><span id="__span-23-10">        }
</span><span id="__span-23-11">
</span><span id="__span-23-12">        public boolean insertFront(int value) {
</span><span id="__span-23-13">            if (isFull()) {
</span><span id="__span-23-14">                return false;
</span><span id="__span-23-15">            } else {
</span><span id="__span-23-16">                deque.offerFirst(value);
</span><span id="__span-23-17">                size++;
</span><span id="__span-23-18">                return true;
</span><span id="__span-23-19">            }
</span><span id="__span-23-20">        }
</span><span id="__span-23-21">
</span><span id="__span-23-22">        public boolean insertLast(int value) {
</span><span id="__span-23-23">            if (isFull()) {
</span><span id="__span-23-24">                return false;
</span><span id="__span-23-25">            } else {
</span><span id="__span-23-26">                deque.offerLast(value);
</span><span id="__span-23-27">                size++;
</span><span id="__span-23-28">                return true;
</span><span id="__span-23-29">            }
</span><span id="__span-23-30">        }
</span><span id="__span-23-31">
</span><span id="__span-23-32">        public boolean deleteFront() {
</span><span id="__span-23-33">            if (isEmpty()) {
</span><span id="__span-23-34">                return false;
</span><span id="__span-23-35">            } else {
</span><span id="__span-23-36">                size--;
</span><span id="__span-23-37">                deque.pollFirst();
</span><span id="__span-23-38">                return true;
</span><span id="__span-23-39">            }
</span><span id="__span-23-40">        }
</span><span id="__span-23-41">
</span><span id="__span-23-42">        public boolean deleteLast() {
</span><span id="__span-23-43">            if (isEmpty()) {
</span><span id="__span-23-44">                return false;
</span><span id="__span-23-45">            } else {
</span><span id="__span-23-46">                size--;
</span><span id="__span-23-47">                deque.pollLast();
</span><span id="__span-23-48">                return true;
</span><span id="__span-23-49">            }
</span><span id="__span-23-50">        }
</span><span id="__span-23-51">
</span><span id="__span-23-52">        public int getFront() {
</span><span id="__span-23-53">            if (isEmpty()) {
</span><span id="__span-23-54">                return -1;
</span><span id="__span-23-55">            } else {
</span><span id="__span-23-56">                return deque.peekFirst();
</span><span id="__span-23-57">            }
</span><span id="__span-23-58">        }
</span><span id="__span-23-59">
</span><span id="__span-23-60">        public int getRear() {
</span><span id="__span-23-61">            if (isEmpty()) {
</span><span id="__span-23-62">                return -1;
</span><span id="__span-23-63">            } else {
</span><span id="__span-23-64">                return deque.peekLast();
</span><span id="__span-23-65">            }
</span><span id="__span-23-66">        }
</span><span id="__span-23-67">
</span><span id="__span-23-68">        public boolean isEmpty() {
</span><span id="__span-23-69">            return size == 0;
</span><span id="__span-23-70">        }
</span><span id="__span-23-71">
</span><span id="__span-23-72">        public boolean isFull() {
</span><span id="__span-23-73">            return size == limit;
</span><span id="__span-23-74">        }
</span><span id="__span-23-75">
</span><span id="__span-23-76">//使用数组实现：
</span><span id="__span-23-77">class MyCircularDeque2 {
</span><span id="__span-23-78">
</span><span id="__span-23-79">        public int[] deque;
</span><span id="__span-23-80">        public int l, r, size, limit;
</span><span id="__span-23-81">
</span><span id="__span-23-82">        public MyCircularDeque2(int k) {
</span><span id="__span-23-83">            deque = new int[k];
</span><span id="__span-23-84">            l = r = size = 0;
</span><span id="__span-23-85">            limit = k;
</span><span id="__span-23-86">        }
</span><span id="__span-23-87">
</span><span id="__span-23-88">        public boolean insertFront(int value) {
</span><span id="__span-23-89">            if (isFull()) {
</span><span id="__span-23-90">                return false;
</span><span id="__span-23-91">            } else {
</span><span id="__span-23-92">                if (isEmpty()) {
</span><span id="__span-23-93">                    l = r = 0;
</span><span id="__span-23-94">                    deque[0] = value;
</span><span id="__span-23-95">                } else {
</span><span id="__span-23-96">                    l = l == 0 ? (limit - 1) : (l - 1);
</span><span id="__span-23-97">                    deque[l] = value;
</span><span id="__span-23-98">                }
</span><span id="__span-23-99">                size++;
</span><span id="__span-23-100">                return true;
</span><span id="__span-23-101">            }
</span><span id="__span-23-102">        }
</span><span id="__span-23-103">
</span><span id="__span-23-104">        public boolean insertLast(int value) {
</span><span id="__span-23-105">            if (isFull()) {
</span><span id="__span-23-106">                return false;
</span><span id="__span-23-107">            } else {
</span><span id="__span-23-108">                if (isEmpty()) {
</span><span id="__span-23-109">                    l = r = 0;
</span><span id="__span-23-110">                    deque[0] = value;
</span><span id="__span-23-111">                } else {
</span><span id="__span-23-112">                    r = r == limit - 1 ? 0 : (r + 1);
</span><span id="__span-23-113">                    deque[r] = value;
</span><span id="__span-23-114">                }
</span><span id="__span-23-115">                size++;
</span><span id="__span-23-116">                return true;
</span><span id="__span-23-117">            }
</span><span id="__span-23-118">        }
</span><span id="__span-23-119">
</span><span id="__span-23-120">        public boolean deleteFront() {
</span><span id="__span-23-121">            if (isEmpty()) {
</span><span id="__span-23-122">                return false;
</span><span id="__span-23-123">            } else {
</span><span id="__span-23-124">                l = (l == limit - 1) ? 0 : (l + 1);
</span><span id="__span-23-125">                size--;
</span><span id="__span-23-126">                return true;
</span><span id="__span-23-127">            }
</span><span id="__span-23-128">        }
</span><span id="__span-23-129">
</span><span id="__span-23-130">        public boolean deleteLast() {
</span><span id="__span-23-131">            if (isEmpty()) {
</span><span id="__span-23-132">                return false;
</span><span id="__span-23-133">            } else {
</span><span id="__span-23-134">                r = r == 0 ? (limit - 1) : (r - 1);
</span><span id="__span-23-135">                size--;
</span><span id="__span-23-136">                return true;
</span><span id="__span-23-137">            }
</span><span id="__span-23-138">        }
</span><span id="__span-23-139">
</span><span id="__span-23-140">        public int getFront() {
</span><span id="__span-23-141">            if (isEmpty()) {
</span><span id="__span-23-142">                return -1;
</span><span id="__span-23-143">            } else {
</span><span id="__span-23-144">                return deque[l];
</span><span id="__span-23-145">            }
</span><span id="__span-23-146">        }
</span><span id="__span-23-147">
</span><span id="__span-23-148">        public int getRear() {
</span><span id="__span-23-149">            if (isEmpty()) {
</span><span id="__span-23-150">                return -1;
</span><span id="__span-23-151">            } else {
</span><span id="__span-23-152">                return deque[r];
</span><span id="__span-23-153">            }
</span><span id="__span-23-154">        }
</span><span id="__span-23-155">
</span><span id="__span-23-156">        public boolean isEmpty() {
</span><span id="__span-23-157">            return size == 0;
</span><span id="__span-23-158">        }
</span><span id="__span-23-159">
</span><span id="__span-23-160">        public boolean isFull() {
</span><span id="__span-23-161">            return size == limit;
</span><span id="__span-23-162">        }
</span></code></pre></div></td></tr></table></div>
<h2 id="_38">二叉树：<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h2>
<h3 id="_39">递归遍历：<a class="headerlink" href="#_39" title="Permanent link">&para;</a></h3>
<p>前序，中序，后序：</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-24-1">public static void preOrder(TreeNode head) {
</span><span id="__span-24-2">        if (head == null) {
</span><span id="__span-24-3">            return;
</span><span id="__span-24-4">        }
</span><span id="__span-24-5">        System.out.print(head.val + &quot; &quot;);
</span><span id="__span-24-6">        preOrder(head.left);
</span><span id="__span-24-7">        preOrder(head.right);
</span><span id="__span-24-8">    }
</span><span id="__span-24-9">
</span><span id="__span-24-10">    // 中序打印所有节点，递归版
</span><span id="__span-24-11">    public static void inOrder(TreeNode head) {
</span><span id="__span-24-12">        if (head == null) {
</span><span id="__span-24-13">            return;
</span><span id="__span-24-14">        }
</span><span id="__span-24-15">        inOrder(head.left);
</span><span id="__span-24-16">        System.out.print(head.val + &quot; &quot;);
</span><span id="__span-24-17">        inOrder(head.right);
</span><span id="__span-24-18">    }
</span><span id="__span-24-19">
</span><span id="__span-24-20">    // 后序打印所有节点，递归版
</span><span id="__span-24-21">    public static void posOrder(TreeNode head) {
</span><span id="__span-24-22">        if (head == null) {
</span><span id="__span-24-23">            return;
</span><span id="__span-24-24">        }
</span><span id="__span-24-25">        posOrder(head.left);
</span><span id="__span-24-26">        posOrder(head.right);
</span><span id="__span-24-27">        System.out.print(head.val + &quot; &quot;);
</span><span id="__span-24-28">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_40">非递归遍历：<a class="headerlink" href="#_40" title="Permanent link">&para;</a></h3>
<ol>
<li>对于先序遍历：</li>
<li>使用一个栈</li>
<li>注意判空</li>
<li>每次对于弹出的节点，弹出就执行相关操作，然后先压入右子节点，再压入左子节点。</li>
<li>对于中序遍历：</li>
<li>首先，让整个左树的左边界全部进入栈，直到为空</li>
<li>然后开始弹出，每弹出一个节点执行相关操作，然后对于它的右树，重复步骤a</li>
<li>重点是对于每一个节点，都是处理干净左子树，然后对自己进行操作，再进行右子树重复。这就是中序遍历</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-25-1">// 先序打印所有节点，非递归版
</span><span id="__span-25-2">    public static void preOrder(TreeNode head) {
</span><span id="__span-25-3">        if (head != null) {
</span><span id="__span-25-4">            Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
</span><span id="__span-25-5">            stack.push(head);
</span><span id="__span-25-6">            while (!stack.isEmpty()) {
</span><span id="__span-25-7">                head = stack.pop();
</span><span id="__span-25-8">                System.out.print(head.val + &quot; &quot;);
</span><span id="__span-25-9">                if (head.right != null) {
</span><span id="__span-25-10">                    stack.push(head.right);
</span><span id="__span-25-11">                }
</span><span id="__span-25-12">                if (head.left != null) {
</span><span id="__span-25-13">                    stack.push(head.left);
</span><span id="__span-25-14">                }
</span><span id="__span-25-15">            }
</span><span id="__span-25-16">            System.out.println();
</span><span id="__span-25-17">        }
</span><span id="__span-25-18">    }
</span><span id="__span-25-19">
</span><span id="__span-25-20">    // 中序打印所有节点，非递归版
</span><span id="__span-25-21">    public static void inOrder(TreeNode head) {
</span><span id="__span-25-22">        if (head != null) {
</span><span id="__span-25-23">            Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
</span><span id="__span-25-24">            //栈不为空，或者当前的子树不为空
</span><span id="__span-25-25">            while (!stack.isEmpty() || head != null) {
</span><span id="__span-25-26">                if (head != null) {
</span><span id="__span-25-27">                    stack.push(head);
</span><span id="__span-25-28">                    head = head.left;
</span><span id="__span-25-29">                } else {
</span><span id="__span-25-30">                    //head等于自己弹出的节点
</span><span id="__span-25-31">                    head = stack.pop();
</span><span id="__span-25-32">                    System.out.print(head.val + &quot; &quot;);
</span><span id="__span-25-33">                    head = head.right;
</span><span id="__span-25-34">                }
</span><span id="__span-25-35">            }
</span><span id="__span-25-36">            System.out.println();
</span><span id="__span-25-37">        }
</span><span id="__span-25-38">    }
</span><span id="__span-25-39">
</span><span id="__span-25-40">    // 后序打印所有节点，非递归版
</span><span id="__span-25-41">    // 这是用两个栈的方法
</span><span id="__span-25-42">    public static void posOrderTwoStacks(TreeNode head) {
</span><span id="__span-25-43">        if (head != null) {
</span><span id="__span-25-44">            Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
</span><span id="__span-25-45">            Stack&lt;TreeNode&gt; collect = new Stack&lt;&gt;();
</span><span id="__span-25-46">            stack.push(head);
</span><span id="__span-25-47">            while (!stack.isEmpty()) {
</span><span id="__span-25-48">                head = stack.pop();
</span><span id="__span-25-49">                collect.push(head);
</span><span id="__span-25-50">                if (head.left != null) {
</span><span id="__span-25-51">                    stack.push(head.left);
</span><span id="__span-25-52">                }
</span><span id="__span-25-53">                if (head.right != null) {
</span><span id="__span-25-54">                    stack.push(head.right);
</span><span id="__span-25-55">                }
</span><span id="__span-25-56">            }
</span><span id="__span-25-57">            while (!collect.isEmpty()) {
</span><span id="__span-25-58">                System.out.print(collect.pop().val + &quot; &quot;);
</span><span id="__span-25-59">            }
</span><span id="__span-25-60">            System.out.println();
</span><span id="__span-25-61">        }
</span><span id="__span-25-62">    }
</span><span id="__span-25-63">
</span><span id="__span-25-64">    // 后序打印所有节点，非递归版
</span><span id="__span-25-65">    // 这是用一个栈的方法
</span><span id="__span-25-66">    public static void posOrderOneStack(TreeNode h) {
</span><span id="__span-25-67">        if (h != null) {
</span><span id="__span-25-68">            Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
</span><span id="__span-25-69">            stack.push(h);
</span><span id="__span-25-70">            // 如果始终没有打印过节点，h就一直是头节点
</span><span id="__span-25-71">            // 一旦打印过节点，h就变成打印节点
</span><span id="__span-25-72">            // 之后h的含义 : 上一次打印的节点
</span><span id="__span-25-73">            while (!stack.isEmpty()) {
</span><span id="__span-25-74">                TreeNode cur = stack.peek();
</span><span id="__span-25-75">                if (cur.left != null &amp;&amp; h != cur.left &amp;&amp; h != cur.right) {
</span><span id="__span-25-76">                    // 有左树且左树没处理过
</span><span id="__span-25-77">                    stack.push(cur.left);
</span><span id="__span-25-78">                } else if (cur.right != null &amp;&amp; h != cur.right) {
</span><span id="__span-25-79">                    // 有右树且右树没处理过
</span><span id="__span-25-80">                    stack.push(cur.right);
</span><span id="__span-25-81">                } else {
</span><span id="__span-25-82">                    // 左树、右树 没有 或者 都处理过了
</span><span id="__span-25-83">                    System.out.print(cur.val + &quot; &quot;);
</span><span id="__span-25-84">                    h = stack.pop();
</span><span id="__span-25-85">                }
</span><span id="__span-25-86">            }
</span><span id="__span-25-87">            System.out.println();
</span><span id="__span-25-88">        }
</span><span id="__span-25-89">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_41">二叉树高频题<a class="headerlink" href="#_41" title="Permanent link">&para;</a></h3>
<h4 id="_42"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a><a class="headerlink" href="#_42" title="Permanent link">&para;</a></h4>
<ol>
<li>思路1：bfs。使用队列实现，一节节点入队并操作之后，弹出，有左加左，有右加右。而按层收集节点的时候，通过哈希表进行收集每个节点所对应的层数。</li>
<li>思路2：bfs优化版，使用数组模拟队列。然后一次处理一层数据。</li>
<li>获得当前的队列长度size</li>
<li>循环size次，对每个节点进行操作，左右入队。最后添加该层结果到最终结果。</li>
<li>代码实现：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-26-1">//思路一：
</span><span id="__span-26-2">class Solution {
</span><span id="__span-26-3">    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span><span id="__span-26-4">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
</span><span id="__span-26-5">        if(root == null) return new ArrayList&lt;&gt;();
</span><span id="__span-26-6">
</span><span id="__span-26-7">        Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();
</span><span id="__span-26-8">        HashMap&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;();
</span><span id="__span-26-9">        que.offer(root);
</span><span id="__span-26-10">        map.put(root,0);
</span><span id="__span-26-11">        while(!que.isEmpty()){
</span><span id="__span-26-12">            TreeNode cur = que.poll();
</span><span id="__span-26-13">            int level = map.get(cur);
</span><span id="__span-26-14">            if(level == res.size()){
</span><span id="__span-26-15">                res.add(new ArrayList&lt;&gt;());
</span><span id="__span-26-16">            }
</span><span id="__span-26-17">            res.get(level).add(cur.val);
</span><span id="__span-26-18">            if(cur.left != null){
</span><span id="__span-26-19">                que.offer(cur.left);
</span><span id="__span-26-20">                map.put(cur.left,level+1);
</span><span id="__span-26-21">            }
</span><span id="__span-26-22">            if(cur.right != null){
</span><span id="__span-26-23">                que.offer(cur.right);
</span><span id="__span-26-24">                map.put(cur.right,level+1);
</span><span id="__span-26-25">            }
</span><span id="__span-26-26">        }
</span><span id="__span-26-27">        return res;
</span><span id="__span-26-28">    }
</span><span id="__span-26-29">}
</span><span id="__span-26-30">
</span><span id="__span-26-31">//思路二
</span><span id="__span-26-32">class Solution {
</span><span id="__span-26-33">    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
</span><span id="__span-26-34">    private int MAXN = 2001;
</span><span id="__span-26-35">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
</span><span id="__span-26-36">        if(root == null) return new ArrayList&lt;&gt;();
</span><span id="__span-26-37">
</span><span id="__span-26-38">        TreeNode[] que = new TreeNode[MAXN];
</span><span id="__span-26-39">        int l=0,r=0;
</span><span id="__span-26-40">        que[r++] = root;
</span><span id="__span-26-41">
</span><span id="__span-26-42">        while(l&lt;r){
</span><span id="__span-26-43">            int size = r-l;
</span><span id="__span-26-44">            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
</span><span id="__span-26-45">            for(int i=0; i&lt;size; i++){
</span><span id="__span-26-46">                TreeNode cur = que[l++];
</span><span id="__span-26-47">                level.add(cur.val);
</span><span id="__span-26-48">                if(cur.left != null){
</span><span id="__span-26-49">                    que[r++] = cur.left;
</span><span id="__span-26-50">                }
</span><span id="__span-26-51">                if(cur.right != null){
</span><span id="__span-26-52">                    que[r++] = cur.right;
</span><span id="__span-26-53">                }
</span><span id="__span-26-54">            }
</span><span id="__span-26-55">            res.add(level);
</span><span id="__span-26-56">        }
</span><span id="__span-26-57">        return res;
</span><span id="__span-26-58">    }
</span><span id="__span-26-59">}
</span></code></pre></div></td></tr></table></div>
<h4 id="_43"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿状遍历</a>：<a class="headerlink" href="#_43" title="Permanent link">&para;</a></h4>
<ol>
<li>要求：二叉树的层序遍历，但是左右交替。</li>
<li>思路：可以在for循环的时候处理左右循环的时候控制，也可以对每层结果进行翻转。</li>
</ol>
<h4 id="_44"><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">二叉树的最大特殊宽度</a><a class="headerlink" href="#_44" title="Permanent link">&para;</a></h4>
<ol>
<li>二叉树每层的宽度定义为最左和最右非空节点之间的节点数。中间的null值也占据空间</li>
<li>使用bfs数组优化版，通过引入编号(i,2*i,2*i+1)来避免操作null节点。</li>
</ol>
<p><img alt="image.png" src="../assets/tree01.png" /></p>
<ol>
<li>二叉树的最大和最小深度：</li>
<li>思路：最大深度：使用递归求解。max(left,right)+1；</li>
<li>思路：最小深度：注意递归终止点是叶子结点。需要防止null值干扰。常规操作是现将值设置为MAX_VALUE，如果存在叶子节点，自然会在比较的之后被替换掉。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-27-1">class Solution {
</span><span id="__span-27-2">    public int minDepth(TreeNode root) {
</span><span id="__span-27-3">        //特判，并不是递归终止点。
</span><span id="__span-27-4">        if(root == null){
</span><span id="__span-27-5">            return 0;
</span><span id="__span-27-6">        }
</span><span id="__span-27-7">        //递归终止点
</span><span id="__span-27-8">        if(root.left == null &amp;&amp; root.right == null){
</span><span id="__span-27-9">            return 1;  
</span><span id="__span-27-10">        }
</span><span id="__span-27-11">
</span><span id="__span-27-12">        int ldeep = Integer.MAX_VALUE;
</span><span id="__span-27-13">        int rdeep = Integer.MAX_VALUE;
</span><span id="__span-27-14">
</span><span id="__span-27-15">        if(root.left != null) ldeep = minDepth(root.left);
</span><span id="__span-27-16">        if(root.right != null) rdeep = minDepth(root.right);
</span><span id="__span-27-17">
</span><span id="__span-27-18">        return Math.min(ldeep,rdeep)+1;
</span><span id="__span-27-19">
</span><span id="__span-27-20">
</span><span id="__span-27-21">    }
</span><span id="__span-27-22">}
</span></code></pre></div></td></tr></table></div>
<h4 id="_45">二叉树的序列化和反序列化<a class="headerlink" href="#_45" title="Permanent link">&para;</a></h4>
<ol>
<li>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</li>
<li>思路：哪种方式遍历(dfs,bfs)都可以。</li>
<li>dfs先序遍历：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-28-1">public class Codec {
</span><span id="__span-28-2">    private int cnt = 0;
</span><span id="__span-28-3">    // Encodes a tree to a single string.
</span><span id="__span-28-4">    public String serialize(TreeNode root) {
</span><span id="__span-28-5">        StringBuilder str = new StringBuilder();
</span><span id="__span-28-6">        encode(root,str);
</span><span id="__span-28-7">        return str.toString();
</span><span id="__span-28-8">    }
</span><span id="__span-28-9">    private void encode(TreeNode root,StringBuilder s){
</span><span id="__span-28-10">        if(root == null){
</span><span id="__span-28-11">            s.append(&quot;#,&quot;);
</span><span id="__span-28-12">            return;
</span><span id="__span-28-13">        }
</span><span id="__span-28-14">        s.append(root.val + &quot;,&quot;);
</span><span id="__span-28-15">        encode(root.left,s);
</span><span id="__span-28-16">        encode(root.right,s);
</span><span id="__span-28-17">    }
</span><span id="__span-28-18">
</span><span id="__span-28-19">    // Decodes your encoded data to tree.
</span><span id="__span-28-20">    public TreeNode deserialize(String data) {
</span><span id="__span-28-21">        String[] vals = data.split(&quot;,&quot;);
</span><span id="__span-28-22">        cnt = 0;
</span><span id="__span-28-23">        return decode(vals);
</span><span id="__span-28-24">    }
</span><span id="__span-28-25">
</span><span id="__span-28-26">    private TreeNode decode(String[] vals){
</span><span id="__span-28-27">        String cur = vals[cnt++];
</span><span id="__span-28-28">        if(cur.equals(&quot;#&quot;)){
</span><span id="__span-28-29">            return null;
</span><span id="__span-28-30">        }
</span><span id="__span-28-31">        //前序遍历解决
</span><span id="__span-28-32">        TreeNode head = new TreeNode(Integer.valueOf(cur));
</span><span id="__span-28-33">        head.left = decode(vals);
</span><span id="__span-28-34">        head.right = decode(vals);
</span><span id="__span-28-35">
</span><span id="__span-28-36">        return head;
</span><span id="__span-28-37">
</span><span id="__span-28-38">    }
</span><span id="__span-28-39">}
</span></code></pre></div></td></tr></table></div>
<h4 id="_46"><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">利用先序遍历和中序遍历构建二叉树</a><a class="headerlink" href="#_46" title="Permanent link">&para;</a></h4>
<ol>
<li>原理：没有重复值的情况下(例如1,1,1)：中序和先序/后序会唯一确定一颗二叉树</li>
<li>思路：构造递归函数，通过头节点位置划分子区间进行递归</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-29-1">public static TreeNode buildTree(int[] pre, int[] in) {
</span><span id="__span-29-2">        if (pre == null || in == null || pre.length != in.length) {
</span><span id="__span-29-3">            return null;
</span><span id="__span-29-4">        }
</span><span id="__span-29-5">        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
</span><span id="__span-29-6">        for (int i = 0; i &lt; in.length; i++) {
</span><span id="__span-29-7">            map.put(in[i], i);
</span><span id="__span-29-8">        }
</span><span id="__span-29-9">        return f(pre, 0, pre.length - 1, in, 0, in.length - 1, map);
</span><span id="__span-29-10">    }
</span><span id="__span-29-11">
</span><span id="__span-29-12">    public static TreeNode f(int[] pre, int l1, int r1, int[] in, int l2, int r2, HashMap&lt;Integer, Integer&gt; map) {
</span><span id="__span-29-13">        if (l1 &gt; r1) {
</span><span id="__span-29-14">            return null;
</span><span id="__span-29-15">        }
</span><span id="__span-29-16">        TreeNode head = new TreeNode(pre[l1]);
</span><span id="__span-29-17">        if (l1 == r1) {
</span><span id="__span-29-18">            return head;
</span><span id="__span-29-19">        }
</span><span id="__span-29-20">        int k = map.get(pre[l1]);
</span><span id="__span-29-21">        // pre : l1(........)[.......r1]
</span><span id="__span-29-22">        // in  : (l2......)k[........r2]
</span><span id="__span-29-23">        // (...)是左树对应，[...]是右树的对应
</span><span id="__span-29-24">        head.left = f(pre, l1 + 1, l1 + k - l2, in, l2, k - 1, map);
</span><span id="__span-29-25">        head.right = f(pre, l1 + k - l2 + 1, r1, in, k + 1, r2, map);
</span><span id="__span-29-26">        return head;
</span><span id="__span-29-27">    }
</span></code></pre></div></td></tr></table></div>
<h4 id="_47">验证完全二叉树：<a class="headerlink" href="#_47" title="Permanent link">&para;</a></h4>
<ol>
<li>判断一个二叉树是否是完全二叉树。完全二叉树：除了叶子结点之外全部层都满，并且叶子结点之间没有跳过。</li>
<li>原理：通过bfs，对于每个节点，</li>
<li>如果出现有右无左，则返回。</li>
<li>如果发现孩子节点不全的节点，则接下来遍历的节点必须全是叶子节点。</li>
</ol>
<h4 id="lca"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">普通二叉树寻找两个节点的最近公共祖先(LCA)</a><a class="headerlink" href="#lca" title="Permanent link">&para;</a></h4>
<ol>
<li>该问题又叫LCA算法。基于LCA会有批量查询，在线查询问题。</li>
<li>问题：假设p，q为二叉树两个不同的节点，要求查找最近公共祖先</li>
<li>
<p>思路：分两种情况解决：</p>
</li>
<li>
<p>包含关系(在同一颗树上)：最近公共祖先是p,q中的一个。面对包含的情况，一旦遇到了p的时候就直接向上返回。</p>
</li>
<li>无包含关系(在两颗树上)：最近公共祖先不是p,q，是递归开始的该节点为LCA</li>
<li>代码：</li>
<li>因为要找最近，所以深度优先到最小节点</li>
<li>到了base case，如果左边右边都null，返回null。如果只有一侧，返回仅有的那一侧，如果两边都有，返回根节点root</li>
<li>也就是从最底部向上开始回溯判断，这样在所有满足条件的LCA中，一定是最底部的LCA被首先访问，所以就是深度最大的公共祖先。</li>
<li>复杂度:</li>
<li>时间：O(n)，所有节点都最多会被执行一次判断逻辑，进行计算一次</li>
<li>空间:O(n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-30-1">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
</span><span id="__span-30-2">        if(root == null || root == p || root == q){
</span><span id="__span-30-3">            return root;
</span><span id="__span-30-4">        }
</span><span id="__span-30-5">        TreeNode lres = lowestCommonAncestor(root.left,p,q);
</span><span id="__span-30-6">        TreeNode rres = lowestCommonAncestor(root.right,p,q);
</span><span id="__span-30-7">
</span><span id="__span-30-8">        if(lres != null &amp;&amp; rres != null){
</span><span id="__span-30-9">            return root;
</span><span id="__span-30-10">        }else if(lres == null &amp;&amp; rres == null){
</span><span id="__span-30-11">            return null;
</span><span id="__span-30-12">        }else{
</span><span id="__span-30-13">            return lres != null? lres:rres;
</span><span id="__span-30-14">        }
</span><span id="__span-30-15">
</span><span id="__span-30-16">    }
</span></code></pre></div></td></tr></table></div>
<h4 id="lca_1"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">搜索二叉树上的LCA</a><a class="headerlink" href="#lca_1" title="Permanent link">&para;</a></h4>
<ol>
<li>搜索二叉树：一棵树左子树的值永远小于根，根的值永远小于右子树的值</li>
<li>优化部分：</li>
<li>利用二叉搜索树性质，左&lt;中&lt;右</li>
<li>假设p=30,q=100。也就是p&lt;q如果当前节点cur，<ol>
<li>cur&lt;min(p,q)则结果必然在右子树，访问cur.right。</li>
<li>cur&gt;max(p,q)否则访问cur.left.</li>
<li>cur=p或者cur=q直接返回就好(这点和普通二叉树相同)。</li>
<li>p&lt;cur&lt;q,则当前的就是最近公共祖先</li>
</ol>
</li>
<li>复杂度：</li>
<li>时间:O(n)</li>
<li>空间: O(n),最差情况是线性情况</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-31-1">class Solution {
</span><span id="__span-31-2">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
</span><span id="__span-31-3">        int x = root.val;
</span><span id="__span-31-4">        if (p.val &lt; x &amp;&amp; q.val &lt; x)
</span><span id="__span-31-5">            return lowestCommonAncestor(root.left, p, q);
</span><span id="__span-31-6">        if (p.val &gt; x &amp;&amp; q.val &gt; x)
</span><span id="__span-31-7">            return lowestCommonAncestor(root.right, p, q);
</span><span id="__span-31-8">        return root;
</span><span id="__span-31-9">    }
</span><span id="__span-31-10">}
</span></code></pre></div></td></tr></table></div>
<h4 id="aim"><a href="https://leetcode.cn/problems/path-sum-ii/">路径综合==aim</a><a class="headerlink" href="#aim" title="Permanent link">&para;</a></h4>
<ol>
<li>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</li>
<li>核心：状态恢复。希望f对于a,b,c情况都是同样的状态开始</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-32-1">class Solution {
</span><span id="__span-32-2">    private List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
</span><span id="__span-32-3">    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
</span><span id="__span-32-4">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {
</span><span id="__span-32-5">        traverse(root,0,targetSum);
</span><span id="__span-32-6">        return  ans;
</span><span id="__span-32-7">    }
</span><span id="__span-32-8">    public void traverse(TreeNode cur,int curSum, int targetSum){
</span><span id="__span-32-9">        if(cur == null) return ;
</span><span id="__span-32-10">        if(cur.left == null &amp;&amp; cur.right == null){
</span><span id="__span-32-11">            if(curSum+cur.val == targetSum){
</span><span id="__span-32-12">                path.add(cur.val);
</span><span id="__span-32-13">                ans.add(new ArrayList&lt;&gt;(path));
</span><span id="__span-32-14">                path.remove(path.size()-1);
</span><span id="__span-32-15">            }
</span><span id="__span-32-16">            return;
</span><span id="__span-32-17">        }
</span><span id="__span-32-18">
</span><span id="__span-32-19">        if(cur.left != null) {
</span><span id="__span-32-20">            path.add(cur.val);
</span><span id="__span-32-21">            traverse(cur.left,curSum+cur.val,targetSum);
</span><span id="__span-32-22">            path.remove(path.size()-1);
</span><span id="__span-32-23">        }
</span><span id="__span-32-24">        if(cur.right != null) {
</span><span id="__span-32-25">            path.add(cur.val);
</span><span id="__span-32-26">            traverse(cur.right,curSum+cur.val,targetSum);
</span><span id="__span-32-27">            path.remove(path.size()-1);
</span><span id="__span-32-28">        }
</span><span id="__span-32-29">    }
</span><span id="__span-32-30">}
</span></code></pre></div></td></tr></table></div>
<h4 id="_48"><a href="https://leetcode.cn/problems/balanced-binary-tree/">验证平衡二叉树</a><a class="headerlink" href="#_48" title="Permanent link">&para;</a></h4>
<ol>
<li>平衡二叉树：定义：每个点左右子树的高度差值的绝对值小于等于1，则称为平衡二叉树</li>
<li>定义一个全局布尔值</li>
<li>在求每个节点的高度的时候，一旦发现左右子树满足差值&gt;1，就直接改变状态。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-33-1">class Solution {
</span><span id="__span-33-2">    private boolean isBalance = true;
</span><span id="__span-33-3">    public boolean isBalanced(TreeNode root) {
</span><span id="__span-33-4">        int leftHeight = traverse(root);
</span><span id="__span-33-5">        return isBalance;
</span><span id="__span-33-6">    }
</span><span id="__span-33-7">    private int traverse(TreeNode cur){
</span><span id="__span-33-8">        if(cur == null) return 0;
</span><span id="__span-33-9">        if(cur.left == null &amp;&amp; cur.right == null){
</span><span id="__span-33-10">            return 1;
</span><span id="__span-33-11">        }
</span><span id="__span-33-12">        int leftHeight = traverse(cur.left);
</span><span id="__span-33-13">        int rightHeight = traverse(cur.right);
</span><span id="__span-33-14">        if(Math.abs(leftHeight-rightHeight)&gt;1) isBalance = false;
</span><span id="__span-33-15">        return Math.max(leftHeight,rightHeight)+1;
</span><span id="__span-33-16">    }
</span><span id="__span-33-17">}
</span></code></pre></div></td></tr></table></div>
<h4 id="_49"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证搜索二叉树</a><a class="headerlink" href="#_49" title="Permanent link">&para;</a></h4>
<ol>
<li>性质：搜索二叉树的中序遍历的值一定是有序的。中序遍历有序的二叉树是搜索二叉树的充要条件</li>
<li>思路：通过递归到base case进行判断</li>
</ol>
<h2 id="_50">位运算<a class="headerlink" href="#_50" title="Permanent link">&para;</a></h2>
<p>优势：常数时间很好，几乎和赋值操作一样。</p>
<p><strong>📌</strong></p>
<p>十进制和二进制之间的转换</p>
<p>十进制转换为x进制：Integer.toString(n,x);，需要注意补充前面的0</p>
<p>x进制转换为十进制:  Integer.parseInt(str,x);还有无符号数的Integer.parseUnsignedInt(str,x);</p>
<ol>
<li>leetcode 231：判断一个整数是不是2的幂。</li>
<li>思路：2的幂，则只有某一位是1，其余都是0</li>
</ol>
<p><strong>👋</strong></p>
<p>Brian Kernighan算法：用于提取最右侧的1，结果是只有之前的数的最高位的1的数</p>
<p>n &amp; -n</p>
<ol>
<li>leetcode 326 判断是否为3的幂</li>
<li>思路:通过找出int范围内3的最大次幂是3^19.然后该数只含有3一个质数因子。所以只要该数%x==0,则 x必然是3的幂。</li>
</ol>
<p><strong>👋</strong></p>
<p>如果一个数m%n == 0，则n一定是m的因子。</p>
<ol>
<li>leetcode 201：返回[x,y]区间内所有数字&amp;的结果</li>
<li>思路：<ol>
<li>将y的二进制形式从低位到高位，使用BK算法进行处理，每次判断是否大于x。</li>
<li>如果满足，则将最低位的1除去，继续循环。因为如果还是大于的话，则必有y-1也就是低位的0全部变为1的情况包含在区间，此时进行&amp;的结果必然是0,保不住1。</li>
<li>简单一句，就是求区间边上的数字的最长公共前缀。</li>
</ol>
</li>
</ol>
<p><img alt="image.png" src="../assets/bit01.png" /></p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-34-1">    public static int rangeBitwiseAnd(int left, int right) {
</span><span id="__span-34-2">        while (left &lt; right) {
</span><span id="__span-34-3">            right -= right &amp; -right;
</span><span id="__span-34-4">        }
</span><span id="__span-34-5">        return right;
</span><span id="__span-34-6">    }
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 190颠倒二进制位</li>
</ol>
<p>思路：还有更简单的API：Integer.reverse(n)</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-35-1">class Solution {
</span><span id="__span-35-2">    // you need treat n as an unsigned value
</span><span id="__span-35-3">    public int reverseBits(int n) {
</span><span id="__span-35-4">        StringBuilder ans = new StringBuilder();
</span><span id="__span-35-5">        String temp = Integer.toBinaryString(n);
</span><span id="__span-35-6">        for(int i=0; i&lt;32-temp.length();i++){
</span><span id="__span-35-7">            ans.append(&#39;0&#39;);
</span><span id="__span-35-8">        }
</span><span id="__span-35-9">        ans.append(temp);
</span><span id="__span-35-10">        return Integer.parseUnsignedInt(ans.reverse().toString(),2);
</span><span id="__span-35-11">    }
</span><span id="__span-35-12">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 461汉明距离</li>
<li>汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（相同长度）字符串对应位置的不同字符的数量，我们以d（x,y）表示两个字x,y之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离。</li>
<li>思路：使用1&lt;&lt;i，获取x与y的每一位数，如果不同,cnt++</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span>
<span class="normal">9</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-36-1">class Solution {
</span><span id="__span-36-2">    public int hammingDistance(int x, int y) {
</span><span id="__span-36-3">        int cnt = 0;
</span><span id="__span-36-4">        for(int i=0; i&lt;32;i++){
</span><span id="__span-36-5">            if((x&amp;(1&lt;&lt;i)) != (y&amp;(1&lt;&lt;i))) cnt++;
</span><span id="__span-36-6">        }
</span><span id="__span-36-7">        return cnt;
</span><span id="__span-36-8">    }
</span><span id="__span-36-9">}
</span></code></pre></div></td></tr></table></div>
<h2 id="master">递归和master公式<a class="headerlink" href="#master" title="Permanent link">&para;</a></h2>
<h3 id="_51">递归：<a class="headerlink" href="#_51" title="Permanent link">&para;</a></h3>
<p>具体内容：递归 = 递归逻辑+ base case。多画递归调用图。</p>
<p>递归必然可以转换为非递归，这时候就把系统栈空间的使用转变为堆内存空间。同时可以更细粒度地控制。工程上必然要改为非递归。除非层数特别少。</p>
<p>常见的不用改的递归有:归并排序，快速排序，线段树，很多平衡树。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-37-1">    public static int f(int[] arr, int l, int r) {
</span><span id="__span-37-2">        //base case
</span><span id="__span-37-3">        if(l == r){
</span><span id="__span-37-4">            return arr[l];
</span><span id="__span-37-5">        }
</span><span id="__span-37-6">        int m = (l + r)/2;
</span><span id="__span-37-7">        int lmax = f(arr,l,m);
</span><span id="__span-37-8">        int rmax = f(arr,m+1, r);
</span><span id="__span-37-9">        return Math.max(lmax,rmax);
</span><span id="__span-37-10">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="master_1">master公式<a class="headerlink" href="#master_1" title="Permanent link">&para;</a></h3>
<p>基本原理：后面的O()项就是其余代码部分的时间复杂度，也就是除了递归调用的部分。同时最终是log(b,a)和c进行对比，谁大谁做指数。如果相等，则c*logn做指数。</p>
<p>注意事项：使用需要注意左右两侧递归调用需要规模相同，都是T(n/b)</p>
<p><img alt="image.png" src="../assets/master01.png" /></p>
<p>例子：假设求[l,r]范围上的最大值，一共n个数。</p>
<p>则如果采用递归求最值，则T(N) = 2* T(N/2) + O(1)。这里a=2,b=2,c=0</p>
<p>则时间复杂度为：O(n^1) = O(n)</p>
<h3 id="_52">递归高频题目总结<a class="headerlink" href="#_52" title="Permanent link">&para;</a></h3>
<p>递归可以分为带路径的递归和不带路径的递归，而大部分的dp,状态压缩dp都是认为是路径简化 。任何递归都是dfs并且非常灵活。</p>
<ol>
<li><a href="https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a">返回字符串所有子序列</a>，并且子序列要求去重</li>
<li>abc情况</li>
<li>abbc情况</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-38-1">public class Solution {
</span><span id="__span-38-2">
</span><span id="__span-38-3">    public String[] generatePermutation (String s) {
</span><span id="__span-38-4">        // write code here
</span><span id="__span-38-5">        char[] chars = s.toCharArray();
</span><span id="__span-38-6">        StringBuilder path = new StringBuilder();
</span><span id="__span-38-7">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
</span><span id="__span-38-8">        f1(chars,0,path,set);
</span><span id="__span-38-9">        String[] ans = new String[set.size()];
</span><span id="__span-38-10">        int i = 0;
</span><span id="__span-38-11">        for(String item : set){
</span><span id="__span-38-12">            ans[i++] = item;
</span><span id="__span-38-13">        } 
</span><span id="__span-38-14">        return ans;
</span><span id="__span-38-15">    }
</span><span id="__span-38-16">    //有状态恢复版本
</span><span id="__span-38-17">    private void f1(char[] s, int i, StringBuilder path,HashSet&lt;String&gt; set){
</span><span id="__span-38-18">        if(i == s.length){
</span><span id="__span-38-19">            set.add(path.toString());
</span><span id="__span-38-20">            return;
</span><span id="__span-38-21">        }
</span><span id="__span-38-22">        //有s[i]
</span><span id="__span-38-23">        path.append(s[i]);
</span><span id="__span-38-24">        f1(s,i+1,path,set);
</span><span id="__span-38-25">        path.deleteCharAt(path.length()-1);
</span><span id="__span-38-26">        //没有s[i]
</span><span id="__span-38-27">        f1(s,i+1,path,set);
</span><span id="__span-38-28">    }
</span><span id="__span-38-29">    //不用状态恢复的方法，将path变为数组进行保存
</span><span id="__span-38-30">    public static void f2(char[] s, int i, char[] path, int size, HashSet&lt;String&gt; set) {
</span><span id="__span-38-31">        if (i == s.length) {
</span><span id="__span-38-32">            set.add(String.valueOf(path, 0, size));
</span><span id="__span-38-33">        } else {
</span><span id="__span-38-34">            path[size] = s[i];
</span><span id="__span-38-35">            f2(s, i + 1, path, size + 1, set);
</span><span id="__span-38-36">            f2(s, i + 1, path, size, set);
</span><span id="__span-38-37">        }
</span><span id="__span-38-38">    }
</span><span id="__span-38-39">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li><a href="https://leetcode.cn/problems/subsets-ii/">返回数组所有子集</a></li>
<li>子集就是从数组中随机挑选一些元素(幂集)</li>
<li>思路：<ol>
<li>先排序，之后相同的数字在一起。</li>
<li>以相同数字为一组，分类讨论该数组不同数量情况下的情况
   3.</li>
</ol>
</li>
</ol>
<h2 id="_53">笔试中的输入输出<a class="headerlink" href="#_53" title="Permanent link">&para;</a></h2>
<h3 id="_54">核心代码模式：<a class="headerlink" href="#_54" title="Permanent link">&para;</a></h3>
<p>组成：代码，data文件，answer文件</p>
<p>规则：只用填逻辑就可以，不能改类名，方法名，参数类型</p>
<h3 id="acm">acm模式：<a class="headerlink" href="#acm" title="Permanent link">&para;</a></h3>
<p>组成:data文件，answer文件。</p>
<p>规则：写code读取data文件，输出结果到后台和answer文件对比。</p>
<ol>
<li>输入：</li>
<li>Scanner：一次读一行数据</li>
<li>BufferReader：一次读多行数据，减少IO交互</li>
<li>StreamTokenizer:基于BufferReader构建，在BufferReader中一个一个读取数组，标识符，字符串等。会自动忽略掉所有的空格和回车。</li>
<li>in.nval:读取整数值。in.sval:读取字符</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-39-1">    public static void main(String[] args) throws IOException {
</span><span id="__span-39-2">        // 把文件里的内容，load进来，保存在内存里，很高效，很经济，托管的很好
</span><span id="__span-39-3">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-39-4">        // 一个一个读数字
</span><span id="__span-39-5">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-39-6">        // 提交答案的时候用的，也是一个内存托管区
</span><span id="__span-39-7">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-39-8">
</span><span id="__span-39-9">
</span><span id="__span-39-10">        while (in.nextToken() != StreamTokenizer.TT_EOF) { // 文件没有结束就继续
</span><span id="__span-39-11">            //代码逻辑
</span><span id="__span-39-12">            in.nextToken():获取下一个元素(自动忽略回车换行符)
</span><span id="__span-39-13">            out.println(maxSumSubmatrix(mat, n, m));
</span><span id="__span-39-14">        }
</span><span id="__span-39-15">        out.flush();
</span><span id="__span-39-16">        br.close();
</span><span id="__span-39-17">        out.close();
</span><span id="__span-39-18">    }
</span></code></pre></div></td></tr></table></div>
<ol>
<li>输出</li>
<li>System.out.println():不推荐，因为IO效率低，一次对一个测试数据</li>
<li>PrintWritter()：每次都将数据打印到内存中。当数据量足够，则可以使用flush方法进行一次性</li>
<li>空间：</li>
<li>不论是数据空间还是辅助空间，都推荐使用静态开辟，注意数据量与复用(例如使用Arrays.fill(arr,0,m,0)等方法进行清空)即可。</li>
</ol>
<h2 id="_55">归并：<a class="headerlink" href="#_55" title="Permanent link">&para;</a></h2>
<h3 id="_56">归并排序：<a class="headerlink" href="#_56" title="Permanent link">&para;</a></h3>
<ol>
<li>时间复杂度O(n*logn)：T(n) = 2*T(n/2) + O(n),则log(2,2)=1，则为O(n^1 * logn) = O(nlogn)</li>
<li>核心：递归</li>
<li>步骤：</li>
<li>先递归调用，在进行merge并刷回原数组。</li>
<li>每次进行的merge都是先左右指针分别指向左右两侧的已经有序的结果，merge写入help数组之后，如果一侧有剩余则直接写入。最后刷回原数组。</li>
<li>为了归并排序的稳定性，则规定当merge的时候先copy左侧的数到help数组中。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-40-1">    // 归并排序递归版
</span><span id="__span-40-2">    public static void mergeSort1(int[] arr) {
</span><span id="__span-40-3">        //对[0,arr_len-1]进行归并排序
</span><span id="__span-40-4">        sort(arr, 0, arr.length - 1);
</span><span id="__span-40-5">    }
</span><span id="__span-40-6">
</span><span id="__span-40-7">    public static void sort(int[] arr, int l, int r) {
</span><span id="__span-40-8">        //直到base case。只有一个数就不用排序
</span><span id="__span-40-9">        if (l == r) {
</span><span id="__span-40-10">            return;
</span><span id="__span-40-11">        }
</span><span id="__span-40-12">        int m = (l + r) / 2;
</span><span id="__span-40-13">        //递归调用部分
</span><span id="__span-40-14">        sort(arr, l, m);  
</span><span id="__span-40-15">        sort(arr, m + 1, r);
</span><span id="__span-40-16">        //合并部分
</span><span id="__span-40-17">        merge(arr, l, m, r);
</span><span id="__span-40-18">    }
</span><span id="__span-40-19">
</span><span id="__span-40-20">    //merge是非递归方法
</span><span id="__span-40-21">    //传入的三个参数，可以标记[1,m],[m+1,r]的左右两个需要merge的数组
</span><span id="__span-40-22">    //使用双指针法排序
</span><span id="__span-40-23">    public static void merge(int[] arr, int l, int m, int r) {
</span><span id="__span-40-24">        int i = l;
</span><span id="__span-40-25">
</span><span id="__span-40-26">        int a = l;
</span><span id="__span-40-27">        int b = m + 1;
</span><span id="__span-40-28">        //当两边都没有遍历完的时候
</span><span id="__span-40-29">        while (a &lt;= m &amp;&amp; b &lt;= r) {   
</span><span id="__span-40-30">            help[i++] = arr[a] &lt;= arr[b] ? arr[a++] : arr[b++];
</span><span id="__span-40-31">        }
</span><span id="__span-40-32">        while (a &lt;= m) {
</span><span id="__span-40-33">            help[i++] = arr[a++];
</span><span id="__span-40-34">        }
</span><span id="__span-40-35">        while (b &lt;= r) {
</span><span id="__span-40-36">            help[i++] = arr[b++];
</span><span id="__span-40-37">        }
</span><span id="__span-40-38">        //刷回原数组
</span><span id="__span-40-39">        for (i = l; i &lt;= r; i++) {
</span><span id="__span-40-40">            arr[i] = help[i];
</span><span id="__span-40-41">        }
</span><span id="__span-40-42">    }
</span></code></pre></div></td></tr></table></div>
<h2 id="_57">差分<a class="headerlink" href="#_57" title="Permanent link">&para;</a></h2>
<h3 id="_58">一维差分<a class="headerlink" href="#_58" title="Permanent link">&para;</a></h3>
<ol>
<li>场景：对于一个数组，要多次在不同区间快速完成整体的加减。</li>
<li>原理：</li>
</ol>
<p>前缀和数组：前缀和可以简单理解为「数列的前 n 项的和」。</p>
<p>差分数组对应的概念是前缀和数组，对于数组 [1,2,2,4]，其差分数组为 [1,1,0,2]，差分数组的第 i 个数即为原数组的第 i−1 个元素和第 i 个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。</p>
<p>差分数组的性质是，当我们希望对原数组的某一个区间 [l,r] 施加一个增量inc 时，差分数组 d 对应的改变是：d[l] 增加 inc，d[r+1] 减少 inc(用于抵消给前面区间+inc的效果)。这样对于区间的修改就变为了对于两个位置的修改。并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。</p>
<ol>
<li>对于原数组，如果要在[L,R]范围上+v,</li>
<li>只需要在对应的差分数组上让[L]-v, [R+1]+v</li>
<li>然后对差分数组进行前缀和就可以得到结果</li>
<li>模板题：</li>
</ol>
<p>这里有 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 个航班，它们分别从 <code>&lt;span class="color_font"&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;</code> 到 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 进行编号。</p>
<p>有一份航班预订表 <code>&lt;span class="color_font"&gt;&lt;span&gt;bookings&lt;/span&gt;&lt;/span&gt;</code> ，表中第 <code>&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;</code> 条预订记录 <code>&lt;span class="color_font"&gt;&lt;span&gt;bookings[i] = [first&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;, last&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;, seats&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;</code> 意味着在从 <code>&lt;span class="color_font"&gt;&lt;span&gt;first&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;</code> 到 <code>&lt;span class="color_font"&gt;&lt;span&gt;last&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;</code> （<strong>包含</strong> <code>&lt;span class="color_font"&gt;&lt;span&gt;first&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;</code> 和 <code>&lt;span class="color_font"&gt;&lt;span&gt;last&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;</code> ）的 <strong>每个航班</strong> 上预订了 <code>&lt;span class="color_font"&gt;&lt;span&gt;seats&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;</code> 个座位。</p>
<p>请你返回一个长度为 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 的数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;answer&lt;/span&gt;&lt;/span&gt;</code>，里面的元素是每个航班预定的座位总数</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-41-1">class Solution {
</span><span id="__span-41-2">    public int[] corpFlightBookings(int[][] bookings, int n) {
</span><span id="__span-41-3">        int[] cnt = new int[n+1];
</span><span id="__span-41-4">
</span><span id="__span-41-5">        for(int[] info : bookings){
</span><span id="__span-41-6">            int l = info[0], r = info[1];
</span><span id="__span-41-7">            int num = info[2];
</span><span id="__span-41-8">            cnt[l] += num;
</span><span id="__span-41-9">            //此处进行特判，或者开cnt的时候多开一个
</span><span id="__span-41-10">            if(r+1&lt;cnt.length) cnt[r+1] -=  num;
</span><span id="__span-41-11">        }
</span><span id="__span-41-12">        for(int i=1; i&lt;cnt.length; i++){
</span><span id="__span-41-13">            cnt[i] += cnt[i-1];
</span><span id="__span-41-14">        }
</span><span id="__span-41-15">        return Arrays.copyOfRange(cnt, 1, n+1);
</span><span id="__span-41-16">    }
</span><span id="__span-41-17">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>一位子数组异或值</li>
<li>解决办法完全同一维前缀和</li>
<li>利用异或的性质<ol>
<li>0^x = x</li>
<li>交换律</li>
<li>结合律</li>
</ol>
</li>
</ol>
<p><img alt="image.png" src="../assets/xor01.png" /></p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-42-1">  def xorQueries(arr: Array[Int], queries: Array[Array[Int]]): Array[Int] = {
</span><span id="__span-42-2">    val prefix: Array[Int] = arr.scanLeft(0)((x, y) =&gt; (x ^ y))
</span><span id="__span-42-3">    //注意scala的scanLeft结果的开头是初始值，则需要r+1 - l 而不是r-(l-1)   
</span><span id="__span-42-4">    for(q &lt;- queries) yield prefix(q(1)+1) ^ prefix(q(0))
</span><span id="__span-42-5">  }
</span></code></pre></div></td></tr></table></div>
<h3 id="_59">二维差分<a class="headerlink" href="#_59" title="Permanent link">&para;</a></h3>
<p>二维前缀和</p>
<ol>
<li>例子：</li>
<li>求快速求得下面矩阵不同位置子矩阵((a,b)-&gt;(c,d))的元素和</li>
<li>使用二维前缀和来处理，使得获得结果的时间是O(1)</li>
<li>步骤：<ol>
<li>先预处理sum数组</li>
<li>不同的子矩阵都可以通过sum数组获得</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align: left;">3</th>
<th style="text-align: left;">1</th>
<th style="text-align: left;">-2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;">-3</td>
<td style="text-align: left;">4</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;">6</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<ol>
<li>原理：</li>
<li>使用容斥原理</li>
<li>实际上经常通过补sum的第0行和第0列来防止额外的边界判断。额外的位置全部设置为0，防止影响操作。</li>
</ol>
<p><img alt="image.png" src="../assets/prefix-sum01.png" /></p>
<ol>
<li>模板题：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-43-1">class NumMatrix {
</span><span id="__span-43-2">    public int[][] sum;
</span><span id="__span-43-3">
</span><span id="__span-43-4">    public NumMatrix(int[][] matrix) {
</span><span id="__span-43-5">        int m = matrix.length;
</span><span id="__span-43-6">        int n = matrix[0].length;
</span><span id="__span-43-7">        sum = new int[m + 1][n + 1];
</span><span id="__span-43-8">        // 进行扩充
</span><span id="__span-43-9">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-43-10">            for (int j = 0; j &lt; n; j++) {
</span><span id="__span-43-11">                sum[i + 1][j + 1] = matrix[i][j];
</span><span id="__span-43-12">            }
</span><span id="__span-43-13">        }
</span><span id="__span-43-14">        // 预处理sum
</span><span id="__span-43-15">        for (int i = 1; i &lt;= m; i++) {
</span><span id="__span-43-16">            for (int j = 1; j &lt;= n; j++) {
</span><span id="__span-43-17">                sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];
</span><span id="__span-43-18">            }
</span><span id="__span-43-19">        }
</span><span id="__span-43-20">    }
</span><span id="__span-43-21">
</span><span id="__span-43-22">    public int sumRegion(int a, int b, int c, int d) {
</span><span id="__span-43-23">        int x1 = a + 1, y1 = b + 1;
</span><span id="__span-43-24">        int x2 = c + 1, y2 = d + 1;
</span><span id="__span-43-25">        return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];
</span><span id="__span-43-26">    }
</span><span id="__span-43-27">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 1139</li>
<li>给你一个由若干 <code>&lt;span&gt;0&lt;/span&gt;</code> 和 <code>&lt;span&gt;1&lt;/span&gt;</code> 组成的二维网格 <code>&lt;span&gt;grid&lt;/span&gt;</code>，请你找出边界全部由 <code>&lt;span&gt;1&lt;/span&gt;</code> 组成的最大 <strong>正方形</strong> 子网格，并返回该子网格中的元素数量。如果不存在，则返回 <code>&lt;span&gt;0&lt;/span&gt;</code></li>
<li>思路：<ol>
<li>暴力：<ol>
<li>时间复杂度O(m*n^2)，其中n&lt;m</li>
</ol>
</li>
<li>优化步骤：使用前缀合</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-44-1">class Solution {
</span><span id="__span-44-2">    public int largest1BorderedSquare(int[][] grid) {
</span><span id="__span-44-3">        int ans = 0;
</span><span id="__span-44-4">        int m = grid.length;
</span><span id="__span-44-5">        int n = grid[0].length;
</span><span id="__span-44-6">        //(i,j,l)：是以(i,j)开头，大小为l的矩阵。
</span><span id="__span-44-7">        //则i范围是[0,m-l)。j范围是[0,n-1)
</span><span id="__span-44-8">        int limit = Math.min(m,n);
</span><span id="__span-44-9">        for(int l = limit; l&gt;=1;l--){
</span><span id="__span-44-10">            for(int i=0; i&lt;=m-l; i++){
</span><span id="__span-44-11">                for(int j=0; j&lt;=n-l;j++){
</span><span id="__span-44-12">                    if(check(i,j,l,grid)){
</span><span id="__span-44-13">                        ans = Math.max(l*l,ans);
</span><span id="__span-44-14">                    }
</span><span id="__span-44-15">                }
</span><span id="__span-44-16">            }
</span><span id="__span-44-17">        }
</span><span id="__span-44-18">        return ans;
</span><span id="__span-44-19">    }
</span><span id="__span-44-20">    public boolean check(int a, int b, int l, int[][] grid){
</span><span id="__span-44-21">        //检查边界(竖着的)
</span><span id="__span-44-22">        for(int i=a;i&lt;a+l;i++){
</span><span id="__span-44-23">            if(grid[i][b] == 0) return false;
</span><span id="__span-44-24">            if(grid[i][b+l-1] == 0) return false;
</span><span id="__span-44-25">        }
</span><span id="__span-44-26">        //横着的
</span><span id="__span-44-27">        for(int i=b; i&lt;b+l;i++){
</span><span id="__span-44-28">            if(grid[a][i] == 0) return false;
</span><span id="__span-44-29">            if(grid[a+l-1][i] == 0) return false;
</span><span id="__span-44-30">        }
</span><span id="__span-44-31">        return true;
</span><span id="__span-44-32">    }
</span><span id="__span-44-33">}
</span><span id="__span-44-34">//使用前缀和
</span><span id="__span-44-35">class Solution {
</span><span id="__span-44-36">    public int largest1BorderedSquare(int[][] grid) {
</span><span id="__span-44-37">        int ans = 0;
</span><span id="__span-44-38">        int m = grid.length;
</span><span id="__span-44-39">        int n = grid[0].length;
</span><span id="__span-44-40">        int limit = Math.min(m,n);
</span><span id="__span-44-41">        for(int l = limit; l&gt;=1;l--){
</span><span id="__span-44-42">            for(int i=0; i&lt;=m-l; i++){
</span><span id="__span-44-43">                for(int j=0; j&lt;=n-l;j++){
</span><span id="__span-44-44">                    if(check(i,j,l,grid)){
</span><span id="__span-44-45">                        return l*l;
</span><span id="__span-44-46">                    }
</span><span id="__span-44-47">                }
</span><span id="__span-44-48">            }
</span><span id="__span-44-49">        }
</span><span id="__span-44-50">        return ans;
</span><span id="__span-44-51">    }
</span><span id="__span-44-52">    public boolean check(int a, int b, int l, int[][] grid){
</span><span id="__span-44-53">        NumMatrix tool = new NumMatrix(grid);
</span><span id="__span-44-54">        int x1=a, y1=b;
</span><span id="__span-44-55">        int x2=a+l-1, y2=b+l-1;
</span><span id="__span-44-56">        int sum1 = tool.sumRegion(x1, y1, x2, y2);
</span><span id="__span-44-57">        int sum2 = 0;
</span><span id="__span-44-58">        if(l==1){
</span><span id="__span-44-59">            return grid[a][b] == 1;
</span><span id="__span-44-60">        }
</span><span id="__span-44-61">        if(l&gt;=3) sum2 = tool.sumRegion(x1+1, y1+1, x2-1, y2-1);
</span><span id="__span-44-62">        if(sum1-sum2 != 4*l-4) return false;
</span><span id="__span-44-63">        return true;
</span><span id="__span-44-64">    }
</span><span id="__span-44-65">}
</span><span id="__span-44-66">
</span><span id="__span-44-67">class NumMatrix {
</span><span id="__span-44-68">    public int[][] sum;
</span><span id="__span-44-69">
</span><span id="__span-44-70">    public NumMatrix(int[][] matrix) {
</span><span id="__span-44-71">        int m = matrix.length;
</span><span id="__span-44-72">        int n = matrix[0].length;
</span><span id="__span-44-73">        sum = new int[m + 1][n + 1];
</span><span id="__span-44-74">        for(int i=0 ;i&lt;m+1;i++){
</span><span id="__span-44-75">            Arrays.fill(sum[i],0);
</span><span id="__span-44-76">        }
</span><span id="__span-44-77">        // 进行扩充
</span><span id="__span-44-78">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-44-79">            for (int j = 0; j &lt; n; j++) {
</span><span id="__span-44-80">                sum[i + 1][j + 1] = matrix[i][j];
</span><span id="__span-44-81">            }
</span><span id="__span-44-82">        }
</span><span id="__span-44-83">        // 预处理sum
</span><span id="__span-44-84">        for (int i = 1; i &lt;= m; i++) {
</span><span id="__span-44-85">            for (int j = 1; j &lt;= n; j++) {
</span><span id="__span-44-86">                sum[i][j] += sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];
</span><span id="__span-44-87">            }
</span><span id="__span-44-88">        }
</span><span id="__span-44-89">    }
</span><span id="__span-44-90">
</span><span id="__span-44-91">    public int sumRegion(int a, int b, int c, int d) {
</span><span id="__span-44-92">        int x1 = a + 1, y1 = b + 1;
</span><span id="__span-44-93">        int x2 = c + 1, y2 = d + 1;
</span><span id="__span-44-94">        return sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];
</span><span id="__span-44-95">    }
</span><span id="__span-44-96">}
</span></code></pre></div></td></tr></table></div>
<p>二维差分</p>
<ol>
<li>场景：(a,b)-&gt;(c,d)的子矩阵进行很多次的加减操作</li>
<li>原理：</li>
<li>如果要在(1,1)-&gt;(2,2)统一加3，需要在如下位置进行操作</li>
<li>同样要使用一圈0把真实数据进行扩充，防止边界情况</li>
<li>读取原始矩阵也可以使用单个元素的差分进行替代</li>
</ol>
<p><img alt="image.png" src="../assets/p-s-02.png" /></p>
<ol>
<li>模板：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-45-1">import java.util.*;
</span><span id="__span-45-2">import java.io.*;
</span><span id="__span-45-3">
</span><span id="__span-45-4">class Main {
</span><span id="__span-45-5">    public static int MAXM = 1005;
</span><span id="__span-45-6">    public static int MAXN = 1005;
</span><span id="__span-45-7">    public static long[][] diff = new long[MAXM][MAXN];
</span><span id="__span-45-8">    public static int n, m, q;
</span><span id="__span-45-9">    public static void main(String[] args) throws IOException {
</span><span id="__span-45-10">
</span><span id="__span-45-11">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-45-12">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-45-13">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-45-14">        while (in.nextToken() != StreamTokenizer.TT_EOF) {
</span><span id="__span-45-15">            n = (int)in.nval;
</span><span id="__span-45-16">            in.nextToken();
</span><span id="__span-45-17">            m = (int)in.nval;
</span><span id="__span-45-18">            in.nextToken();
</span><span id="__span-45-19">            q = (int)in.nval;
</span><span id="__span-45-20">            for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-45-21">                for (int j = 1; j &lt;= m; j++) {
</span><span id="__span-45-22">                    in.nextToken();
</span><span id="__span-45-23">                    //必须要用同样的方式进行添加数据，否则结构会乱
</span><span id="__span-45-24">                    add(i, j, i, j, (int)in.nval);
</span><span id="__span-45-25">                }
</span><span id="__span-45-26">            }
</span><span id="__span-45-27">            for (int i = 0; i &lt; q; i++) {
</span><span id="__span-45-28">                in.nextToken();
</span><span id="__span-45-29">                int a = (int)in.nval;
</span><span id="__span-45-30">                in.nextToken();
</span><span id="__span-45-31">                int b = (int)in.nval;
</span><span id="__span-45-32">                in.nextToken();
</span><span id="__span-45-33">                int c = (int)in.nval;
</span><span id="__span-45-34">                in.nextToken();
</span><span id="__span-45-35">                int d = (int)in.nval;
</span><span id="__span-45-36">                in.nextToken();
</span><span id="__span-45-37">                int k = (int)in.nval;
</span><span id="__span-45-38">                add(a, b, c, d, k);
</span><span id="__span-45-39">            }
</span><span id="__span-45-40">            build();
</span><span id="__span-45-41">            for(int i=1;i&lt;=n;i++){
</span><span id="__span-45-42">                out.print(diff[i][1]);
</span><span id="__span-45-43">                for(int j=2; j&lt;=m;j++){
</span><span id="__span-45-44">                    out.print(&quot; &quot; + diff[i][j]);
</span><span id="__span-45-45">                }
</span><span id="__span-45-46">                out.println();
</span><span id="__span-45-47">            }
</span><span id="__span-45-48">            //防止下一份测试数据被上一组干扰
</span><span id="__span-45-49">            clear();
</span><span id="__span-45-50">        }
</span><span id="__span-45-51">        out.flush();
</span><span id="__span-45-52">        br.close();
</span><span id="__span-45-53">        out.close();
</span><span id="__span-45-54">    }
</span><span id="__span-45-55">    public static void add(int a, int b, int c, int d, int k) {
</span><span id="__span-45-56">        diff[a][b] += k;
</span><span id="__span-45-57">        diff[a][d + 1] -= k;
</span><span id="__span-45-58">        diff[c + 1][b] -= k;
</span><span id="__span-45-59">        diff[c + 1][d + 1] += k;
</span><span id="__span-45-60">    }
</span><span id="__span-45-61">    public static void build() {
</span><span id="__span-45-62">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-45-63">            for (int j = 1; j &lt;= m; j++) {
</span><span id="__span-45-64">                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
</span><span id="__span-45-65">            }
</span><span id="__span-45-66">        }
</span><span id="__span-45-67">    }
</span><span id="__span-45-68">    public static void clear() {
</span><span id="__span-45-69">        for (int i = 1; i &lt;= n + 1; i++) {
</span><span id="__span-45-70">            for (int j = 1; j &lt;= m + 1; j++) {
</span><span id="__span-45-71">                diff[i][j] = 0;
</span><span id="__span-45-72">            }
</span><span id="__span-45-73">        }
</span><span id="__span-45-74">    }
</span><span id="__span-45-75">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_60">离散化技巧<a class="headerlink" href="#_60" title="Permanent link">&para;</a></h3>
<ol>
<li>核心问题：怎么处理不是整数下标位置的格子。数据是[0.5,1,1.5,2,2.5].....</li>
<li>思路：</li>
<li>坐标位置统一放大一倍。比如说区域是以x,y为中心点，长度为r的正方形。则变换为中心点为(2x,2y)，长度为2r的正方形。保证了区域的相对位置不变。</li>
<li>边界位置也是2*(x-r/2)，同样也是乘2</li>
</ol>
<h2 id="_61">堆<a class="headerlink" href="#_61" title="Permanent link">&para;</a></h2>
<h3 id="_62">堆结构<a class="headerlink" href="#_62" title="Permanent link">&para;</a></h3>
<ol>
<li>堆的实质：将序列映射为二叉树(实际上就是在数组中操作)，并维持某些性质</li>
</ol>
<p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。</p>
<p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆</p>
<p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p>
<ol>
<li>
<p>二叉树的性质：假设节点按照层序遍历进行排序，</p>
</li>
<li>
<p>则i位置的左孩子是2i+1， 右孩子节点是2i+2.</p>
</li>
<li>第i位置的父节点是(i-1)/2。这么算0的父亲节点还是0(有环)</li>
<li>完全二叉树的高度就是log(2,N)</li>
<li>将一个序列的前缀范围进行建立堆，则需要通过size来进行限制堆中的元素</li>
<li>大根堆：</li>
<li>定义：二叉树的任何一颗子树的最大值都在顶部。</li>
<li>插入：对于新来的数，向上调整大根堆(实质上是进行数组的调整)</li>
<li>Java 的PriorityQueue默认内部使用的是小根堆来实现。优先队列就是根据优先级进行重排元素的队列。如果使用堆排序的话可以直接使用PriorityQueue。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-46-1">   //向上调整
</span><span id="__span-46-2">   //范围是[0,i]
</span><span id="__span-46-3">    public static void heapInsert(int[] arr, int i) {
</span><span id="__span-46-4">        //来到0位置的话也会跳出while，因为不满足arr[0]&gt;arr[0]
</span><span id="__span-46-5">        while (arr[i] &gt; arr[(i - 1) / 2]) {
</span><span id="__span-46-6">            swap(arr, i, (i - 1) / 2);
</span><span id="__span-46-7">            i = (i - 1) / 2;
</span><span id="__span-46-8">        }
</span><span id="__span-46-9">    }
</span><span id="__span-46-10">    //向下调整
</span><span id="__span-46-11">    //范围是[i,size]
</span><span id="__span-46-12">    public static void heapify(int[] arr, int i, int size) {
</span><span id="__span-46-13">        int l = i * 2 + 1;
</span><span id="__span-46-14">        //l&lt;size 就是 有左孩子
</span><span id="__span-46-15">        while (l &lt; size) {
</span><span id="__span-46-16">            // 右孩子，l+1
</span><span id="__span-46-17">            // 评选，最强的孩子，是哪个下标的孩子
</span><span id="__span-46-18">            int best = l + 1 &lt; size &amp;&amp; arr[l + 1] &gt; arr[l] ? l + 1 : l;
</span><span id="__span-46-19">            // 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁
</span><span id="__span-46-20">            best = arr[best] &gt; arr[i] ? best : i;
</span><span id="__span-46-21">            if (best == i) {
</span><span id="__span-46-22">                break;
</span><span id="__span-46-23">            }
</span><span id="__span-46-24">            swap(arr, best, i);
</span><span id="__span-46-25">            i = best;
</span><span id="__span-46-26">            l = i * 2 + 1;
</span><span id="__span-46-27">        }
</span><span id="__span-46-28">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_63">堆排序<a class="headerlink" href="#_63" title="Permanent link">&para;</a></h3>
<ol>
<li>步骤：</li>
<li>先对整个数组建立大根堆</li>
<li>将得到的最大值和最后一个值进行交换。同时堆的大小-1。</li>
<li>对根位置向下调整</li>
<li>对剩下的位置重复abc操作。</li>
<li>时间复杂度:</li>
<li>单个元素的插入删除调整都是O(logn)，对n个元素就是n*logn</li>
<li>建立大根堆:时间复杂度是O(n*logn)。也就是log(2,1) + log(2,2) +...+log(2,N)-&gt;n*logn</li>
<li>调整:时间复杂度也是O(n*logn)</li>
<li>则时间复杂度是O(n*logn)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-47-1"> // 从顶到底建立大根堆，O(n * logn)
</span><span id="__span-47-2">    // 依次弹出堆内最大值并排好序，O(n * logn)
</span><span id="__span-47-3">    // 整体时间复杂度O(n * logn)
</span><span id="__span-47-4">    public static void heapSort1(int[] arr) {
</span><span id="__span-47-5">        int n = arr.length;
</span><span id="__span-47-6">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-47-7">            heapInsert(arr, i);
</span><span id="__span-47-8">        }
</span><span id="__span-47-9">        int size = n;
</span><span id="__span-47-10">        while (size &gt; 1) {
</span><span id="__span-47-11">            swap(arr, 0, --size);
</span><span id="__span-47-12">            heapify(arr, 0, size);
</span><span id="__span-47-13">        }
</span><span id="__span-47-14">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_64">堆的常见题<a class="headerlink" href="#_64" title="Permanent link">&para;</a></h3>
<ol>
<li>合并K个有序链表：</li>
<li>思路1：收集所有节点，将节点进行排序，然后再统一装起来。<ol>
<li>时间复杂度:O(n*logn) + O(n)=O(n*logn)。</li>
<li>空间复杂度：O(n)(就是收集所有节点的位置)</li>
</ol>
</li>
<li>思路2：使用堆。</li>
<li>使用小根堆，利用链表自身有序的性质。</li>
<li>现将K个链表的头结点加入堆。从中选取最小的，就是全局最小的。则将其弹出，并将其后继节点加入堆。</li>
<li>优点：堆的大小始终不超过K。</li>
<li>时间复杂度:O(n*logk)</li>
<li>空间复杂度：O(k)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-48-1">public class Code01_MergeKSortedLists {
</span><span id="__span-48-2">
</span><span id="__span-48-3">    // 不要提交这个类
</span><span id="__span-48-4">    public static class ListNode {
</span><span id="__span-48-5">        public int val;
</span><span id="__span-48-6">        public ListNode next;
</span><span id="__span-48-7">    }
</span><span id="__span-48-8">
</span><span id="__span-48-9">    // 提交以下的方法
</span><span id="__span-48-10">    public static ListNode mergeKLists(ArrayList&lt;ListNode&gt; arr) {
</span><span id="__span-48-11">        // 小根堆
</span><span id="__span-48-12">        PriorityQueue&lt;ListNode&gt; heap = new PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);
</span><span id="__span-48-13">        for (ListNode h : arr) {
</span><span id="__span-48-14">            // 遍历所有的头！
</span><span id="__span-48-15">            if (h != null) {
</span><span id="__span-48-16">                heap.add(h);
</span><span id="__span-48-17">            }
</span><span id="__span-48-18">        }
</span><span id="__span-48-19">        //如果全是空链表
</span><span id="__span-48-20">        if (heap.isEmpty()) {
</span><span id="__span-48-21">            return null;
</span><span id="__span-48-22">        }
</span><span id="__span-48-23">        // 先弹出一个节点，做总头部。
</span><span id="__span-48-24">        //poll方法取出优先队列的头部
</span><span id="__span-48-25">        ListNode h = heap.poll();
</span><span id="__span-48-26">        ListNode pre = h;
</span><span id="__span-48-27">        if (pre.next != null) {
</span><span id="__span-48-28">            heap.add(pre.next);
</span><span id="__span-48-29">        }
</span><span id="__span-48-30">        while (!heap.isEmpty()) {
</span><span id="__span-48-31">            ListNode cur = heap.poll();
</span><span id="__span-48-32">            pre.next = cur;
</span><span id="__span-48-33">            pre = cur;
</span><span id="__span-48-34">            if (cur.next != null) {
</span><span id="__span-48-35">                heap.add(cur.next);
</span><span id="__span-48-36">            }
</span><span id="__span-48-37">        }
</span><span id="__span-48-38">        return h;
</span><span id="__span-48-39">    }
</span><span id="__span-48-40">
</span><span id="__span-48-41">}
</span></code></pre></div></td></tr></table></div>
<p><strong>💡</strong></p>
<p>传入比较器的写法：可以使用lambda表达式，也可以常规传入Comparator</p>
<p>PriorityQueue<ListNode> heap = new PriorityQueue&lt;&gt;(new Comparator<ListNode>() {</p>
<p>@Override</p>
<p>public int compare(ListNode o1, ListNode o2) {</p>
<p>return o1.val - o2.val;
}</p>
<p>});</p>
<h2 id="_65">哈希表<a class="headerlink" href="#_65" title="Permanent link">&para;</a></h2>
<h3 id="hashset-and-hashmap">HashSet and HashMap<a class="headerlink" href="#hashset-and-hashmap" title="Permanent link">&para;</a></h3>
<ol>
<li>注意Java中==和equals方法的使用</li>
<li>对于所有包装类型，以及String都按照值来使用(调用equals方法)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-49-1">public static void main(String[] args) {
</span><span id="__span-49-2">        // Integer、Long、Double、Float
</span><span id="__span-49-3">        // Byte、Short、Character、Boolean
</span><span id="__span-49-4">        // String等都有这个特征
</span><span id="__span-49-5">        String str1 = new String(&quot;Hello&quot;);
</span><span id="__span-49-6">        String str2 = new String(&quot;Hello&quot;);
</span><span id="__span-49-7">        // false，因为不同的内存地址
</span><span id="__span-49-8">        System.out.println(str1 == str2);
</span><span id="__span-49-9">        // true，因为它们的值是相同的
</span><span id="__span-49-10">        System.out.println(str1.equals(str2));
</span><span id="__span-49-11">
</span><span id="__span-49-12">        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();
</span><span id="__span-49-13">        set.add(str1);
</span><span id="__span-49-14">        System.out.println(set.contains(&quot;Hello&quot;));
</span><span id="__span-49-15">        System.out.println(set.contains(str2));
</span><span id="__span-49-16">        set.add(str2);
</span><span id="__span-49-17">        System.out.println(set.size());
</span><span id="__span-49-18">        set.remove(str1);
</span><span id="__span-49-19">        set.clear();
</span><span id="__span-49-20">        System.out.println(set.isEmpty());
</span><span id="__span-49-21">
</span><span id="__span-49-22">        System.out.println(&quot;===========&quot;);
</span><span id="__span-49-23">
</span><span id="__span-49-24">        HashMap&lt;String, String&gt; map1 = new HashMap&lt;&gt;();
</span><span id="__span-49-25">        map1.put(str1, &quot;World&quot;);
</span><span id="__span-49-26">        //此处判断必然是存在的，因为HashMap内部中通过equals方法进行判断
</span><span id="__span-49-27">        System.out.println(map1.containsKey(&quot;Hello&quot;));
</span><span id="__span-49-28">        System.out.println(map1.containsKey(str2));
</span><span id="__span-49-29">        System.out.println(map1.get(str2));
</span><span id="__span-49-30">        System.out.println(map1.get(&quot;你好&quot;) == null);
</span><span id="__span-49-31">        map1.remove(&quot;Hello&quot;);
</span><span id="__span-49-32">        System.out.println(map1.size());
</span><span id="__span-49-33">        map1.clear();
</span><span id="__span-49-34">        System.out.println(map1.isEmpty());
</span><span id="__span-49-35">
</span><span id="__span-49-36">        System.out.println(&quot;===========&quot;);
</span><span id="__span-49-37">
</span><span id="__span-49-38">        // 一般在笔试中，未必需要申请哈希表
</span><span id="__span-49-39">        HashMap&lt;Integer, Integer&gt; map2 = new HashMap&lt;&gt;();
</span><span id="__span-49-40">        map2.put(56, 7285);
</span><span id="__span-49-41">        map2.put(34, 3671263);
</span><span id="__span-49-42">        map2.put(17, 716311);
</span><span id="__span-49-43">        map2.put(24, 1263161);
</span><span id="__span-49-44">        // 上面的map2行为，可以被如下数组的行为替代
</span><span id="__span-49-45">        int[] arr = new int[100];
</span><span id="__span-49-46">        arr[56] = 7285;
</span><span id="__span-49-47">        arr[34] = 3671263;
</span><span id="__span-49-48">        arr[17] = 716311;
</span><span id="__span-49-49">        arr[24] = 1263161;
</span><span id="__span-49-50">        // 哈希表的增、删、改、查，都可以被数组替代，前提是key的范围是固定的、可控的
</span><span id="__span-49-51">        System.out.println(&quot;在笔试场合中哈希表往往会被数组替代&quot;);
</span><span id="__span-49-52">
</span><span id="__span-49-53">        System.out.println(&quot;===========&quot;);
</span><span id="__span-49-54">        Student s1 = new Student(17, &quot;张三&quot;);
</span><span id="__span-49-55">        Student s2 = new Student(17, &quot;张三&quot;);
</span><span id="__span-49-56">        HashMap&lt;Student, String&gt; map3 = new HashMap&lt;&gt;();
</span><span id="__span-49-57">        map3.put(s1, &quot;这是张三&quot;);
</span><span id="__span-49-58">        System.out.println(map3.containsKey(s1));
</span><span id="__span-49-59">        System.out.println(map3.containsKey(s2));
</span><span id="__span-49-60">        map3.put(s2, &quot;这是另一个张三&quot;);
</span><span id="__span-49-61">        System.out.println(map3.size());
</span><span id="__span-49-62">        System.out.println(map3.get(s1));
</span><span id="__span-49-63">        System.out.println(map3.get(s2));
</span><span id="__span-49-64">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_66">比较器<a class="headerlink" href="#_66" title="Permanent link">&para;</a></h3>
<p>Java中的实现对象排序由两种方式：自然排序和定制排序</p>
<ol>
<li>自然排序：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-50-1">public interface Comparable{
</span><span id="__span-50-2"> int compareTo(Object obj);
</span><span id="__span-50-3">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>全类名：java.lang.Comparable(接口)</li>
<li>使用方法：实现接口中的int compareTo(Object obj)方法.若this&gt;that则返回值为正。</li>
<li>定制排序：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-51-1">public interface Comparator{
</span><span id="__span-51-2"> int compare(Object o1,Object o2);
</span><span id="__span-51-3">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>背景：如果需要比较的类没有实现Comparable接口，并且无法改变。或者不想按照Comparable的compareTo()的实现进行排序。</li>
<li>解决办法：通过使用Comparator接口进行定制排序</li>
<li>使用方法：重写compare方法进行比较。如果o1&gt;o2，则返回值为正。</li>
<li>常见场景：将Comparator传入Collections.sort()方法中，或者Arrays.sort()等方法中。</li>
</ol>
<h2 id="_67">前缀树<a class="headerlink" href="#_67" title="Permanent link">&para;</a></h2>
<h3 id="_68">原理<a class="headerlink" href="#_68" title="Permanent link">&para;</a></h3>
<ol>
<li>假设有字符串"acb","cba","acc"。则前缀树是一种特殊的N叉树，它被用来存储字符串。则由这三个字符串构成的前缀树是。一般都是将字符放在路上(通过长度为26的数组的下标来表示。比如0位置就是走向a分支)，而不是节点上。节点就维持p信息，e信息。</li>
<li>每个节点都有2个信息：</li>
<li>pass信息：有多少字符串路过该节点(刚好来到也算)</li>
<li>end信息：有多少字符串以该节点结尾</li>
</ol>
<p><img alt="image.png" src="../assets/p-t-01.png" /></p>
<p><img alt="" src="" /></p>
<ol>
<li>信息的作用：</li>
<li>快速查看单词的出现频率。比如查看"acc"出现几次</li>
<li>查看有多少单词：就是根节点的p值,也等价于有多少单词以""空字符串开头。</li>
<li>多少字符串以"ac"开头：查看c下面的节点的p值信息</li>
<li>删除单词：首查询是否出现过。在减去p的时候，如果p=0，则需要将该节点的分支都变为无效</li>
<li>前缀树优点：根据前缀信息树的分支来快速选择，节省时间</li>
<li>前缀树缺点：比较浪费空间，和字符总数量和种类有关</li>
</ol>
<h3 id="_69">实现<a class="headerlink" href="#_69" title="Permanent link">&para;</a></h3>
<p><img alt="image.png" src="../assets/image99.png" /></p>
<ol>
<li>使用类的方式进行实现：</li>
<li>需要定义节点类，包含pass,end,nexts[]三个成员变量。通过开固定长度的nexts[]来实现树的构建。x - 'a'实现偏移量。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-52-1">class Trie {
</span><span id="__span-52-2">    class TreeNode{
</span><span id="__span-52-3">        public int pass;
</span><span id="__span-52-4">        public int end;
</span><span id="__span-52-5">        public TreeNode[] nexts;
</span><span id="__span-52-6">        public TreeNode(){
</span><span id="__span-52-7">            pass = 0;
</span><span id="__span-52-8">            end = 0;
</span><span id="__span-52-9">            nexts = new TreeNode[26];
</span><span id="__span-52-10">        }
</span><span id="__span-52-11">    }
</span><span id="__span-52-12">    private TreeNode root;
</span><span id="__span-52-13">    public Trie() {
</span><span id="__span-52-14">        root = new TreeNode();
</span><span id="__span-52-15">    }
</span><span id="__span-52-16">
</span><span id="__span-52-17">    public void insert(String word) {
</span><span id="__span-52-18">        TreeNode node = root;
</span><span id="__span-52-19">        node.pass++;
</span><span id="__span-52-20">        for(int i=0 ;i&lt;word.length();i++){
</span><span id="__span-52-21">            int path = word.charAt(i) - &#39;a&#39;;
</span><span id="__span-52-22">            if(node.nexts[path] == null){
</span><span id="__span-52-23">                node.nexts[path] = new TreeNode();
</span><span id="__span-52-24">            }
</span><span id="__span-52-25">            node = node.nexts[path];
</span><span id="__span-52-26">            node.pass++;
</span><span id="__span-52-27">        }
</span><span id="__span-52-28">        node.end++;
</span><span id="__span-52-29">    }
</span><span id="__span-52-30">
</span><span id="__span-52-31">    public boolean search(String word) {
</span><span id="__span-52-32">        TreeNode node = root;
</span><span id="__span-52-33">        for(int i=0 ;i&lt;word.length();i++){
</span><span id="__span-52-34">            int path = word.charAt(i) - &#39;a&#39;;
</span><span id="__span-52-35">            if(node.nexts[path] == null){
</span><span id="__span-52-36">                return false;
</span><span id="__span-52-37">            }
</span><span id="__span-52-38">            node = node.nexts[path];
</span><span id="__span-52-39">        }
</span><span id="__span-52-40">        return node.end == 0 ? false : true;
</span><span id="__span-52-41">    }
</span><span id="__span-52-42">
</span><span id="__span-52-43">    public boolean startsWith(String word) {
</span><span id="__span-52-44">        TreeNode node = root;
</span><span id="__span-52-45">        for(int i=0 ;i&lt;word.length();i++){
</span><span id="__span-52-46">            int path = word.charAt(i) - &#39;a&#39;;
</span><span id="__span-52-47">            if(node.nexts[path] == null){
</span><span id="__span-52-48">                return false;
</span><span id="__span-52-49">            }
</span><span id="__span-52-50">            node = node.nexts[path];
</span><span id="__span-52-51">        }
</span><span id="__span-52-52">        return true;
</span><span id="__span-52-53">    }
</span><span id="__span-52-54">}
</span></code></pre></div></td></tr></table></div>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-53-1">class Trie{
</span><span id="__span-53-2">  private case class TreeNode (
</span><span id="__span-53-3">    var pass:Int = 0,
</span><span id="__span-53-4">    var end:Int = 0,
</span><span id="__span-53-5">    var nexts:Array[Option[TreeNode]] = Array.fill(26)(None)
</span><span id="__span-53-6">  )
</span><span id="__span-53-7">  private val root = TreeNode()
</span><span id="__span-53-8">
</span><span id="__span-53-9">  def insert(word:String): Unit = {
</span><span id="__span-53-10">    var node = root
</span><span id="__span-53-11">    node.pass += 1
</span><span id="__span-53-12">    for(i&lt;-word.indices){
</span><span id="__span-53-13">      val path = word(i) - &#39;a&#39;
</span><span id="__span-53-14">      if(node.nexts(path).isEmpty) node.nexts(path) = Some(TreeNode())
</span><span id="__span-53-15">      node = node.nexts(path).get
</span><span id="__span-53-16">      node.pass += 1
</span><span id="__span-53-17">    }
</span><span id="__span-53-18">    node.end += 1
</span><span id="__span-53-19">  }
</span><span id="__span-53-20">  def search(word:String): Boolean = {
</span><span id="__span-53-21">    var node = root
</span><span id="__span-53-22">    @scala.annotation.tailrec
</span><span id="__span-53-23">    def go(n:TreeNode, i:Int):Boolean = {
</span><span id="__span-53-24">      if(i == word.length) return node.end != 0
</span><span id="__span-53-25">      val path = word(i) - &#39;a&#39;
</span><span id="__span-53-26">      if(node.nexts(path).isEmpty) return false
</span><span id="__span-53-27">      node = node.nexts(path).get
</span><span id="__span-53-28">      go(node,i+1)
</span><span id="__span-53-29">    }
</span><span id="__span-53-30">    go(node,0)
</span><span id="__span-53-31">  }
</span><span id="__span-53-32">
</span><span id="__span-53-33">  def startsWith(word:String):Boolean = {
</span><span id="__span-53-34">    var node = root
</span><span id="__span-53-35">    @scala.annotation.tailrec
</span><span id="__span-53-36">    def go(n:TreeNode, i:Int):Boolean = {
</span><span id="__span-53-37">      if(i == word.length) return true
</span><span id="__span-53-38">      val path = word(i) - &#39;a&#39;
</span><span id="__span-53-39">      if(node.nexts(path).isEmpty) return false
</span><span id="__span-53-40">      node = node.nexts(path).get
</span><span id="__span-53-41">      go(node,i+1)
</span><span id="__span-53-42">    }
</span><span id="__span-53-43">    go(node,0)
</span><span id="__span-53-44">  }
</span><span id="__span-53-45">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>使用静态数组的方式实现。一次性开足足够的空间</li>
<li>假设树一共会开m个节点(m&gt;实际节点数)，每个节点下有n个选择。则int[][] tree = new int[m][n];</li>
<li>pass,end信息分别使用一维的数组；</li>
<li>假设从cnt=1下标的节点为(根节点)开始。使用cnt代表分配的节点，等价于new</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-54-1">    // 如果将来增加了数据量，就改大这个值
</span><span id="__span-54-2">    public static int MAXN = 150001;
</span><span id="__span-54-3">
</span><span id="__span-54-4">    public static int[][] tree = new int[MAXN][26];
</span><span id="__span-54-5">
</span><span id="__span-54-6">    public static int[] end = new int[MAXN];
</span><span id="__span-54-7">
</span><span id="__span-54-8">    public static int[] pass = new int[MAXN];
</span><span id="__span-54-9">
</span><span id="__span-54-10">    public static int cnt;
</span><span id="__span-54-11">
</span><span id="__span-54-12">    public static void build() {
</span><span id="__span-54-13">        cnt = 1;
</span><span id="__span-54-14">        for(int i=0; i&lt;MAXN;i++){
</span><span id="__span-54-15">            Arrays.fill(tree[i],0);
</span><span id="__span-54-16">        }
</span><span id="__span-54-17">        Arrays.fill(end,0);
</span><span id="__span-54-18">        Arrays.fill(pass,0);
</span><span id="__span-54-19">    }
</span><span id="__span-54-20">
</span><span id="__span-54-21">    public static void insert(String word) {
</span><span id="__span-54-22">        int cur = 1;
</span><span id="__span-54-23">        pass[cur]++;
</span><span id="__span-54-24">        for (int i = 0, path; i &lt; word.length(); i++) {
</span><span id="__span-54-25">            path = word.charAt(i) - &#39;a&#39;;
</span><span id="__span-54-26">            if (tree[cur][path] == 0) {
</span><span id="__span-54-27">                //使用cnt给他分配编号
</span><span id="__span-54-28">                tree[cur][path] = ++cnt;
</span><span id="__span-54-29">            }
</span><span id="__span-54-30">            cur = tree[cur][path];
</span><span id="__span-54-31">            pass[cur]++;
</span><span id="__span-54-32">        }
</span><span id="__span-54-33">        end[cur]++;
</span><span id="__span-54-34">    }
</span><span id="__span-54-35">
</span><span id="__span-54-36">    public static int search(String word) {
</span><span id="__span-54-37">        int cur = 1;
</span><span id="__span-54-38">        for (int i = 0, path; i &lt; word.length(); i++) {
</span><span id="__span-54-39">            path = word.charAt(i) - &#39;a&#39;;
</span><span id="__span-54-40">            if (tree[cur][path] == 0) {
</span><span id="__span-54-41">                return 0;
</span><span id="__span-54-42">            }
</span><span id="__span-54-43">            cur = tree[cur][path];
</span><span id="__span-54-44">        }
</span><span id="__span-54-45">        return end[cur];
</span><span id="__span-54-46">    }
</span><span id="__span-54-47">
</span><span id="__span-54-48">    public static int prefixNumber(String pre) {
</span><span id="__span-54-49">        int cur = 1;
</span><span id="__span-54-50">        for (int i = 0, path; i &lt; pre.length(); i++) {
</span><span id="__span-54-51">            path = pre.charAt(i) - &#39;a&#39;;
</span><span id="__span-54-52">            if (tree[cur][path] == 0) {
</span><span id="__span-54-53">                return 0;
</span><span id="__span-54-54">            }
</span><span id="__span-54-55">            cur = tree[cur][path];
</span><span id="__span-54-56">        }
</span><span id="__span-54-57">        return pass[cur];
</span><span id="__span-54-58">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_70">例题<a class="headerlink" href="#_70" title="Permanent link">&para;</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">数组中两个数的最大异或值</a></li>
<li>暴力解法：2重for循环解决</li>
<li>前缀树解法：<ol>
<li>将每个数使用二进制表示，如果数字有32位，也就是将32位字符串存入前缀树中。将数字存入前缀树中。</li>
<li>因为所有的数都是非负数，则补码表示都是以0开头(符号位)，根节点下面开始从最高位开始选择。如果要结果尽可能大，就需要从高位看起，1的出现的可能性需要最大。</li>
<li>。对于每个数，在前缀树中查询相应的最优解。</li>
<li>最后一定要clear，防止脏数据的影响。</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-55-1">class Solution {
</span><span id="__span-55-2">    public static int MAXN = 3000001;
</span><span id="__span-55-3">    public static int[][] tree = new int[MAXN][2];
</span><span id="__span-55-4">    public static int[] pass = new int[MAXN];
</span><span id="__span-55-5">    public static int[] end = new int[MAXN];
</span><span id="__span-55-6">    public static int cnt;
</span><span id="__span-55-7">    public int findMaximumXOR(int[] nums) {
</span><span id="__span-55-8">        bulid(nums);
</span><span id="__span-55-9">        int ans = 0;
</span><span id="__span-55-10">        for(int item:nums){
</span><span id="__span-55-11">            ans = Math.max(ans,maxXor(item));
</span><span id="__span-55-12">        }
</span><span id="__span-55-13">        clear();
</span><span id="__span-55-14">        return ans;
</span><span id="__span-55-15">    }
</span><span id="__span-55-16">    public static void bulid(int[] nums){
</span><span id="__span-55-17">        cnt = 1;
</span><span id="__span-55-18">        for(int item : nums){
</span><span id="__span-55-19">            insert(item);
</span><span id="__span-55-20">        }
</span><span id="__span-55-21">    }
</span><span id="__span-55-22">    public static void insert(int num){
</span><span id="__span-55-23">        int cur = 1;
</span><span id="__span-55-24">        pass[cur]++;
</span><span id="__span-55-25">        for(int i = 31;i&gt;=0;i--){
</span><span id="__span-55-26">            int path = (num &gt;&gt; i) &amp; 1;
</span><span id="__span-55-27">            if(tree[cur][path] == 0){
</span><span id="__span-55-28">                tree[cur][path] = ++cnt;
</span><span id="__span-55-29">            }
</span><span id="__span-55-30">            cur = tree[cur][path];
</span><span id="__span-55-31">            pass[cur]++;
</span><span id="__span-55-32">        }
</span><span id="__span-55-33">        end[cur]++;
</span><span id="__span-55-34">    }
</span><span id="__span-55-35">
</span><span id="__span-55-36">    public static int maxXor(int num){
</span><span id="__span-55-37">        int cur = 1;
</span><span id="__span-55-38">        int ans = 0;
</span><span id="__span-55-39">        for(int i=31;i&gt;=0;i--){
</span><span id="__span-55-40">            //nums第i的状态
</span><span id="__span-55-41">            int status = (num &gt;&gt; i) &amp; 1;
</span><span id="__span-55-42">            //想要的状态
</span><span id="__span-55-43">            int want = status ^ 1;
</span><span id="__span-55-44">            if(tree[cur][want] == 0){
</span><span id="__span-55-45">                //如果没有，就只能往反方向走
</span><span id="__span-55-46">                want = want ^ 1;
</span><span id="__span-55-47">            }
</span><span id="__span-55-48">            //如果status^want==1，则第i位就是1。和ans取大值(还是1)
</span><span id="__span-55-49">            //如果status^want=0,则第i位就是0，如果ans是0，最终还是0,否则还是1
</span><span id="__span-55-50">            ans |= (status ^ want) &lt;&lt; i;
</span><span id="__span-55-51">            cur = tree[cur][want];
</span><span id="__span-55-52">        }
</span><span id="__span-55-53">        return ans;
</span><span id="__span-55-54">    }
</span><span id="__span-55-55">    public static void clear() {
</span><span id="__span-55-56">        for (int i = 1; i &lt;= cnt; i++) {
</span><span id="__span-55-57">            tree[i][0] = tree[i][1] = 0;
</span><span id="__span-55-58">        }
</span><span id="__span-55-59">    }
</span><span id="__span-55-60">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 14最长公共前缀</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-56-1">class Solution {
</span><span id="__span-56-2">    public static int MAXN = 203;
</span><span id="__span-56-3">    public static int[][] tree = new int[MAXN][26];
</span><span id="__span-56-4">    public static int[] end = new int[MAXN];
</span><span id="__span-56-5">    public static int[] pass = new int[MAXN];
</span><span id="__span-56-6">    public static int cnt;
</span><span id="__span-56-7">    public String longestCommonPrefix(String[] strs) {
</span><span id="__span-56-8">        build();
</span><span id="__span-56-9">        Arrays.sort(strs,(a,b)-&gt;(a.length()-b.length()));
</span><span id="__span-56-10">        String word = strs[0];
</span><span id="__span-56-11">        for(String item : strs){
</span><span id="__span-56-12">            insert(item);
</span><span id="__span-56-13">        }
</span><span id="__span-56-14">        int v = strs.length;
</span><span id="__span-56-15">        String ans = &quot;&quot;;
</span><span id="__span-56-16">        for(int i=1; i&lt;=word.length();i++){
</span><span id="__span-56-17">            String pre = word.substring(0,i);
</span><span id="__span-56-18">            int cnt = prefix(pre);
</span><span id="__span-56-19">            if(cnt == v){
</span><span id="__span-56-20">                v = cnt;
</span><span id="__span-56-21">                ans = pre;
</span><span id="__span-56-22">            }
</span><span id="__span-56-23">        }
</span><span id="__span-56-24">        return ans;
</span><span id="__span-56-25">    }
</span><span id="__span-56-26">    public void build(){
</span><span id="__span-56-27">        cnt = 1;
</span><span id="__span-56-28">        for(int i=0; i&lt;MAXN;i++){
</span><span id="__span-56-29">            Arrays.fill(tree[i],0);
</span><span id="__span-56-30">        }
</span><span id="__span-56-31">        Arrays.fill(end,0);
</span><span id="__span-56-32">        Arrays.fill(pass,0);
</span><span id="__span-56-33">    }
</span><span id="__span-56-34">    public void insert(String word){
</span><span id="__span-56-35">        int cur = 1;
</span><span id="__span-56-36">        pass[cur]++;
</span><span id="__span-56-37">        for(int i=0,path; i&lt;word.length();i++){
</span><span id="__span-56-38">            path = word.charAt(i)-&#39;a&#39;;
</span><span id="__span-56-39">            //分配节点编号
</span><span id="__span-56-40">            if(tree[cur][path] == 0){
</span><span id="__span-56-41">                tree[cur][path] = ++cnt;
</span><span id="__span-56-42">            }
</span><span id="__span-56-43">            cur = tree[cur][path];
</span><span id="__span-56-44">            pass[cur]++;
</span><span id="__span-56-45">        }
</span><span id="__span-56-46">        end[cur]++;
</span><span id="__span-56-47">    }
</span><span id="__span-56-48">    public int search(String word){
</span><span id="__span-56-49">        int cur = 1;
</span><span id="__span-56-50">        for(int i=0,path;i&lt;word.length();i++){
</span><span id="__span-56-51">            path = word.charAt(i)-&#39;a&#39;;
</span><span id="__span-56-52">            if(tree[cur][path] == 0){
</span><span id="__span-56-53">                return 0;
</span><span id="__span-56-54">            }
</span><span id="__span-56-55">            cur = tree[cur][path];
</span><span id="__span-56-56">        }
</span><span id="__span-56-57">        return end[cur];
</span><span id="__span-56-58">    }
</span><span id="__span-56-59">    public int prefix(String pre){
</span><span id="__span-56-60">        int cur = 1;
</span><span id="__span-56-61">        for(int i=0,path;i&lt;pre.length();i++){
</span><span id="__span-56-62">            path = pre.charAt(i)-&#39;a&#39;;
</span><span id="__span-56-63">            if(tree[cur][path] == 0){
</span><span id="__span-56-64">                return 0;
</span><span id="__span-56-65">            }
</span><span id="__span-56-66">            cur = tree[cur][path];
</span><span id="__span-56-67">        }
</span><span id="__span-56-68">        return pass[cur];
</span><span id="__span-56-69">    }
</span><span id="__span-56-70">}
</span></code></pre></div></td></tr></table></div>
<h2 id="kmp">KMP算法<a class="headerlink" href="#kmp" title="Permanent link">&para;</a></h2>
<h3 id="_71">概念<a class="headerlink" href="#_71" title="Permanent link">&para;</a></h3>
<p>核心概念：</p>
<ol>
<li>暴力方法每次都重新进行匹配，并没有利用之前操作的信息，而kmp算法会使用到之前匹配所提炼出的信息。</li>
<li>
<p>next数组的定义：</p>
</li>
<li>
<p>next[i]：含义一：存储的是[0,i)的字符串的前缀和后缀的最大匹配长度。如果没有[0,i)位置的子串则规定为-1。终止位置的next值是整个字符串的前后缀匹配的最大长度。</p>
</li>
<li>next[i]：含义二：另一个含义是pre向前跳的下一位下标，也就是比对的下一个下标。</li>
<li>字符串前缀：字符串首部。字符串真前缀：指的是除了s本身的子串。</li>
<li>字符串后缀：字符串尾部。字符串真后缀：指的是除了s本身的尾串。</li>
<li>前后缀可以交叉。</li>
<li>比如abab:则前缀和后缀匹配的最大长度是2(是ab)。</li>
<li>next数组的求解：</li>
<li>前两项固定：next[0] = -1, next[1] = 0;</li>
<li>如果对于i位置的next[i],</li>
<li>如果s[i] = s<a href="使用的是next含义2">pre</a>，则next[i] = ++pre(使用的是next含义1).</li>
<li>如果s[i] !=s[pre] 并且如果pre&gt;0,则pre = next<a href="next含义2">pre</a>，也就是继续向左跳，直到找到一个可以满足条件的最大的值，此时返回到步骤一。</li>
<li>如果都不满足，也就是pre&lt;=0 了，pre不用再跳了，当前的next[i]也就没有最大的匹配长度，设置值为0.</li>
<li>总结概括为不用跳，跳多次，以及边界处理的情况。</li>
</ol>
<p><img alt="" src="" /></p>
<p><img alt="image.png" src="../assets/image100.png" /></p>
<p><strong>🔔</strong></p>
<p>next[i]存储的就是每一次向前跳的下标。因为如果当前的‘x’和‘前’不等，则也就证明next[10]所提供的最长匹配前后缀无法使用全部，只能退而求其次，保留这里面的0-9的最长前缀以及 后一部分的最长后缀。又因为前后两个已经完全匹配，则可以转化为在0-9求最长前后缀匹配，也就是next[x]。这样如果‘下’和‘前’相等，则next[11]就得到结果了。</p>
<p><img alt="image.png" src="../assets/image102.png" /></p>
<hr />
<p><img alt="" src="" /></p>
<p><img alt="image.png" src="../assets/image103.png" /></p>
<p>例子如上：在大串s1中使用匹配子串s2。</p>
<ol>
<li>先获得s2的next数组。</li>
<li>进行匹配。如果遇到两个位置不匹配的数，比如如上的13位置的a与t。</li>
<li>加速要点1：使用next数组</li>
<li>因为next[13] = 6,则[0,6]必然等于[7,13).</li>
<li>因为匹配的原因，则已经走过的子串必然是相等，则s1[6,13)==s2[6,13).</li>
<li>所以s1[6,13）== s2[0,6）</li>
<li>加速要点2：为什么可以直接跳</li>
</ol>
<p><img alt="image.png" src="../assets/image104.png" /></p>
<ol>
<li>假设s1[i,j)和s2[0,k)匹配已经匹配，并且s1[p,j)和s2的next[k]匹配。为什么不可以从p之前开始匹配呢？</li>
<li>使用反证法，如果开头在p之前，则因为需要和s2去匹配，如果可以匹配，则证明s2有更大的前后缀最大匹配长度，显然和事实不符和。则可以直接跳到p位置。</li>
</ol>
<p><strong>💡</strong></p>
<p>也就是任意匹配的前后缀都可以满足跳跃，但是最大前后缀匹配可以满足一次跳跃的长度最大，保证最大化利用信息。</p>
<ol>
<li>则下一次匹配s1[13]开始匹配s2[6].</li>
</ol>
<h3 id="_72">例题<a class="headerlink" href="#_72" title="Permanent link">&para;</a></h3>
<ol>
<li>leetcode 28:模板题</li>
<li>时间复杂度：O(n+m)。暴力匹配是O(n*m)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-57-1">class Solution {
</span><span id="__span-57-2">    public int strStr(String haystack, String needle) {
</span><span id="__span-57-3">        return kmp(haystack.toCharArray(),needle.toCharArray());
</span><span id="__span-57-4">    }
</span><span id="__span-57-5">    public static int kmp(char[] s1, char[] s2){
</span><span id="__span-57-6">        int m = s1.length, n = s2.length;
</span><span id="__span-57-7">        int x = 0, y = 0;
</span><span id="__span-57-8">        int[] next = nextArray(s2);
</span><span id="__span-57-9">        while(x &lt; m &amp;&amp; y &lt; n){
</span><span id="__span-57-10">            if(s1[x] == s2[y]){
</span><span id="__span-57-11">                x++;
</span><span id="__span-57-12">                y++;
</span><span id="__span-57-13">            }else{
</span><span id="__span-57-14">                if(y == 0){
</span><span id="__span-57-15">                    x++;
</span><span id="__span-57-16">                }else{
</span><span id="__span-57-17">                    y = next[y];
</span><span id="__span-57-18">                }
</span><span id="__span-57-19">            }
</span><span id="__span-57-20">        }
</span><span id="__span-57-21">        return y == n? x-y : -1;
</span><span id="__span-57-22">    }
</span><span id="__span-57-23">    public static int[] nextArray(char[] s){
</span><span id="__span-57-24">        int m = s.length;
</span><span id="__span-57-25">        if(m == 1) return new int[]{-1};
</span><span id="__span-57-26">        int[] next = new int[m];
</span><span id="__span-57-27">        next[0] = -1;
</span><span id="__span-57-28">        next[1] = 0;
</span><span id="__span-57-29">        int cur = 2, pre = 0;
</span><span id="__span-57-30">        while(cur &lt; m){
</span><span id="__span-57-31">            if(s[cur-1] == s[pre]){
</span><span id="__span-57-32">                next[cur++] = ++pre;
</span><span id="__span-57-33">            }else{
</span><span id="__span-57-34">                if(pre &gt; 0){
</span><span id="__span-57-35">                    pre = next[pre];
</span><span id="__span-57-36">                }else{
</span><span id="__span-57-37">                    next[cur++] = 0;
</span><span id="__span-57-38">                }
</span><span id="__span-57-39">            }
</span><span id="__span-57-40">        }
</span><span id="__span-57-41">        return next;
</span><span id="__span-57-42">    }
</span><span id="__span-57-43">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_73">简化版本<a class="headerlink" href="#_73" title="Permanent link">&para;</a></h3>
<ol>
<li>前缀函数π</li>
</ol>
<p>π数组：π[i]表示字符串第i个前缀的最长匹配真前后缀长度。</p>
<p>KMP只是前缀函数的子集或者说是一种应用。</p>
<p><img alt="image.png" src="../assets/kmp01.png" /></p>
<ol>
<li>模式串和被搜索串的处理</li>
<li>将模式串和搜索串合并在一起，并对该字符串计算前缀函数。</li>
</ol>
<p><img alt="image.png" src="../assets/kmp02.png" /></p>
<ol>
<li>如果有个π[i]等于模式串的长度，则说明匹配了模式串。而所匹配的串就是[i-π+1,i];</li>
</ol>
<p><img alt="image.png" src="../assets/kmp03.png" /></p>
<ol>
<li>则根据前缀函数，就可以直接计算是否匹配。并得到相应的下标。</li>
<li>
<p>前缀函数的计算</p>
</li>
<li>
<p>当前计算π[i]。</p>
</li>
<li>则和kmp中计算next数组完全一致，进行比对，不同就使用π数组向前跳。</li>
</ol>
<p><img alt="" src="" /></p>
<p><img alt="image.png" src="../assets/kmp05.png" /></p>
<h2 id="_74">滑动窗口<a class="headerlink" href="#_74" title="Permanent link">&para;</a></h2>
<h3 id="_75">原理<a class="headerlink" href="#_75" title="Permanent link">&para;</a></h3>
<ol>
<li>通过L和R双指针来控制窗口滑动，有[L,R]以及[L,R)两种。</li>
<li>关键：找到范围和答案指标之间的单调性关系，标志性就是while操作。</li>
<li>单调性就是当右侧引入数字的时候，此时窗口满足某个性质(并且可以进行下一步操作，也就是使用while)。可以通过调整左侧窗口，使得窗口大小进行调整。</li>
<li>注意L和R都是不回退的，所以称为滑动窗口</li>
<li>时间复杂度：O(N)。时间复杂度是操作数与数据量的关系。while循环中的sum += num[r++]，以及sum -= nums[l]之和最多2n次，因为滑动窗口中指针不回退，遍历一遍就结束了。</li>
<li>一般流程：就是每个子数组在开头或者结尾的情况，开头或者是结尾都可以。</li>
</ol>
<h3 id="_76">例题<a class="headerlink" href="#_76" title="Permanent link">&para;</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">累加和大于等于target的最短数组</a></li>
</ol>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其总和大于等于 target 的长度最小的 子数组[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。nums中全是正数。</p>
<ol>
<li>思路：使用滑动窗口进行流量控制</li>
<li>每进来一个数字，对于窗口中的sum进行条件检查，看是否另一侧可以调整。</li>
<li>单调性：维护的是sum.因为一个数字进来的时候，sum必然变大，则可以尝试将另一边进行缩小(此时sum必然减小而不是增加)</li>
<li>此处的调整是指让本题目的符合条件的子数组最小，也就是进行窗口的大小调整。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-58-1">public static int minSubArrayLen(int target, int[] nums) {
</span><span id="__span-58-2">    int ans = Integer.MAX_VALUE;
</span><span id="__span-58-3">    for (int l = 0, r = 0, sum = 0; r &lt; nums.length; r++) {
</span><span id="__span-58-4">        sum += nums[r];
</span><span id="__span-58-5">        while (sum - nums[l] &gt;= target) {
</span><span id="__span-58-6">            // sum : nums[l....r]
</span><span id="__span-58-7">            // 如果l位置的数从窗口出去，还能继续达标，那就出去
</span><span id="__span-58-8">            sum -= nums[l++];
</span><span id="__span-58-9">        }
</span><span id="__span-58-10">        //此处进行的特判是有必要的，保证数组只有满足sum&gt;=target才可以进行更新
</span><span id="__span-58-11">        if (sum &gt;= target) {
</span><span id="__span-58-12">            ans = Math.min(ans, r - l + 1);
</span><span id="__span-58-13">        }
</span><span id="__span-58-14">    }
</span><span id="__span-58-15">    return ans == Integer.MAX_VALUE ? 0 : ans;
</span><span id="__span-58-16">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">无重复字符的最长字串</a></li>
<li>思路：对于以每个位置结束的子串，调整滑动窗口的大小，使得窗口中的字符始终保持要求的性质，也就是无重复性</li>
<li>核心的更新公式：<ol>
<li>如果是f ....abdcf，则L = L，而不是回退，因为回退会导致之前的调整失效，重新引入重复字符。</li>
<li>单调性：维护的是重复性：也就是当右侧引入一个元素时候，左侧滑动必然会使得当前区间的性质不变(也就是不会引入新重复元素，重复性只会减小)</li>
<li>如果是 abfdf，则L = pos[f]+1,需要进行更新</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-59-1">class Solution {
</span><span id="__span-59-2">    public int lengthOfLongestSubstring(String s) {
</span><span id="__span-59-3">        char[] arr = s.toCharArray();
</span><span id="__span-59-4">        int ans = 0;
</span><span id="__span-59-5">        //每种字符出现的位置，将字符转换为0-255的整数
</span><span id="__span-59-6">        int[] last = new int[256];
</span><span id="__span-59-7">        Arrays.fill(last,-1);
</span><span id="__span-59-8">
</span><span id="__span-59-9">        for(int l=0, r=0; r&lt;arr.length; r++){
</span><span id="__span-59-10">            l = Math.max(l, last[(int)arr[r]]+1);
</span><span id="__span-59-11">            ans = Math.max(ans, r-l+1);
</span><span id="__span-59-12">            last[arr[r]] = r;
</span><span id="__span-59-13">        }
</span><span id="__span-59-14">        return ans;
</span><span id="__span-59-15">    }
</span><span id="__span-59-16">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖字串</a></li>
<li>题目含义：给你一个字符串 <code>&lt;span&gt;s&lt;/span&gt;</code> 、一个字符串 <code>&lt;span&gt;t&lt;/span&gt;</code> 。返回 <code>&lt;span&gt;s&lt;/span&gt;</code> 中涵盖 <code>&lt;span&gt;t&lt;/span&gt;</code> 所有字符的最小子串。如果 <code>&lt;span&gt;s&lt;/span&gt;</code> 中不存在涵盖 <code>&lt;span&gt;t&lt;/span&gt;</code> 所有字符的子串，则返回空字符串 <code>&lt;span&gt;""&lt;/span&gt;</code></li>
<li>核心思路：使用滑动窗口。对于以每个位置结束的子串，在滑动窗口中检查是否满足覆盖的性质。如果满足，则尝试调整大小，最终得到最小字串。</li>
<li>单调性：维护的是涵盖性：当左侧滑动的时候，涵盖性必然是减小或者不变。可以使用while直到性质不满足。</li>
<li>字符的出现次数，使用数组进行哈希表的实现。其中cnts[]代表的是t中每种元素的出现次数。然后当进行调整的时候，使用的debt就是指的t的所有种类的字符全都被满足了，也就是以当前字符结尾的子串满足了覆盖的性质。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-60-1">class Solution {
</span><span id="__span-60-2">    public String minWindow(String str, String ttr) {
</span><span id="__span-60-3">
</span><span id="__span-60-4">        int[] cnts = new int[256];
</span><span id="__span-60-5">        char[] s = str.toCharArray();
</span><span id="__span-60-6">        char[] t = ttr.toCharArray();
</span><span id="__span-60-7">        if(s.length &lt; t.length) return &quot;&quot;;
</span><span id="__span-60-8">        for(char item : t){
</span><span id="__span-60-9">            cnts[(int)item]--;
</span><span id="__span-60-10">        }
</span><span id="__span-60-11">        int len = Integer.MAX_VALUE;
</span><span id="__span-60-12">        int start = 0;
</span><span id="__span-60-13">        for(int l=0,r=0,debt=t.length; r&lt;s.length;r++){
</span><span id="__span-60-14">            if(cnts[s[r]] &lt; 0){
</span><span id="__span-60-15">                debt--;
</span><span id="__span-60-16">            }
</span><span id="__span-60-17">            cnts[s[r]]++;
</span><span id="__span-60-18">            if(debt == 0){
</span><span id="__span-60-19">                while(cnts[s[l]] &gt; 0){
</span><span id="__span-60-20">                    cnts[s[l]]--;
</span><span id="__span-60-21">                    l++;
</span><span id="__span-60-22">                }
</span><span id="__span-60-23">                if(r-l+1 &lt; len){
</span><span id="__span-60-24">                    len = r-l+1;
</span><span id="__span-60-25">                    start = l;
</span><span id="__span-60-26">                }
</span><span id="__span-60-27">            }
</span><span id="__span-60-28">        }
</span><span id="__span-60-29">        return len == Integer.MAX_VALUE ? &quot;&quot; : str.substring(start,start+len);  
</span><span id="__span-60-30">    }
</span><span id="__span-60-31">
</span><span id="__span-60-32">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li><a href="https://leetcode.cn/problems/gas-station/">加油站的出发点</a></li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-61-1">class Solution {
</span><span id="__span-61-2">    public int canCompleteCircuit(int[] gas, int[] cost) {
</span><span id="__span-61-3">        int n = gas.length;
</span><span id="__span-61-4">
</span><span id="__span-61-5">        for(int l=0,r=0,sum = 0, len = 0;l&lt;n;l++){
</span><span id="__span-61-6">            while(sum &gt;= 0){
</span><span id="__span-61-7">                if(len == n){
</span><span id="__span-61-8">                    return l;
</span><span id="__span-61-9">                }
</span><span id="__span-61-10">                r = (l + len)%n;
</span><span id="__span-61-11">                len++;
</span><span id="__span-61-12">                sum += gas[r] -  cost[r];
</span><span id="__span-61-13">            }
</span><span id="__span-61-14">            len--;
</span><span id="__span-61-15">            sum -= gas[l] - cost[l];
</span><span id="__span-61-16">
</span><span id="__span-61-17">        }
</span><span id="__span-61-18">        return -1;
</span><span id="__span-61-19">    }
</span><span id="__span-61-20">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode1984 数组中的k个元素的最小极差：</li>
<li>结论：如果要求任意k个元素的最小极差，需要进行排序，然后使用相邻的k个元素一组，使用滑动窗口进行遍历，窗口中元素的极差是nums[r]-nums[l]。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-62-1">class Solution {
</span><span id="__span-62-2">    public int minimumDifference(int[] nums, int k) {
</span><span id="__span-62-3">        int ans = Integer.MAX_VALUE;
</span><span id="__span-62-4">        int n = nums.length;
</span><span id="__span-62-5">        Arrays.sort(nums);
</span><span id="__span-62-6">        if(nums.length == 1){
</span><span id="__span-62-7">            return 0;
</span><span id="__span-62-8">        }
</span><span id="__span-62-9">        for(int l=0,r = k-1; r&lt;n;l++,r++){
</span><span id="__span-62-10">            ans = Math.min(ans,nums[r]- nums[l]);
</span><span id="__span-62-11">        }
</span><span id="__span-62-12">        return ans;
</span><span id="__span-62-13">    }
</span><span id="__span-62-14">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode1652 拆炸弹：</li>
<li>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 的 <strong>循环</strong> 数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;code&lt;/span&gt;&lt;/span&gt;</code> 以及一个密钥 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 。</li>
</ol>
<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 <strong>同时</strong> 被替换。</p>
<ul>
<li>如果 <code>&lt;span class="color_font"&gt;&lt;span&gt;k &gt; 0&lt;/span&gt;&lt;/span&gt;</code> ，将第 <code>&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;</code> 个数字用 <strong>接下来</strong> <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 个数字之和替换。</li>
<li>如果 <code>&lt;span class="color_font"&gt;&lt;span&gt;k &lt; 0&lt;/span&gt;&lt;/span&gt;</code> ，将第 <code>&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;</code> 个数字用 <strong>之前</strong> <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 个数字之和替换。</li>
<li>如果 <code>&lt;span class="color_font"&gt;&lt;span&gt;k == 0&lt;/span&gt;&lt;/span&gt;</code> ，将第 <code>&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;</code> 个数字用 <code>&lt;span class="color_font"&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;</code> 替换。</li>
</ul>
<p>由于 <code>&lt;span class="color_font"&gt;&lt;span&gt;code&lt;/span&gt;&lt;/span&gt;</code> 是循环的， <code>&lt;span class="color_font"&gt;&lt;span&gt;code[n-1]&lt;/span&gt;&lt;/span&gt;</code> 下一个元素是 <code>&lt;span class="color_font"&gt;&lt;span&gt;code[0]&lt;/span&gt;&lt;/span&gt;</code> ，且 <code>&lt;span class="color_font"&gt;&lt;span&gt;code[0]&lt;/span&gt;&lt;/span&gt;</code> 前一个元素是 <code>&lt;span class="color_font"&gt;&lt;span&gt;code[n-1]&lt;/span&gt;&lt;/span&gt;</code> 。</p>
<p>给你 <strong>循环</strong> 数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;code&lt;/span&gt;&lt;/span&gt;</code> 和整数密钥 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> ，请你返回解密后的结果来拆除炸弹！</p>
<ol>
<li>思路：每个位置的数i，对应的滑动窗口是其后面或者前面的定长数组。和加油站的题类似，复用sum。同时提前初始化base case,方便后续窗口滑动。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-63-1">class Solution {
</span><span id="__span-63-2">    public int[] decrypt(int[] code, int k) {
</span><span id="__span-63-3">        int n = code.length;
</span><span id="__span-63-4">        int[] ans = new int[n];
</span><span id="__span-63-5">        Arrays.fill(ans, 0);
</span><span id="__span-63-6">        if(k == 0) return ans;
</span><span id="__span-63-7">        int cnt = 0;
</span><span id="__span-63-8">        int sum = 0;
</span><span id="__span-63-9">        int l = k&gt;0 ? 1:(n+k)%n;
</span><span id="__span-63-10">        int r = k&gt;0 ? k%n:(n-1)%n;
</span><span id="__span-63-11">        for (int i = l; i &lt;=r; i++) {
</span><span id="__span-63-12">            sum += code[i];
</span><span id="__span-63-13">        }
</span><span id="__span-63-14">        for(int i=0; i&lt;n;i++){
</span><span id="__span-63-15">            ans[i] = sum;
</span><span id="__span-63-16">            sum -= code[(l++)%n];
</span><span id="__span-63-17">            sum += code[(++r)%n];
</span><span id="__span-63-18">        }
</span><span id="__span-63-19">        return ans;
</span><span id="__span-63-20">    }
</span><span id="__span-63-21">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_77">单调栈<a class="headerlink" href="#_77" title="Permanent link">&para;</a></h2>
<h3 id="_78">原理<a class="headerlink" href="#_78" title="Permanent link">&para;</a></h3>
<h3 id="_79">例题<a class="headerlink" href="#_79" title="Permanent link">&para;</a></h3>
<ol>
<li><a href="https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb">求左右两边比自己小的数的位置</a></li>
<li>题目：</li>
</ol>
<p>给定一个可能含有重复值的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p>
<ol>
<li>思路：</li>
<li>暴力解法：对于每个位置，遍历左边和右边，找到对应位置。则时间复杂度O(n^2)</li>
<li>单调栈：<ol>
<li>由值的性质，将下标入栈，方便进行索引。</li>
<li>保持栈中大压小的性质，也就是单调性。</li>
<li>如果下一个数字不满足(该侧的要求被满足(也就是小大小))，则进行元素出栈。</li>
<li>最后将栈中剩余的数组进行清算</li>
<li>时间复杂度：O(n)，因为每个元素只被操作两次，也就是进栈一次，出栈一次。</li>
<li>正确性证明：<ol>
<li>如果栈中进入的数字是abc，则a&lt;b&lt;c</li>
<li>对于L: 则a的L不存在，b的L是a,c的L=b，</li>
<li>对于R: 并且abc此时都没有满足R。</li>
<li>如果出现了下一个数字d，并且d&lt;c，则c的(L,R)找到，并且栈中剩余的元素的R必然不是c，并且d的(L,R)必然没有c，则c可以弹出。</li>
</ol>
</li>
<li>重复值情况处理：如果有重复值，需要进行修正。关键就是重复值情况的处理。对于本题，就是利用后来的重复元素作暂时的R，最后复用后来的重复元素的R</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-64-1">public static void compute() {
</span><span id="__span-64-2">        //r代表栈中的元素个数，也就是栈的长度
</span><span id="__span-64-3">        r = 0;
</span><span id="__span-64-4">        int cur;
</span><span id="__span-64-5">        // 遍历阶段
</span><span id="__span-64-6">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-64-7">            // i -&gt; arr[i]
</span><span id="__span-64-8">            while (r &gt; 0 &amp;&amp; arr[stack[r - 1]] &gt;= arr[i]) {
</span><span id="__span-64-9">                cur = stack[--r];
</span><span id="__span-64-10">                // cur当前弹出的位置，左边最近且小
</span><span id="__span-64-11">                ans[cur][0] = r &gt; 0 ? stack[r - 1] : -1;
</span><span id="__span-64-12">                ans[cur][1] = i;
</span><span id="__span-64-13">            }
</span><span id="__span-64-14">            stack[r++] = i;
</span><span id="__span-64-15">        }
</span><span id="__span-64-16">        // 清算阶段
</span><span id="__span-64-17">        while (r &gt; 0) {
</span><span id="__span-64-18">            cur = stack[--r];
</span><span id="__span-64-19">            ans[cur][0] = r &gt; 0 ? stack[r - 1] : -1;
</span><span id="__span-64-20">            ans[cur][1] = -1;
</span><span id="__span-64-21">        }
</span><span id="__span-64-22">        // 修正阶段
</span><span id="__span-64-23">        // 左侧的答案不需要修正一定是正确的，只有右侧答案需要修正
</span><span id="__span-64-24">        // 从右往左修正，n-1位置的右侧答案一定是-1，不需要修正
</span><span id="__span-64-25">        for (int i = n - 2; i &gt;= 0; i--) {
</span><span id="__span-64-26">            if (ans[i][1] != -1 &amp;&amp; arr[ans[i][1]] == arr[i]) {
</span><span id="__span-64-27">                ans[i][1] = ans[ans[i][1]][1];
</span><span id="__span-64-28">            }
</span><span id="__span-64-29">        }
</span></code></pre></div></td></tr></table></div>
<ol>
<li><a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></li>
<li>给定一个整数数组 <code>&lt;span&gt;temperatures&lt;/span&gt;</code> ，表示每天的温度，返回一个数组 <code>&lt;span&gt;answer&lt;/span&gt;</code> ，其中 <code>&lt;span&gt;answer[i]&lt;/span&gt;</code> 是指对于第 <code>&lt;span&gt;i&lt;/span&gt;</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>&lt;span&gt;0&lt;/span&gt;</code> 来代替。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-65-1">public static int[] dailyTemperatures(int[] nums) {
</span><span id="__span-65-2">        int n = nums.length;
</span><span id="__span-65-3">        int[] ans = new int[n];
</span><span id="__span-65-4">        r = 0;
</span><span id="__span-65-5">        for (int i = 0, cur; i &lt; n; i++) {
</span><span id="__span-65-6">            // 相等时候的处理，相等也加入单调栈
</span><span id="__span-65-7">            while (r &gt; 0 &amp;&amp; nums[stack[r - 1]] &lt; nums[i]) {
</span><span id="__span-65-8">                cur = stack[--r];
</span><span id="__span-65-9">                ans[cur] = i - cur;
</span><span id="__span-65-10">            }
</span><span id="__span-65-11">            stack[r++] = i;
</span><span id="__span-65-12">        }
</span><span id="__span-65-13">        return ans;
</span><span id="__span-65-14">    }
</span></code></pre></div></td></tr></table></div>
<ol>
<li>子数组的最小值之和</li>
<li>给定一个整数数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;arr&lt;/span&gt;&lt;/span&gt;</code>，找到 <code>&lt;span class="color_font"&gt;&lt;span&gt;min(b)&lt;/span&gt;&lt;/span&gt;</code> 的总和，其中 <code>&lt;span class="color_font"&gt;&lt;span&gt;b&lt;/span&gt;&lt;/span&gt;</code> 的范围为 <code>&lt;span class="color_font"&gt;&lt;span&gt;arr&lt;/span&gt;&lt;/span&gt;</code> 的每个（连续）子数组。</li>
</ol>
<p>由于答案可能很大，因此<strong> 返回答案模 </strong><code>&lt;span class="color_font"&gt;&lt;strong&gt;&lt;span&gt;10^9 + 7&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;</code> 。</p>
<ol>
<li>思路：</li>
<li>重点是求最小值，如果是暴力的话则时间复杂度是O(n*logn*n^2)。</li>
<li>对于一个数组中的值，找到左边和右边最近比它小的数(则范围内的数都比他大)，则它是在该范围内的所有包含该元素的数组的最小值。这些数组的个数总共有cnt = (cur-left)*(i-cur)个。则这个部分和是cnt*nums[cur]。</li>
<li>对于这里的重复值，不用进行修正，因为后面重复值进栈的时候自然会cover这个情况。</li>
</ol>
<h2 id="_80">单调队列<a class="headerlink" href="#_80" title="Permanent link">&para;</a></h2>
<h3 id="_81">原理<a class="headerlink" href="#_81" title="Permanent link">&para;</a></h3>
<ol>
<li>最常用场景：维护每个窗口的最大值或者最小值</li>
<li>通过数组实现双端队列</li>
</ol>
<h3 id="_82">例题<a class="headerlink" href="#_82" title="Permanent link">&para;</a></h3>
<ol>
<li><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口的最大值</a></li>
<li>给你一个整数数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;nums&lt;/span&gt;&lt;/span&gt;</code>，有一个大小为 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>&lt;span class="color_font"&gt;&lt;span&gt;k&lt;/span&gt;&lt;/span&gt;</code> 个数字。滑动窗口每次只向右移动一位。</li>
</ol>
<p>返回 <em>滑动窗口中的最大值 </em>。</p>
<ol>
<li>思路：</li>
<li>对于每一个窗口，更新相应的队列，</li>
<li>保证队列的头部始终是该窗口的答案，使用的是单调队列，使得最大值始终在head位置(可以看做是元素的状态维护)</li>
<li>当窗口的l位置与队列头部相等，由于下一步l++,则必须要将head出队列，因为它过期了。</li>
<li>时间复杂度：O(1)，队列中数字只会进出一次</li>
<li>由该性质维护的队列大小是&lt;=进来的元素个数，所以如果下一个要进来，就应该将上一个头部出队列</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-66-1">class Solution {
</span><span id="__span-66-2">    public static int MAXN = 100001;
</span><span id="__span-66-3">    public static int[] deque = new int[MAXN];
</span><span id="__span-66-4">    public static int h,t;
</span><span id="__span-66-5">    public int[] maxSlidingWindow(int[] nums, int k) {
</span><span id="__span-66-6">        int n = nums.length;
</span><span id="__span-66-7">        int[] ans = new int[n-k+1];
</span><span id="__span-66-8">        h = 0;
</span><span id="__span-66-9">        t = 0;
</span><span id="__span-66-10">        //初始化要维护的队列
</span><span id="__span-66-11">        for(int i=0; i&lt;k-1; i++){
</span><span id="__span-66-12">            while(h&lt;t &amp;&amp; nums[i] &gt; nums[deque[t-1]] ){
</span><span id="__span-66-13">                t--;
</span><span id="__span-66-14">            }
</span><span id="__span-66-15">            deque[t++] = i;
</span><span id="__span-66-16">        }
</span><span id="__span-66-17">        //从第一组开始维护队列
</span><span id="__span-66-18">        for(int l=0,r=k-1; r&lt;n;l++,r++){
</span><span id="__span-66-19">            while(h &lt; t &amp;&amp; nums[r]&gt;nums[deque[t-1]]){
</span><span id="__span-66-20">                t--;
</span><span id="__span-66-21">            }
</span><span id="__span-66-22">            deque[t++] = r;
</span><span id="__span-66-23">            ans[l] = nums[deque[h]];
</span><span id="__span-66-24">            if(deque[h] == l){
</span><span id="__span-66-25">                h++;
</span><span id="__span-66-26">            }
</span><span id="__span-66-27">        }
</span><span id="__span-66-28">        return ans;
</span><span id="__span-66-29">    }
</span><span id="__span-66-30">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_83">并查集<a class="headerlink" href="#_83" title="Permanent link">&para;</a></h2>
<p>原理：</p>
<ol>
<li>
<p>定义：并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。顾名思义，并查集支持两种操作：</p>
</li>
<li>
<p>合并（Union）：合并两个元素所属集合（合并对应的树）</p>
</li>
<li>查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合</li>
<li>此处我们使用两个数组father和size数组，用来记录每个元素的数根节点以及集合的大小。</li>
<li>节点所在集合合并(Union)：节点加入，则该节点对应的father位置改为父亲节点的下标。以后查找该节点所在的集合大小是father节点的对应的size。挂的时候是小的集合挂大的集合。</li>
<li>查询：一直找该节点的父节点，递归查找直到根节点。</li>
<li>路径压缩(扁平化):向上寻找的过程中，如果找到了根节点，就将该路径上的所有节点都直接指向该节点。</li>
<li>经典优化手段：</li>
<li>扁平化：路径压缩，使用栈(辅助数组来进行路径的收集)。可以不强制扁平化，而是遇到一定长度的链在进行扁平化</li>
<li>小挂大</li>
<li>时间复杂度(结论):单次调用就是O(1)</li>
<li>区间并查集：</li>
<li>基本思路：将目光放在边上，连接三点之间的两条边，就是将这两条边归为同一个集合中，初始集合数量最多，每次合并都会减少。</li>
<li>一般不需要使用小挂大的优化，直接赋值father数组就可以。直接使用根节点，加速操作。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-67-1">class Solution {
</span><span id="__span-67-2">    public static int MAXN = 200010;
</span><span id="__span-67-3">    public static int[] father = new int[MAXN];
</span><span id="__span-67-4">    public static int[] size = new int[MAXN];
</span><span id="__span-67-5">    public static int[] stack = new int[MAXN];
</span><span id="__span-67-6">    public static int r;
</span><span id="__span-67-7">    public int[] shortestDistanceAfterQueries(int n, int[][] queries) {
</span><span id="__span-67-8">        build(n);
</span><span id="__span-67-9">        int[] ans = new int[queries.length];
</span><span id="__span-67-10">        int cnt = n-1;
</span><span id="__span-67-11">        for(int q=0; q&lt;queries.length;q++){
</span><span id="__span-67-12">            //[0,2] -&gt; [0,1],[1,2]
</span><span id="__span-67-13">            int l = queries[q][0],r = queries[q][1]-1;
</span><span id="__span-67-14">            int fr = find(r);
</span><span id="__span-67-15">            // 将区间[l,r-1]上所有元素挂到r节点下面，成为一个连通块
</span><span id="__span-67-16">            for(int i=find(l);i&lt;r;i = find(i+1)){
</span><span id="__span-67-17">                father[i] = fr;
</span><span id="__span-67-18">                cnt--;
</span><span id="__span-67-19">            }
</span><span id="__span-67-20">            ans[q] = cnt;
</span><span id="__span-67-21">        }
</span><span id="__span-67-22">        return ans;
</span><span id="__span-67-23">
</span><span id="__span-67-24">    }
</span><span id="__span-67-25">    public static void build(int n) {
</span><span id="__span-67-26">
</span><span id="__span-67-27">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-67-28">            father[i] = i;
</span><span id="__span-67-29">            size[i] = 1;
</span><span id="__span-67-30">        }
</span><span id="__span-67-31">    }
</span><span id="__span-67-32">
</span><span id="__span-67-33">    public static int find(int i) {
</span><span id="__span-67-34">        int size = 0;
</span><span id="__span-67-35">        while (i != father[i]) {
</span><span id="__span-67-36">            stack[size++] = i;
</span><span id="__span-67-37">            i = father[i];
</span><span id="__span-67-38">        }
</span><span id="__span-67-39">        while (size &gt; 0) {
</span><span id="__span-67-40">            father[stack[--size]] = i;
</span><span id="__span-67-41">        }
</span><span id="__span-67-42">        return i;
</span><span id="__span-67-43">    }
</span><span id="__span-67-44">
</span><span id="__span-67-45">    public static boolean isSameSet(int x, int y) {
</span><span id="__span-67-46">        return find(x) == find(y);
</span><span id="__span-67-47">    }
</span><span id="__span-67-48">}
</span></code></pre></div></td></tr></table></div>
<p>例题：</p>
<ol>
<li>板子题：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-68-1">object Solution {
</span><span id="__span-68-2">  val MAXN = 100007
</span><span id="__span-68-3">  val father: Array[Int] = Array.fill(MAXN)(-1)
</span><span id="__span-68-4">  val size: Array[Int] = Array.fill(MAXN)(-1)
</span><span id="__span-68-5">  def countPairs(n: Int, edges: Array[Array[Int]]): Long = {
</span><span id="__span-68-6">    build(n)
</span><span id="__span-68-7">    for(e &lt;- edges){
</span><span id="__span-68-8">      union(e(0), e(1))
</span><span id="__span-68-9">    }
</span><span id="__span-68-10">    val fIndex=  (for(i &lt;- 0 until n) yield find(i)).distinct
</span><span id="__span-68-11">    var cnt = 0L
</span><span id="__span-68-12">    for(i &lt;- fIndex){
</span><span id="__span-68-13">      cnt += size(i).toLong*(size(i)-1)/2
</span><span id="__span-68-14">    }
</span><span id="__span-68-15">    n.toLong*(n-1)/2 - cnt
</span><span id="__span-68-16">  }
</span><span id="__span-68-17">  def build(n: Int): Unit ={
</span><span id="__span-68-18">    for(i &lt;- 0 until n){
</span><span id="__span-68-19">      father(i) = i
</span><span id="__span-68-20">      size(i) = 1
</span><span id="__span-68-21">    }
</span><span id="__span-68-22">  }
</span><span id="__span-68-23">  def find(x: Int): Int = {
</span><span id="__span-68-24">    if(father(x) == x) return x
</span><span id="__span-68-25">    father(x) = find(father(x))
</span><span id="__span-68-26">    father(x)
</span><span id="__span-68-27">  }
</span><span id="__span-68-28">  def union(x: Int, y: Int): Unit = {
</span><span id="__span-68-29">    val fx = find(x)
</span><span id="__span-68-30">    val fy = find(y)
</span><span id="__span-68-31">    if(fx == fy) return
</span><span id="__span-68-32">    else{
</span><span id="__span-68-33">      if(size(fx) &gt;= size(fy)){
</span><span id="__span-68-34">        size(fx) += size(fy)
</span><span id="__span-68-35">        father(fy) = fx
</span><span id="__span-68-36">      }else{
</span><span id="__span-68-37">        size(fy) += size(fx)
</span><span id="__span-68-38">        father(fx) = fy
</span><span id="__span-68-39">      }
</span><span id="__span-68-40">    }
</span><span id="__span-68-41">  }
</span><span id="__span-68-42">  def isSameSet(x: Int, y: Int):Boolean = {find(x) == find(y)}
</span><span id="__span-68-43">}
</span></code></pre></div></td></tr></table></div>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-69-1">import java.util.Scanner;
</span><span id="__span-69-2">import java.io.*;
</span><span id="__span-69-3">
</span><span id="__span-69-4">// 注意类名必须为 Main, 不要有任何 package xxx 信息
</span><span id="__span-69-5">public class Main {
</span><span id="__span-69-6">    public static int MAXN = 1000001;
</span><span id="__span-69-7">    public static int[] father = new int[MAXN];
</span><span id="__span-69-8">    public static int[] size = new int[MAXN];
</span><span id="__span-69-9">    public static int[] stk = new int[MAXN];
</span><span id="__span-69-10">    public static int r;
</span><span id="__span-69-11">    public static int n;
</span><span id="__span-69-12">    public static void main(String[] args) throws IOException {
</span><span id="__span-69-13">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-69-14">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-69-15">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-69-16">        while (in.nextToken() != StreamTokenizer.TT_EOF) {
</span><span id="__span-69-17">            n = (int) in.nval;
</span><span id="__span-69-18">            build();
</span><span id="__span-69-19">            in.nextToken();
</span><span id="__span-69-20">            int m = (int) in.nval;
</span><span id="__span-69-21">            for (int i = 0; i &lt; m; i++) {
</span><span id="__span-69-22">                in.nextToken();
</span><span id="__span-69-23">                int op = (int) in.nval;
</span><span id="__span-69-24">                in.nextToken();
</span><span id="__span-69-25">                int x = (int) in.nval;
</span><span id="__span-69-26">                in.nextToken();
</span><span id="__span-69-27">                int y = (int) in.nval;
</span><span id="__span-69-28">                if (op == 1) {
</span><span id="__span-69-29">                    out.println(isSameSet(x, y) ? &quot;Yes&quot; : &quot;No&quot;);
</span><span id="__span-69-30">                } else {
</span><span id="__span-69-31">                    union(x, y);
</span><span id="__span-69-32">                }
</span><span id="__span-69-33">            }
</span><span id="__span-69-34">        }
</span><span id="__span-69-35">        out.flush();
</span><span id="__span-69-36">        out.close();
</span><span id="__span-69-37">        br.close();
</span><span id="__span-69-38">    }
</span><span id="__span-69-39">    public static void build(){
</span><span id="__span-69-40">        //
</span><span id="__span-69-41">        for(int i=0;i&lt;n; i++){
</span><span id="__span-69-42">            father[i] = i;
</span><span id="__span-69-43">            size[i] = 1;
</span><span id="__span-69-44">        }
</span><span id="__span-69-45">    }
</span><span id="__span-69-46">    public static int find(int x){
</span><span id="__span-69-47">        r = 0;
</span><span id="__span-69-48">        while(x != father[x]){
</span><span id="__span-69-49">            stk[r++] = father[x];
</span><span id="__span-69-50">            x = father[x];
</span><span id="__span-69-51">        }
</span><span id="__span-69-52">        while(r &gt; 0){
</span><span id="__span-69-53">            r--;
</span><span id="__span-69-54">            father[stk[r]] = x;
</span><span id="__span-69-55">        }
</span><span id="__span-69-56">        return x;
</span><span id="__span-69-57">    }
</span><span id="__span-69-58">    public static boolean isSameSet(int x, int y){
</span><span id="__span-69-59">        return find(x) == find(y) ? true : false;
</span><span id="__span-69-60">    }
</span><span id="__span-69-61">    public static void union(int x, int y){
</span><span id="__span-69-62">        int fx = find(x);
</span><span id="__span-69-63">        int fy = find(y);
</span><span id="__span-69-64">        if(fx == fy){
</span><span id="__span-69-65">            return;
</span><span id="__span-69-66">        }else{
</span><span id="__span-69-67">            if (size[fx] &gt;= size[fy]) {
</span><span id="__span-69-68">                size[fx] += size[fy];
</span><span id="__span-69-69">                father[fy] = fx;
</span><span id="__span-69-70">            } else {
</span><span id="__span-69-71">                size[fy] += size[fx];
</span><span id="__span-69-72">                father[fx] = fy;
</span><span id="__span-69-73">            }
</span><span id="__span-69-74">        }
</span><span id="__span-69-75">    }
</span><span id="__span-69-76">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 1971寻找图中是否存在路径</li>
<li>连通的图在一个集合中，可以被查找到。使用这个性质，进行查找</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-70-1">class Solution {
</span><span id="__span-70-2">    public static int MAXN = 200010;
</span><span id="__span-70-3">    public static int[] father = new int[MAXN];
</span><span id="__span-70-4">    public static int[] size = new int[MAXN];
</span><span id="__span-70-5">    public static int[] stack = new int[MAXN];
</span><span id="__span-70-6">    public static int r;
</span><span id="__span-70-7">    public boolean validPath(int n, int[][] edges, int source, int destination){ {
</span><span id="__span-70-8">        build(n);
</span><span id="__span-70-9">        for(int i=0;i&lt;edges.length;i++){
</span><span id="__span-70-10">            union(edges[i][0], edges[i][1]);
</span><span id="__span-70-11">        }
</span><span id="__span-70-12">        return find(source) == find(destination);
</span><span id="__span-70-13">    }
</span><span id="__span-70-14">    public static void build(int n) {
</span><span id="__span-70-15">
</span><span id="__span-70-16">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-70-17">            father[i] = i;
</span><span id="__span-70-18">            size[i] = 1;
</span><span id="__span-70-19">        }
</span><span id="__span-70-20">    }
</span><span id="__span-70-21">
</span><span id="__span-70-22">    public static int find(int i) {
</span><span id="__span-70-23">        int size = 0;
</span><span id="__span-70-24">        while (i != father[i]) {
</span><span id="__span-70-25">            stack[size++] = i;
</span><span id="__span-70-26">            i = father[i];
</span><span id="__span-70-27">        }
</span><span id="__span-70-28">        while (size &gt; 0) {
</span><span id="__span-70-29">            father[stack[--size]] = i;
</span><span id="__span-70-30">        }
</span><span id="__span-70-31">        return i;
</span><span id="__span-70-32">    }
</span><span id="__span-70-33">
</span><span id="__span-70-34">    public static boolean isSameSet(int x, int y) {
</span><span id="__span-70-35">        return find(x) == find(y);
</span><span id="__span-70-36">    }
</span><span id="__span-70-37">
</span><span id="__span-70-38">    public static void union(int x, int y) {
</span><span id="__span-70-39">        int fx = find(x);
</span><span id="__span-70-40">        int fy = find(y);
</span><span id="__span-70-41">        if (fx != fy) {
</span><span id="__span-70-42">            if (size[fx] &gt;= size[fy]) {
</span><span id="__span-70-43">                size[fx] += size[fy];
</span><span id="__span-70-44">                father[fy] = fx;
</span><span id="__span-70-45">            } else {
</span><span id="__span-70-46">                size[fy] += size[fx];
</span><span id="__span-70-47">                father[fx] = fy;
</span><span id="__span-70-48">            }
</span><span id="__span-70-49">        }
</span><span id="__span-70-50">    }
</span><span id="__span-70-51">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_84">图论<a class="headerlink" href="#_84" title="Permanent link">&para;</a></h2>
<h3 id="_85">建图<a class="headerlink" href="#_85" title="Permanent link">&para;</a></h3>
<ol>
<li>方式有3种：邻接矩阵，邻接表，链式前向星</li>
<li>一般从有向图开始，因为无向图是双向的实现。</li>
<li>一般使用边的序号从1开始:1,2,3,4....。力扣上点的编号是从0开始，注意审题</li>
</ol>
<h4 id="_86">邻接矩阵<a class="headerlink" href="#_86" title="Permanent link">&para;</a></h4>
<ol>
<li>原理</li>
<li>下图是有向图以及邻接矩阵，如果是无向图则是关于对角线对称的矩阵</li>
<li>如果是带权图，则矩阵对应位置的数字是w权值</li>
<li>如果没有链接，可以设置为0或者正无穷(如果出现权值为0的就需要使用正无穷)</li>
<li>使用场景：数据量较小的时候</li>
</ol>
<p><img alt="" src="" /></p>
<h4 id="_87">邻接表<a class="headerlink" href="#_87" title="Permanent link">&para;</a></h4>
<ol>
<li>原理：</li>
<li>使用List<List\<int[]>>的形式。都是动态列表。<ol>
<li>如果是无权图：则是数组长度为1。如果是有权图，就是也就是每次存入的都是一个小数组，包含节点以及连接的权值，数组长度为2。</li>
</ol>
</li>
<li>使用场景：一般情况完全足够了</li>
<li>无权图(左)以及有权图(右)</li>
</ol>
<h4 id="_88">链式前向星<a class="headerlink" href="#_88" title="Permanent link">&para;</a></h4>
<ol>
<li>为了使用静态数组进行空间的优化，而不是使用动态结构</li>
<li>实在固定数组上实现了邻接表</li>
<li>例子：</li>
<li>假设n=4，m=6,也就是4个点，6条边的有向图</li>
<li>head是一个长度为n+1的一维数组，index代表的是节点号，value是头边号</li>
<li>next数组，长度取决于边的规模。index是边的编号，value是下一条边的编号</li>
<li>to数组，index代表边的编号，value代表去往的点</li>
<li>int cnt =1。用来记录边的编号的变量</li>
<li>如果是带权值的图，则再加一个w数组，index是边的编号，value是权值</li>
</ol>
<p><img alt="image.png" src="../assets/image108.png" /></p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  1</span>
<span class="normal">  2</span>
<span class="normal">  3</span>
<span class="normal">  4</span>
<span class="normal">  5</span>
<span class="normal">  6</span>
<span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-71-1">public class Code01_CreateGraph {
</span><span id="__span-71-2">
</span><span id="__span-71-3">    // 点的最大数量
</span><span id="__span-71-4">    public static int MAXN = 11;
</span><span id="__span-71-5">
</span><span id="__span-71-6">    // 边的最大数量
</span><span id="__span-71-7">    // 只有链式前向星方式建图需要这个数量
</span><span id="__span-71-8">    // 注意如果无向图的最大数量是m条边，数量要准备m*2
</span><span id="__span-71-9">    // 因为一条无向边要加两条有向边
</span><span id="__span-71-10">    public static int MAXM = 21;
</span><span id="__span-71-11">
</span><span id="__span-71-12">    // 邻接矩阵方式建图
</span><span id="__span-71-13">    public static int[][] graph1 = new int[MAXN][MAXN];
</span><span id="__span-71-14">
</span><span id="__span-71-15">    // 邻接表方式建图
</span><span id="__span-71-16">    // public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph2 = new ArrayList&lt;&gt;();
</span><span id="__span-71-17">    public static ArrayList&lt;ArrayList&lt;int[]&gt;&gt; graph2 = new ArrayList&lt;&gt;();
</span><span id="__span-71-18">
</span><span id="__span-71-19">    // 链式前向星方式建图
</span><span id="__span-71-20">    public static int[] head = new int[MAXN];
</span><span id="__span-71-21">
</span><span id="__span-71-22">    public static int[] next = new int[MAXM];
</span><span id="__span-71-23">
</span><span id="__span-71-24">    public static int[] to = new int[MAXM];
</span><span id="__span-71-25">
</span><span id="__span-71-26">    // 如果边有权重，那么需要这个数组
</span><span id="__span-71-27">    public static int[] weight = new int[MAXM];
</span><span id="__span-71-28">
</span><span id="__span-71-29">    public static int cnt;
</span><span id="__span-71-30">
</span><span id="__span-71-31">    public static void build(int n) {
</span><span id="__span-71-32">        // 邻接矩阵清空
</span><span id="__span-71-33">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-71-34">            for (int j = 1; j &lt;= n; j++) {
</span><span id="__span-71-35">                graph1[i][j] = 0;
</span><span id="__span-71-36">            }
</span><span id="__span-71-37">        }
</span><span id="__span-71-38">        // 邻接表清空和准备
</span><span id="__span-71-39">        graph2.clear();
</span><span id="__span-71-40">        // 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用
</span><span id="__span-71-41">        for (int i = 0; i &lt;= n; i++) {
</span><span id="__span-71-42">            graph2.add(new ArrayList&lt;&gt;());
</span><span id="__span-71-43">        }
</span><span id="__span-71-44">        // 链式前向星清空
</span><span id="__span-71-45">        cnt = 1;
</span><span id="__span-71-46">        Arrays.fill(head, 1, n + 1, 0);
</span><span id="__span-71-47">    }
</span><span id="__span-71-48">
</span><span id="__span-71-49">    // 链式前向星加边
</span><span id="__span-71-50">    public static void addEdge(int u, int v, int w) {
</span><span id="__span-71-51">        // u -&gt; v , 边权重是w
</span><span id="__span-71-52">        //变更顺序倒过来，依次是to,next,head
</span><span id="__span-71-53">        to[cnt] = v;
</span><span id="__span-71-54">        next[cnt] = head[u];
</span><span id="__span-71-55">        head[u] = cnt++;
</span><span id="__span-71-56">    }
</span><span id="__span-71-57">
</span><span id="__span-71-58">    // 三种方式建立有向图带权图
</span><span id="__span-71-59">    public static void directGraph(int[][] edges) {
</span><span id="__span-71-60">        // 邻接矩阵建图
</span><span id="__span-71-61">        for (int[] edge : edges) {
</span><span id="__span-71-62">            graph1[edge[0]][edge[1]] = edge[2];
</span><span id="__span-71-63">        }
</span><span id="__span-71-64">        // 邻接表建图
</span><span id="__span-71-65">        for (int[] edge : edges) {
</span><span id="__span-71-66">            // graph2.get(edge[0]).add(edge[1]);
</span><span id="__span-71-67">            graph2.get(edge[0]).add(new int[] { edge[1], edge[2] });
</span><span id="__span-71-68">        }
</span><span id="__span-71-69">        // 链式前向星建图
</span><span id="__span-71-70">        for (int[] edge : edges) {
</span><span id="__span-71-71">            addEdge(edge[0], edge[1], edge[2]);
</span><span id="__span-71-72">        }
</span><span id="__span-71-73">    }
</span><span id="__span-71-74">
</span><span id="__span-71-75">    // 三种方式建立无向图带权图
</span><span id="__span-71-76">    public static void undirectGraph(int[][] edges) {
</span><span id="__span-71-77">        // 邻接矩阵建图
</span><span id="__span-71-78">        for (int[] edge : edges) {
</span><span id="__span-71-79">            graph1[edge[0]][edge[1]] = edge[2];
</span><span id="__span-71-80">            graph1[edge[1]][edge[0]] = edge[2];
</span><span id="__span-71-81">        }
</span><span id="__span-71-82">        // 邻接表建图
</span><span id="__span-71-83">        for (int[] edge : edges) {
</span><span id="__span-71-84">            // graph2.get(edge[0]).add(edge[1]);
</span><span id="__span-71-85">            // graph2.get(edge[1]).add(edge[0]);
</span><span id="__span-71-86">            graph2.get(edge[0]).add(new int[] { edge[1], edge[2] });
</span><span id="__span-71-87">            graph2.get(edge[1]).add(new int[] { edge[0], edge[2] });
</span><span id="__span-71-88">        }
</span><span id="__span-71-89">        // 链式前向星建图
</span><span id="__span-71-90">        for (int[] edge : edges) {
</span><span id="__span-71-91">            addEdge(edge[0], edge[1], edge[2]);
</span><span id="__span-71-92">            addEdge(edge[1], edge[0], edge[2]);
</span><span id="__span-71-93">        }
</span><span id="__span-71-94">    }
</span><span id="__span-71-95">
</span><span id="__span-71-96">    public static void traversal(int n) {
</span><span id="__span-71-97">        System.out.println(&quot;邻接矩阵遍历 :&quot;);
</span><span id="__span-71-98">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-71-99">            for (int j = 1; j &lt;= n; j++) {
</span><span id="__span-71-100">                System.out.print(graph1[i][j] + &quot; &quot;);
</span><span id="__span-71-101">            }
</span><span id="__span-71-102">            System.out.println();
</span><span id="__span-71-103">        }
</span><span id="__span-71-104">        System.out.println(&quot;邻接表遍历 :&quot;);
</span><span id="__span-71-105">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-71-106">            System.out.print(i + &quot;(邻居、边权) : &quot;);
</span><span id="__span-71-107">            for (int[] edge : graph2.get(i)) {
</span><span id="__span-71-108">                System.out.print(&quot;(&quot; + edge[0] + &quot;,&quot; + edge[1] + &quot;) &quot;);
</span><span id="__span-71-109">            }
</span><span id="__span-71-110">            System.out.println();
</span><span id="__span-71-111">        }
</span><span id="__span-71-112">        System.out.println(&quot;链式前向星 :&quot;);
</span><span id="__span-71-113">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-71-114">            System.out.print(i + &quot;(邻居、边权) : &quot;);
</span><span id="__span-71-115">            // 注意这个for循环，链式前向星的方式遍历
</span><span id="__span-71-116">            for (int ei = head[i]; ei &gt; 0; ei = next[ei]) {
</span><span id="__span-71-117">                System.out.print(&quot;(&quot; + to[ei] + &quot;,&quot; + weight[ei] + &quot;) &quot;);
</span><span id="__span-71-118">            }
</span><span id="__span-71-119">            System.out.println();
</span><span id="__span-71-120">        }
</span><span id="__span-71-121">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_89">拓扑排序<a class="headerlink" href="#_89" title="Permanent link">&para;</a></h3>
<ol>
<li>要求：拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点</li>
<li>使用要求：有向无环图(DAG)，无向图不可以，因为无向图天然带环</li>
<li>实际场景：工作流安排，编译的过程</li>
<li>
<p>前置概念：</p>
</li>
<li>
<p>入度：有多少节点指向该节点</p>
</li>
<li>出度：该节点指向多少个节点</li>
<li>过程(入度删除法)：</li>
<li>找到一个入度为0的点(因为入度为0可能不止一个，孤立的点也是入度为0)</li>
<li>消除掉该点对其他节点的影响(入度删除法)</li>
<li>重复a,b步骤</li>
<li>整个步骤会删除所有点，如果删除的个数和总结点个数不同，则出现了环(可以用于判断是否有环)</li>
<li>时间复杂度：O(V+E)</li>
<li>例题leetcode210：</li>
<li>要注意题目所给的边是从0-n-1。</li>
<li>如果使用链式前向星建图，可以将静态数组的初始状态全部设置为-1，防止和0混杂。在遍历的时候需要注意终止条件变为ei&gt;=0即可，而不是&gt;0。</li>
<li>如果要字典序最小的结果，则将维护的队列换成小根堆就可以。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-72-1">#使用邻接表存储
</span><span id="__span-72-2">class Solution {
</span><span id="__span-72-3">    //注意[a,b]和[b.a]的区别
</span><span id="__span-72-4">    public int[] findOrder(int numCourses, int[][] prerequisites) {
</span><span id="__span-72-5">        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
</span><span id="__span-72-6">        int n = numCourses;
</span><span id="__span-72-7">        //点从0开始
</span><span id="__span-72-8">        for(int i=0;i&lt;n;i++){
</span><span id="__span-72-9">            graph.add(new ArrayList&lt;&gt;());
</span><span id="__span-72-10">        }
</span><span id="__span-72-11">        int[] indegree = new int[n];
</span><span id="__span-72-12">        for(int[] edge : prerequisites){
</span><span id="__span-72-13">            graph.get(edge[1]).add(edge[0]);
</span><span id="__span-72-14">            indegree[edge[0]]++;
</span><span id="__span-72-15">        }
</span><span id="__span-72-16">        int[] queue = new int[n];
</span><span id="__span-72-17">        int l = 0, r = 0;
</span><span id="__span-72-18">        for(int i=0; i&lt;n;i++){
</span><span id="__span-72-19">            if(indegree[i] == 0){
</span><span id="__span-72-20">                queue[r++] = i;
</span><span id="__span-72-21">            }
</span><span id="__span-72-22">        }
</span><span id="__span-72-23">        int cnt = 0;
</span><span id="__span-72-24">        while(l&lt;r){
</span><span id="__span-72-25">            int cur = queue[l++];
</span><span id="__span-72-26">            cnt++;
</span><span id="__span-72-27">            for(int next : graph.get(cur)){
</span><span id="__span-72-28">                indegree[next]--;
</span><span id="__span-72-29">                if(indegree[next] == 0){
</span><span id="__span-72-30">                    queue[r++] = next;
</span><span id="__span-72-31">                }
</span><span id="__span-72-32">            }
</span><span id="__span-72-33">        }
</span><span id="__span-72-34">
</span><span id="__span-72-35">        return cnt == n? queue : new int[0];
</span><span id="__span-72-36">    }
</span><span id="__span-72-37">}
</span><span id="__span-72-38">#使用链式前向星存储
</span><span id="__span-72-39">class Solution {
</span><span id="__span-72-40">    public static int MAXN = 2001;
</span><span id="__span-72-41">    public static int[] head = new int[MAXN];
</span><span id="__span-72-42">    public static int[] next = new int[MAXN*2];
</span><span id="__span-72-43">    public static int[] to = new int[MAXN*2];
</span><span id="__span-72-44">    public static int cnt;
</span><span id="__span-72-45">    public int[] findOrder(int numCourses, int[][] prerequisites) {
</span><span id="__span-72-46">        int n = numCourses;
</span><span id="__span-72-47">        int[] queue = new int[n];
</span><span id="__span-72-48">        int[] indegree = new int[n];
</span><span id="__span-72-49">        int l = 0, r = 0;
</span><span id="__span-72-50">        bulid(n);
</span><span id="__span-72-51">        for(int[] edge : prerequisites){
</span><span id="__span-72-52">            addEdge(edge[1], edge[0]);
</span><span id="__span-72-53">            indegree[edge[0]]++;
</span><span id="__span-72-54">        }
</span><span id="__span-72-55">        l = 0;
</span><span id="__span-72-56">        r = 0;
</span><span id="__span-72-57">        for(int i=0; i&lt;n; i++){
</span><span id="__span-72-58">            if(indegree[i] == 0){
</span><span id="__span-72-59">                queue[r++] = i;
</span><span id="__span-72-60">            }
</span><span id="__span-72-61">        }
</span><span id="__span-72-62">        int len = 0;
</span><span id="__span-72-63">        while(l&lt;r){
</span><span id="__span-72-64">            int cur = queue[l++];
</span><span id="__span-72-65">            len++;
</span><span id="__span-72-66">            for(int ei = head[cur]; ei &gt;= 0; ei = next[ei]){
</span><span id="__span-72-67">                indegree[to[ei]]--;
</span><span id="__span-72-68">                if(indegree[to[ei]] == 0){
</span><span id="__span-72-69">                    queue[r++] = to[ei];
</span><span id="__span-72-70">                }
</span><span id="__span-72-71">            }
</span><span id="__span-72-72">        }
</span><span id="__span-72-73">        return len == n? queue : new int[0];
</span><span id="__span-72-74">    }
</span><span id="__span-72-75">    public static void bulid(int n){
</span><span id="__span-72-76">        cnt = 0;
</span><span id="__span-72-77">        Arrays.fill(head, -1);
</span><span id="__span-72-78">        Arrays.fill(next,-1);
</span><span id="__span-72-79">        Arrays.fill(to, -1);
</span><span id="__span-72-80">    }
</span><span id="__span-72-81">    public static void addEdge(int u, int v){
</span><span id="__span-72-82">        to[cnt] = v;
</span><span id="__span-72-83">        next[cnt] = head[u];
</span><span id="__span-72-84">        head[u] = cnt++;
</span><span id="__span-72-85">    }
</span><span id="__span-72-86">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_90">洪水填充<a class="headerlink" href="#_90" title="Permanent link">&para;</a></h3>
<p>原理：类似于洪水蔓延的过程，用于网格搜索。通过设置路径信息，用于统计或者剪枝。看似暴力递归，其实时间复杂度很好。</p>
<ol>
<li>leetcode 200岛屿数量</li>
</ol>
<p>给你一个由 <code>&lt;span class="color_font"&gt;&lt;span&gt;'1'&lt;/span&gt;&lt;/span&gt;</code>（陆地）和 <code>&lt;span class="color_font"&gt;&lt;span&gt;'0'&lt;/span&gt;&lt;/span&gt;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<ol>
<li>思路：使用洪水填充，感染过程就是dfs。从左往右，从上往下，进行检查。发现一个1，就把这一片的位置全部蔓延为2，相当于都遍历了，重复该过程。不用撤销修改信息，因为就是利用修改的副作用。</li>
<li>时间复杂度：O(m*n)，并且是最优解。每个位置最多被访问4次，并且修改的操作只用访问1次，代价是O(1)的。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-73-1">class Solution {
</span><span id="__span-73-2">    public static int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-73-3">    public int numIslands(char[][] grid) {
</span><span id="__span-73-4">        int cnt = 0;
</span><span id="__span-73-5">        int m = grid.length;
</span><span id="__span-73-6">        int n = grid[0].length;
</span><span id="__span-73-7">        for(int i=0; i&lt;m;i++){
</span><span id="__span-73-8">            for(int j=0; j&lt;n;j++){
</span><span id="__span-73-9">                if(grid[i][j] == &#39;1&#39;) cnt++;
</span><span id="__span-73-10">                dfs(grid, i, j);
</span><span id="__span-73-11">            }
</span><span id="__span-73-12">        }  
</span><span id="__span-73-13">        return cnt;  
</span><span id="__span-73-14">    }
</span><span id="__span-73-15">    public static void dfs(char[][] grid, int i, int j){
</span><span id="__span-73-16">        if(i&lt;0 ||i&gt;=grid.length || j&lt;0 || j &gt;= grid[0].length || grid[i][j] != &#39;1&#39;){
</span><span id="__span-73-17">            return;
</span><span id="__span-73-18">        }
</span><span id="__span-73-19">        grid[i][j] = &#39;0&#39;;
</span><span id="__span-73-20">        for(int k=0; k&lt;4;k++){
</span><span id="__span-73-21">            int nx = i + move[k];
</span><span id="__span-73-22">            int ny = j + move[k+1];
</span><span id="__span-73-23">            dfs(grid,nx,ny);
</span><span id="__span-73-24">        }
</span><span id="__span-73-25">    }
</span><span id="__span-73-26">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode  130 被围绕的区域</li>
<li>思路：先寻找边缘的联通区域，提前标记区别开来。然后可以将中间的闭合区域进行修改，最后将边缘区域恢复即可。</li>
<li>时间复杂度O(m*n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-74-1">class Solution {
</span><span id="__span-74-2">    public static int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-74-3">    public void solve(char[][] board) {
</span><span id="__span-74-4">        int m = board.length;
</span><span id="__span-74-5">        int n = board[0].length;
</span><span id="__span-74-6">        for(int i=0; i&lt;m;i++){
</span><span id="__span-74-7">            for(int j=0; j&lt;n;j++){
</span><span id="__span-74-8">                if(i==0 || j == 0 || i==m-1 || j==n-1){
</span><span id="__span-74-9">                    if(board[i][j] == &#39;O&#39;){
</span><span id="__span-74-10">                        dfs(board,i,j,&#39;F&#39;);
</span><span id="__span-74-11">                    }
</span><span id="__span-74-12">                }
</span><span id="__span-74-13">            }
</span><span id="__span-74-14">        }
</span><span id="__span-74-15">        for(int i=0; i&lt;m;i++){
</span><span id="__span-74-16">            for(int j=0; j&lt;n;j++){
</span><span id="__span-74-17">                if(board[i][j] == &#39;O&#39;) board[i][j] = &#39;X&#39;;
</span><span id="__span-74-18">                if(board[i][j] == &#39;F&#39;) board[i][j] = &#39;O&#39;;
</span><span id="__span-74-19">            }
</span><span id="__span-74-20">        }
</span><span id="__span-74-21">    }
</span><span id="__span-74-22">    public static void dfs(char[][] board,int i, int j,char flag) {
</span><span id="__span-74-23">        if (i &lt; 0 || i == board.length|| j &lt; 0 || j == board[0].length || board[i][j] != &#39;O&#39;) {
</span><span id="__span-74-24">            return;
</span><span id="__span-74-25">        }
</span><span id="__span-74-26">        board[i][j] = flag;
</span><span id="__span-74-27">        for(int k=0; k&lt;4;k++){
</span><span id="__span-74-28">            int nx = i + move[k];
</span><span id="__span-74-29">            int ny = j + move[k+1];
</span><span id="__span-74-30">            dfs(board,nx,ny,flag);
</span><span id="__span-74-31">        }
</span><span id="__span-74-32">
</span><span id="__span-74-33">    }
</span><span id="__span-74-34">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 827：最大人工岛</li>
</ol>
<p>给你一个大小为 <code>&lt;span class="color_font"&gt;&lt;span&gt;n x n&lt;/span&gt;&lt;/span&gt;</code> 二进制矩阵 <code>&lt;span class="color_font"&gt;&lt;span&gt;grid&lt;/span&gt;&lt;/span&gt;</code> 。<strong>最多</strong> 只能将一格 <code>&lt;span class="color_font"&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;</code> 变成 <code>&lt;span class="color_font"&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;</code> 。</p>
<p>返回执行此操作后，<code>&lt;span class="color_font"&gt;&lt;span&gt;grid&lt;/span&gt;&lt;/span&gt;</code> 中最大的岛屿面积是多少</p>
<ol>
<li>思路：</li>
<li>通过进行二位遍历，然后进行蔓延。每片位置使用不同id进行填充。</li>
<li>然后对每个0进行枚举，对四个方向进行遍历。如果有区域，就增加相应数量。注意不要重复。</li>
</ol>
<p><img alt="" src="" /></p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-75-1">class Solution {
</span><span id="__span-75-2">    public static int[] move = new int[] { -1, 0, 1, 0, -1 };
</span><span id="__span-75-3">
</span><span id="__span-75-4">    public int largestIsland(int[][] grid) {
</span><span id="__span-75-5">        int m = grid.length;
</span><span id="__span-75-6">        int n = grid[0].length;
</span><span id="__span-75-7">        int id = 2;
</span><span id="__span-75-8">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-75-9">            for (int j = 0; j &lt; n; j++) {
</span><span id="__span-75-10">                if (grid[i][j] == 1) {
</span><span id="__span-75-11">                    dfs(grid, i, j, id++);
</span><span id="__span-75-12">                }
</span><span id="__span-75-13">            }
</span><span id="__span-75-14">        }
</span><span id="__span-75-15">        int[] size = new int[id];
</span><span id="__span-75-16">        int ans = 0;
</span><span id="__span-75-17">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-75-18">            for (int j = 0; j &lt; n; j++) {
</span><span id="__span-75-19">                if (grid[i][j] &gt; 1) {
</span><span id="__span-75-20">                    size[grid[i][j]]++;
</span><span id="__span-75-21">                    ans = Math.max(ans, size[grid[i][j]]);
</span><span id="__span-75-22">                }
</span><span id="__span-75-23">            }
</span><span id="__span-75-24">        }
</span><span id="__span-75-25">        // 讨论所有的0，变成1，能带来的最大岛的大小
</span><span id="__span-75-26">        boolean[] visited = new boolean[id];
</span><span id="__span-75-27">        int up, down, left, right, merge;
</span><span id="__span-75-28">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-75-29">            for (int j = 0; j &lt; m; j++) {
</span><span id="__span-75-30">                if (grid[i][j] == 0) {
</span><span id="__span-75-31">                    up = i &gt; 0 ? grid[i - 1][j] : 0;
</span><span id="__span-75-32">                    down = i + 1 &lt; n ? grid[i + 1][j] : 0;
</span><span id="__span-75-33">                    left = j &gt; 0 ? grid[i][j - 1] : 0;
</span><span id="__span-75-34">                    right = j + 1 &lt; m ? grid[i][j + 1] : 0;
</span><span id="__span-75-35">                    visited[up] = true;
</span><span id="__span-75-36">                    merge = 1 + size[up];
</span><span id="__span-75-37">                    if (!visited[down]) {
</span><span id="__span-75-38">                        merge += size[down];
</span><span id="__span-75-39">                        visited[down] = true;
</span><span id="__span-75-40">                    }
</span><span id="__span-75-41">                    if (!visited[left]) {
</span><span id="__span-75-42">                        merge += size[left];
</span><span id="__span-75-43">                        visited[left] = true;
</span><span id="__span-75-44">                    }
</span><span id="__span-75-45">                    if (!visited[right]) {
</span><span id="__span-75-46">                        merge += size[right];
</span><span id="__span-75-47">                        visited[right] = true;
</span><span id="__span-75-48">                    }
</span><span id="__span-75-49">                    ans = Math.max(ans, merge);
</span><span id="__span-75-50">                    visited[up] = false;
</span><span id="__span-75-51">                    visited[down] = false;
</span><span id="__span-75-52">                    visited[left] = false;
</span><span id="__span-75-53">                    visited[right] = false;
</span><span id="__span-75-54">                }
</span><span id="__span-75-55">            }
</span><span id="__span-75-56">        }
</span><span id="__span-75-57">        return ans;
</span><span id="__span-75-58">    }
</span><span id="__span-75-59">    public static void dfs(int[][] grid, int i, int j, int id) {
</span><span id="__span-75-60">        if (i &lt; 0 || i &gt;= grid.length || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] != 1) {
</span><span id="__span-75-61">            return;
</span><span id="__span-75-62">        }
</span><span id="__span-75-63">        grid[i][j] = id;
</span><span id="__span-75-64">        dfs(grid, i - 1, j, id);
</span><span id="__span-75-65">        dfs(grid, i + 1, j, id);
</span><span id="__span-75-66">        dfs(grid, i, j - 1, id);
</span><span id="__span-75-67">        dfs(grid, i, j + 1, id);
</span><span id="__span-75-68">    }
</span><span id="__span-75-69">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_91">最小生成树<a class="headerlink" href="#_91" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>定义：</p>
</li>
<li>
<p>生成树：一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择n-1条边，将所有顶点联通。</p>
</li>
<li>最小生成树：边权最小的生成树</li>
<li>Kruskal算法</li>
<li>最常用</li>
<li>不需要建图。使用并查集即可</li>
<li>思路：</li>
<li>把所有的边按权值从小到大排序</li>
<li>如果当前的边不会形成环(此处使用并查集进行判断)，就选择当前的边。否则就不要这条边</li>
<li>考察完所有的边之后，就得到结果</li>
<li>使用并查集进行判断：a----b,如果b已经和a在同一个结合中，此时要抛弃这条边，否则会成环。</li>
<li>是基于贪心算法来使用的</li>
<li>模板题：leetcode1584</li>
</ol>
<p>给你一个<code>&lt;span class="color_font"&gt;&lt;span&gt;points&lt;/span&gt;&lt;/span&gt;</code> 数组，表示 2D 平面上的一些点，其中 <code>&lt;span class="color_font"&gt;&lt;span&gt;points[i] = [x&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;, y&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;</code> 。</p>
<p>连接点 <code>&lt;span class="color_font"&gt;&lt;span&gt;[x&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;, y&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;</code> 和点 <code>&lt;span class="color_font"&gt;&lt;span&gt;[x&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;, y&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>&lt;span class="color_font"&gt;&lt;span&gt;|x&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt; - x&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;| + |y&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt; - y&lt;/span&gt;&lt;/span&gt;``&lt;sub&gt;&lt;span class="color_font"&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/sub&gt;``&lt;span class="color_font"&gt;&lt;span&gt;|&lt;/span&gt;&lt;/span&gt;</code> ，其中 <code>&lt;span class="color_font"&gt;&lt;span&gt;|val|&lt;/span&gt;&lt;/span&gt;</code> 表示 <code>&lt;span class="color_font"&gt;&lt;span&gt;val&lt;/span&gt;&lt;/span&gt;</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-76-1">class Solution {
</span><span id="__span-76-2">    public static int MAXN = 1001;
</span><span id="__span-76-3">    public static int[] father = new int[MAXN];
</span><span id="__span-76-4">    public static int[] size = new int[MAXN];
</span><span id="__span-76-5">    public static int[] stk = new int[MAXN];
</span><span id="__span-76-6">    public static int r;
</span><span id="__span-76-7">    public int minCostConnectPoints(int[][] points) {
</span><span id="__span-76-8">        //点从0开始
</span><span id="__span-76-9">        int n = points.length;
</span><span id="__span-76-10">        build(n);
</span><span id="__span-76-11">        List&lt;int[]&gt; edges = new ArrayList&lt;&gt;();
</span><span id="__span-76-12">        //创建边集并排序
</span><span id="__span-76-13">        for(int i=0 ;i&lt;n;i++){
</span><span id="__span-76-14">            for(int j=i+1; j&lt;n; j++){
</span><span id="__span-76-15">                edges.add(new int[]{i, j,dist(points,i,j)});
</span><span id="__span-76-16">            }
</span><span id="__span-76-17">        }
</span><span id="__span-76-18">        Collections.sort(edges,(a,b)-&gt;a[2]-b[2]);
</span><span id="__span-76-19">        //k算法
</span><span id="__span-76-20">        int ans = 0;
</span><span id="__span-76-21">        int cnt = 0;
</span><span id="__span-76-22">        for(int[] edge : edges){
</span><span id="__span-76-23">            if(union(edge[0], edge[1])){
</span><span id="__span-76-24">                cnt++;
</span><span id="__span-76-25">                ans += edge[2];
</span><span id="__span-76-26">            }
</span><span id="__span-76-27">        }
</span><span id="__span-76-28">        return ans;
</span><span id="__span-76-29">
</span><span id="__span-76-30">    }
</span><span id="__span-76-31">    public static int dist(int[][] points, int x, int y){
</span><span id="__span-76-32">        return Math.abs(points[x][0]-points[y][0]) + Math.abs(points[x][1]-points[y][1]);
</span><span id="__span-76-33">    }
</span><span id="__span-76-34">    public static void build(int n){
</span><span id="__span-76-35">        for(int i=0; i&lt;n; i++){
</span><span id="__span-76-36">            father[i] = i;
</span><span id="__span-76-37">            size[i] = 1;
</span><span id="__span-76-38">        }
</span><span id="__span-76-39">    }
</span><span id="__span-76-40">    public static int find(int x){
</span><span id="__span-76-41">        r = 0;
</span><span id="__span-76-42">        while(x != father[x]){
</span><span id="__span-76-43">            stk[r++] = x;
</span><span id="__span-76-44">            x = father[x];
</span><span id="__span-76-45">        }
</span><span id="__span-76-46">        while(r&gt;0){
</span><span id="__span-76-47">            father[stk[--r]] = x;
</span><span id="__span-76-48">        }
</span><span id="__span-76-49">        return x;
</span><span id="__span-76-50">    }
</span><span id="__span-76-51">    //true代表需要合并
</span><span id="__span-76-52">    public static boolean union(int x, int y) {
</span><span id="__span-76-53">        int fx = find(x);
</span><span id="__span-76-54">        int fy = find(y);
</span><span id="__span-76-55">        if (fx != fy) {
</span><span id="__span-76-56">            if (size[fx] &gt;= size[fy]) {
</span><span id="__span-76-57">                size[fx] += size[fy];
</span><span id="__span-76-58">                father[fy] = fx;
</span><span id="__span-76-59">            } else {
</span><span id="__span-76-60">                size[fy] += size[fx];
</span><span id="__span-76-61">                father[fx] = fy;
</span><span id="__span-76-62">            }
</span><span id="__span-76-63">            return true;
</span><span id="__span-76-64">        }else{
</span><span id="__span-76-65">            return false;
</span><span id="__span-76-66">        }
</span><span id="__span-76-67">    }
</span><span id="__span-76-68">}
</span></code></pre></div></td></tr></table></div>
<h3 id="bfs">BFS及其扩展<a class="headerlink" href="#bfs" title="Permanent link">&para;</a></h3>
<ol>
<li>理论：</li>
<li>定义：<ol>
<li>是图上最基础、最重要的搜索算法之一。</li>
<li>所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。</li>
<li>这样做的结果是，BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。</li>
<li>在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。</li>
<li>算法过程可以看做是图上火苗传播的过程：最开始只有起点着火了，在每一时刻，有火的节点都向它相邻的所有节点传播火苗。</li>
<li>可以单源进行BFS，也有多源BFS</li>
</ol>
</li>
<li>例子：</li>
<li>每次外扩一层，都是源点距离本层的点距离+1。本层的点到源点的距离都相同。此处的距离都是曼哈顿距离。</li>
<li>需要有状态来记录节点是否被访问过。</li>
<li>处理方式：</li>
<li>单点处理方式：通过使用队列来存储每一层的(Node，distance)。上一层的一个节点出去，则如队对应的下一层节点。</li>
<li>一次处理一层：使用hashMap来记录每个节点对应的level值。</li>
</ol>
<p><img alt="image.png" src="../assets/bfs.png" /></p>
<ol>
<li>例题：</li>
<li>模板题：多源BFS。结束之后的level就是最远的层数(距离)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-77-1">class Solution {
</span><span id="__span-77-2">    public static int MAXN = 101;
</span><span id="__span-77-3">    public static int MAXM = 101;
</span><span id="__span-77-4">    public static int[][] queue = new int[MAXN * MAXM][2];
</span><span id="__span-77-5">    public static int l, r;
</span><span id="__span-77-6">    public static boolean[][] visited = new boolean[MAXN][MAXM];
</span><span id="__span-77-7">    public static int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-77-8">    public int maxDistance(int[][] grid) {
</span><span id="__span-77-9">        int n = grid.length;
</span><span id="__span-77-10">        int m = grid[0].length;
</span><span id="__span-77-11">        l = 0;
</span><span id="__span-77-12">        r = 0;
</span><span id="__span-77-13">        int seas = 0;
</span><span id="__span-77-14">        for(int i=0; i&lt;n; i++){
</span><span id="__span-77-15">            for(int j=0; j&lt;m; j++){
</span><span id="__span-77-16">                if(grid[i][j] == 1){
</span><span id="__span-77-17">                    visited[i][j] = true;
</span><span id="__span-77-18">                    queue[r][0] = i;
</span><span id="__span-77-19">                    queue[r][1] = j;
</span><span id="__span-77-20">                    r++;
</span><span id="__span-77-21">                }else{
</span><span id="__span-77-22">                    visited[i][j] = false;
</span><span id="__span-77-23">                    seas++;
</span><span id="__span-77-24">                }
</span><span id="__span-77-25">            }
</span><span id="__span-77-26">        }
</span><span id="__span-77-27">        if(seas == 0 || seas == n*m){
</span><span id="__span-77-28">            return -1;
</span><span id="__span-77-29">        }
</span><span id="__span-77-30">
</span><span id="__span-77-31">        int level = 0;
</span><span id="__span-77-32">        while(l&lt;r){
</span><span id="__span-77-33">            level++;
</span><span id="__span-77-34">            int size = r-l;
</span><span id="__span-77-35">            for(int i=0; i&lt;size; i++){
</span><span id="__span-77-36">                int x = queue[l][0];
</span><span id="__span-77-37">                int y = queue[l][1];
</span><span id="__span-77-38">                l++;
</span><span id="__span-77-39">                for(int j=0; j&lt;4 ;j++){
</span><span id="__span-77-40">                    int nx = x + move[j];
</span><span id="__span-77-41">                    int ny = y + move[j+1];
</span><span id="__span-77-42">                    if(nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny]==0 &amp;&amp;!visited[nx][ny]){
</span><span id="__span-77-43">                        visited[nx][ny] = true;
</span><span id="__span-77-44">                        queue[r][0] = nx;
</span><span id="__span-77-45">                        queue[r][1] = ny;
</span><span id="__span-77-46">                        r++;
</span><span id="__span-77-47">                    }
</span><span id="__span-77-48">                }
</span><span id="__span-77-49">            }
</span><span id="__span-77-50">        }
</span><span id="__span-77-51">        return level-1;
</span><span id="__span-77-52">    }
</span><span id="__span-77-53">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode200</li>
<li>每个节点进行处理的模板题：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-78-1">class Solution {
</span><span id="__span-78-2">    public static int MAXN = 100000;
</span><span id="__span-78-3">    public static int MAXM = 301;
</span><span id="__span-78-4">    public static int[][] queue = new int[MAXN][MAXM];
</span><span id="__span-78-5">    public static int l, r;
</span><span id="__span-78-6">    public static boolean[][] visited = new boolean[MAXN][MAXM];
</span><span id="__span-78-7">    public static int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-78-8">
</span><span id="__span-78-9">    public int numIslands(char[][] grid) {
</span><span id="__span-78-10">        for(int i=0 ;i&lt;visited.length; i++){
</span><span id="__span-78-11">            Arrays.fill(visited[i], false);
</span><span id="__span-78-12">        }
</span><span id="__span-78-13">        int n = grid.length;
</span><span id="__span-78-14">        int m = grid[0].length;
</span><span id="__span-78-15">        l = 0;
</span><span id="__span-78-16">        r = 0;
</span><span id="__span-78-17">        int num = 0;
</span><span id="__span-78-18">        for(int i=0; i&lt;n; i++){
</span><span id="__span-78-19">            for(int j=0;j&lt;m;j++){
</span><span id="__span-78-20">                if(!visited[i][j] &amp;&amp; grid[i][j] == &#39;1&#39;){
</span><span id="__span-78-21">                    num++;
</span><span id="__span-78-22">                    visited[i][j] = true;
</span><span id="__span-78-23">                    queue[r][0] = i;
</span><span id="__span-78-24">                    queue[r++][1] = j;
</span><span id="__span-78-25">
</span><span id="__span-78-26">                    while(l&lt;r){
</span><span id="__span-78-27">                        int x = queue[l][0];
</span><span id="__span-78-28">                        int y = queue[l][1];
</span><span id="__span-78-29">                        l++;
</span><span id="__span-78-30">                        for(int e=0; e&lt;4;e++){
</span><span id="__span-78-31">                            int nx = x + move[e];
</span><span id="__span-78-32">                            int ny = y + move[e+1];
</span><span id="__span-78-33">                            if(nx&gt;=0 &amp;&amp; nx&lt;n &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;m &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] == &#39;1&#39;){
</span><span id="__span-78-34">                                visited[nx][ny] = true;
</span><span id="__span-78-35">                                queue[r][0] = nx;
</span><span id="__span-78-36">                                queue[r][1] = ny;
</span><span id="__span-78-37">                                r++;
</span><span id="__span-78-38">
</span><span id="__span-78-39">                            }
</span><span id="__span-78-40">                        }
</span><span id="__span-78-41">                    }
</span><span id="__span-78-42">
</span><span id="__span-78-43">                }
</span><span id="__span-78-44">            }
</span><span id="__span-78-45">        }
</span><span id="__span-78-46">        return num;
</span><span id="__span-78-47">    }
</span><span id="__span-78-48">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>01BFS，也就是双端队列BFS</li>
<li>适用范围：边的权重只有0和1，求解最短距离</li>
<li>不能使用传统BFS，因为进行传统的BFS之后，进行下一层扩展之后，需要距离增加，而不是两个节点还是在同一层。</li>
<li>时间复杂度O(节点数 + 边数)</li>
<li>过程：<ol>
<li>diatance[i]代表从源点到i点的最短距离。初始的时候所有点的diatance设置为无穷大。</li>
<li>源点进入双端队列，distance[源点] = 0</li>
<li>双端队列头部弹出x<ol>
<li>如果x是目标点，返回distance[x]</li>
<li>考察从x出发的每一条边，假设x-&gt;y,权重为w<ol>
<li>如果distance[y] &gt; diatance[x] + w,处理该边</li>
<li>处理的时候，更新distance[y] =distance[x] +w</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>如果w==0,y从头部进入双端队列，重复步骤III</p>
<p>如果w==1,y从尾部进入双端队列，重复步骤III</p>
<ol>
<li>直到队列为空</li>
<li>
<p>性质：</p>
</li>
<li>
<p>在双端队列中同时存在的节点到源点的距离之差&lt;=1。</p>
</li>
<li>其实w==0从头进入是进行的一次修正，将距离边的不变或者更小。</li>
<li>模板题：leetcode2290</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-79-1">class Solution {
</span><span id="__span-79-2">    public int minimumObstacles(int[][] grid) {
</span><span id="__span-79-3">        int m = grid.length;
</span><span id="__span-79-4">        int n = grid[0].length;
</span><span id="__span-79-5">
</span><span id="__span-79-6">        int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-79-7">        Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();
</span><span id="__span-79-8">        int[][] distance = new int[m][n];
</span><span id="__span-79-9">        for(int i=0 ;i&lt;m;i++){
</span><span id="__span-79-10">            Arrays.fill(distance[i],Integer.MAX_VALUE);
</span><span id="__span-79-11">        }
</span><span id="__span-79-12">
</span><span id="__span-79-13">        deque.offerFirst(new int[]{0,0});
</span><span id="__span-79-14">        distance[0][0] = 0;
</span><span id="__span-79-15">        while(!deque.isEmpty()){
</span><span id="__span-79-16">            int[] cur = deque.pollFirst();
</span><span id="__span-79-17">            int x = cur[0];
</span><span id="__span-79-18">            int y = cur[1];
</span><span id="__span-79-19">            if(x == m-1 &amp;&amp; y == n-1) return distance[x][y];
</span><span id="__span-79-20">            for(int i=0 ;i&lt;4 ;i++){
</span><span id="__span-79-21">                int nx = x + move[i];
</span><span id="__span-79-22">                int ny = y + move[i+1];
</span><span id="__span-79-23">                boolean bound = (nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n);
</span><span id="__span-79-24">                if(bound &amp;&amp; distance[nx][ny] &gt; distance[x][y] + grid[nx][ny]){
</span><span id="__span-79-25">                    int w = grid[nx][ny];
</span><span id="__span-79-26">                    distance[nx][ny] = distance[x][y]+w;
</span><span id="__span-79-27">                    if(w == 0){
</span><span id="__span-79-28">                        deque.offerFirst(new int[]{nx,ny});
</span><span id="__span-79-29">                    }else{
</span><span id="__span-79-30">                        deque.offerLast(new int[]{nx,ny});
</span><span id="__span-79-31">                    }
</span><span id="__span-79-32">                }
</span><span id="__span-79-33">            }
</span><span id="__span-79-34">        }
</span><span id="__span-79-35">        return -1;   
</span><span id="__span-79-36">    }
</span><span id="__span-79-37">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>变形题：leetcode1368</li>
</ol>
<p>因为每一个格子都有方向，并且可以用cost 1改方向.则假设该点原本指向的cost=0,其余三个方向都是cost=1。要求cost之和最小，就是计算最短路。所以转换为0-1BFS</p>
<h3 id="dijkstra">DijkStra算法<a class="headerlink" href="#dijkstra" title="Permanent link">&para;</a></h3>
<ol>
<li>作用：计算图中的单源最短路</li>
<li>使用范围：有向图，无负权值</li>
<li>实现种类：暴力，普通堆优化(最常用)，反向堆索引优化</li>
<li>算法过程：</li>
</ol>
<p><img alt="image.png" src="../assets/image107.png" /></p>
<ol>
<li>时间复杂度：O(m*logm),m为边数。</li>
<li>模板题：leetcode743</li>
<li>使用链式前向星建图 + 堆优化</li>
<li>注意使用链式前向星建图调用函数build</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-80-1">class Solution {
</span><span id="__span-80-2">    public static int MAXN = 102;
</span><span id="__span-80-3">    public static int MAXM = 6002;
</span><span id="__span-80-4">    public static int[] head = new int[MAXN];
</span><span id="__span-80-5">    public static int[] next = new int[MAXM];
</span><span id="__span-80-6">    public static int[] to = new int[MAXM];
</span><span id="__span-80-7">    public static int[] w = new int[MAXM];
</span><span id="__span-80-8">    public static int cnt;
</span><span id="__span-80-9">    public int networkDelayTime(int[][] times, int n, int k) {
</span><span id="__span-80-10">        //本题下标从1开始 
</span><span id="__span-80-11">        build(n);
</span><span id="__span-80-12">        for(int[] edge : times){
</span><span id="__span-80-13">            addEdge(edge[0], edge[1], edge[2]);
</span><span id="__span-80-14">        }
</span><span id="__span-80-15">        int[] distance = new int[n+1];
</span><span id="__span-80-16">        Arrays.fill(distance,Integer.MAX_VALUE);
</span><span id="__span-80-17">        distance[k] = 0;
</span><span id="__span-80-18">        boolean[] visited = new boolean[n+1];
</span><span id="__span-80-19">        Arrays.fill(visited,false);
</span><span id="__span-80-20">        PriorityQueue&lt;int[]&gt; heap = new PriorityQueue&lt;&gt;((a,b)-&gt;a[1]-b[1]);
</span><span id="__span-80-21">        heap.add(new int[]{k,0});
</span><span id="__span-80-22">        while(!heap.isEmpty()){
</span><span id="__span-80-23">            int[] cur = heap.poll();
</span><span id="__span-80-24">            int u = cur[0];
</span><span id="__span-80-25">            System.out.println(&quot;u:&quot;+ u);
</span><span id="__span-80-26">            if(visited[u]){
</span><span id="__span-80-27">                continue;
</span><span id="__span-80-28">            }
</span><span id="__span-80-29">            visited[u] = true;
</span><span id="__span-80-30">            for(int ei = head[u]; ei&gt;0; ei = next[ei]){
</span><span id="__span-80-31">                int y = to[ei];
</span><span id="__span-80-32">                int weight = w[ei];
</span><span id="__span-80-33">                System.out.println(&quot;y:&quot; + y + &quot; &quot; + &quot;w:&quot; + weight);
</span><span id="__span-80-34">                if(!visited[y] &amp;&amp; distance[u] + weight &lt; distance[y]){
</span><span id="__span-80-35">                    distance[y] = distance[u] + weight;
</span><span id="__span-80-36">                    //System.out.println(&quot;distance:&quot; + distance[y]);
</span><span id="__span-80-37">                    heap.add(new int[]{y,distance[y]});
</span><span id="__span-80-38">                }
</span><span id="__span-80-39">            }
</span><span id="__span-80-40">        }
</span><span id="__span-80-41">        int ans = Integer.MIN_VALUE;
</span><span id="__span-80-42">        for(int i=1; i&lt;=n; i++){
</span><span id="__span-80-43">            if(distance[i] == Integer.MAX_VALUE){
</span><span id="__span-80-44">                return -1;
</span><span id="__span-80-45">            }
</span><span id="__span-80-46">            ans = Math.max(ans,distance[i]);
</span><span id="__span-80-47">        }
</span><span id="__span-80-48">        return ans;  
</span><span id="__span-80-49">    }
</span><span id="__span-80-50">    public static void build(int n){
</span><span id="__span-80-51">        cnt = 1;
</span><span id="__span-80-52">        Arrays.fill(head,0);
</span><span id="__span-80-53">        Arrays.fill(next,0);
</span><span id="__span-80-54">        Arrays.fill(to,0);
</span><span id="__span-80-55">    }
</span><span id="__span-80-56">    public static void addEdge(int u, int v, int weight){
</span><span id="__span-80-57">        w[cnt] = weight;
</span><span id="__span-80-58">        to[cnt] = v;
</span><span id="__span-80-59">        next[cnt] = head[u];
</span><span id="__span-80-60">        head[u] = cnt++;
</span><span id="__span-80-61">    }
</span><span id="__span-80-62">}
</span></code></pre></div></td></tr></table></div>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-81-1">//scala模板
</span><span id="__span-81-2">object Solution {
</span><span id="__span-81-3">  def findSafeWalk(grid: List[List[Int]], health: Int): Boolean = {
</span><span id="__span-81-4">    val move = Array(-1,0,1,0,-1)
</span><span id="__span-81-5">    val m = grid.length
</span><span id="__span-81-6">    val n = grid(0).length
</span><span id="__span-81-7">    val dis = Array.fill[Int](m, n)(Int.MaxValue)
</span><span id="__span-81-8">    val vis = Array.fill[Boolean](m, n)(false)
</span><span id="__span-81-9">    import scala.collection.mutable
</span><span id="__span-81-10">    implicit val myOrd: Ordering[(Int, Int, Int)] = Ordering.by((x: (Int, Int, Int)) =&gt; x._3)(Ordering[Int].reverse)
</span><span id="__span-81-11">    val heap = mutable.PriorityQueue[(Int,Int,Int)]()
</span><span id="__span-81-12">
</span><span id="__span-81-13">    dis(0)(0) = grid(0)(0)
</span><span id="__span-81-14">    heap.enqueue((0,0,0))
</span><span id="__span-81-15">    while(heap.nonEmpty){
</span><span id="__span-81-16">      val (x,y,d) = heap.dequeue()
</span><span id="__span-81-17">      if(!vis(x)(y)){
</span><span id="__span-81-18">        vis(x)(y) = true
</span><span id="__span-81-19">        for(k &lt;- 0 until 4){
</span><span id="__span-81-20">          val nx = x + move(k)
</span><span id="__span-81-21">          val ny = y + move(k+1)
</span><span id="__span-81-22">          if(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; !vis(nx)(ny) &amp;&amp; dis(x)(y) + grid(nx)(ny) &lt;= dis(nx)(ny)){
</span><span id="__span-81-23">            dis(nx)(ny) = dis(x)(y) + grid(nx)(ny)
</span><span id="__span-81-24">            heap.enqueue((nx,ny,dis(nx)(ny)))
</span><span id="__span-81-25">          }
</span><span id="__span-81-26">        }
</span><span id="__span-81-27">      }
</span><span id="__span-81-28">    }
</span><span id="__span-81-29">    dis(m-1)(n-1) &lt; health
</span><span id="__span-81-30">  }
</span><span id="__span-81-31">}
</span></code></pre></div></td></tr></table></div>
<h3 id="a">A*算法<a class="headerlink" href="#a" title="Permanent link">&para;</a></h3>
<ol>
<li>不同点：</li>
</ol>
<p>DijkStra是解决一个源点到所有目标点的最短距离</p>
<p>A*算法解决的是从一个源点到一个目标点之间的距离</p>
<ol>
<li>特点：</li>
<li>在堆中存放的数据，不再只是(y,distance(y))。</li>
<li>对于BFS，就是每次扩充一层。这样的话最后会访问大量的无用节点</li>
<li>对于DijkStra，每次也都是扩充一层(与BFS一致)，还引入了堆，优点就是可以解决所有节点。</li>
<li>它属于图遍历（英文：Graph traversal）和最佳优先搜索算法（英文：Best-first search），亦是 BFS 的改进</li>
</ol>
<h3 id="floyd">Floyd算法<a class="headerlink" href="#floyd" title="Permanent link">&para;</a></h3>
<ol>
<li>全能算法，只要没有负环的最短路(保证最短路存在)都可以求。所求的结果是每两点之间的最短距离</li>
<li>复杂度：</li>
<li>时间复杂度是O(n^3)。所以使用的时候要先估计数据量，如果时间复杂度大于10^9就会超时。</li>
<li>空间复杂度是O(n^2)。</li>
<li>代码模板：</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-82-1">public class Code02_Floyd {
</span><span id="__span-82-2">
</span><span id="__span-82-3">    public static int MAXN = 101;
</span><span id="__span-82-4">    public static int[][] distance = new int[MAXN][MAXN];
</span><span id="__span-82-5">
</span><span id="__span-82-6">    public static int n, m, ans;
</span><span id="__span-82-7">
</span><span id="__span-82-8">    // 初始时设置任意两点之间的最短距离为无穷大，表示任何路不存在
</span><span id="__span-82-9">    public static void build() {
</span><span id="__span-82-10">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-82-11">            for (int j = 0; j &lt; n; j++) {
</span><span id="__span-82-12">                distance[i][j] = Integer.MAX_VALUE;
</span><span id="__span-82-13">            }
</span><span id="__span-82-14">        }
</span><span id="__span-82-15">    }
</span><span id="__span-82-16">    public static void floyd() {
</span><span id="__span-82-17">        // O(N^3)的过程
</span><span id="__span-82-18">        // 枚举每个跳板
</span><span id="__span-82-19">        // 注意，跳板要最先枚举！跳板要最先枚举！跳板要最先枚举！
</span><span id="__span-82-20">        for (int bridge = 0; bridge &lt; n; bridge++) { // 跳板
</span><span id="__span-82-21">            for (int i = 0; i &lt; n; i++) {
</span><span id="__span-82-22">                for (int j = 0; j &lt; n; j++) {
</span><span id="__span-82-23">                    // i -&gt; .....bridge .... -&gt; j
</span><span id="__span-82-24">                    // distance[i][j]能不能缩短
</span><span id="__span-82-25">                    // distance[i][j] = min ( distance[i][j] , distance[i][bridge] + distance[bridge][j])
</span><span id="__span-82-26">                    //如果跳板能到达，则可以进行更新
</span><span id="__span-82-27">                    boolean check = distance[i][bridge] != Integer.MAX_VALUE &amp;&amp; distance[bridge][j] != Integer.MAX_VALUE;
</span><span id="__span-82-28">                    if(check) distance[i][j] = Math.min(distance[i][j], distance[i][bridge] + distance[bridge][j]);
</span><span id="__span-82-29">                }
</span><span id="__span-82-30">            }
</span><span id="__span-82-31">        }
</span><span id="__span-82-32">    }
</span><span id="__span-82-33">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_92">动态规划<a class="headerlink" href="#_92" title="Permanent link">&para;</a></h2>
<h3 id="_93">一维动态规划<a class="headerlink" href="#_93" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p>算法类型：</p>
</li>
<li>
<p>知道怎么计算的算法，比如图论中的DijkStra算法</p>
</li>
<li>知道怎么尝试的算法，比如递归</li>
<li>递归与动态规划：</li>
<li>有些递归在调用的时候，总是重复调用同一个问题的解，则转换为动态规划很有收益。</li>
<li>如果每次展开都是不同的解，就没有必要变为动态规划。</li>
<li>任何动态规划问题一定对应着有重复调用动作的的递归。</li>
<li>但是递归不一定可以改为动态规划，因为递归中可能改变子问题的环境，从而不可以使用动态规划</li>
<li>斐波那契数列：</li>
<li><strong>斐波那契数</strong> （通常用 <code>&lt;span&gt;F(n)&lt;/span&gt;</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>&lt;span&gt;0&lt;/span&gt;</code> 和 <code>&lt;span&gt;1&lt;/span&gt;</code> 开始，后面的每一项数字都是前面两项数字的和。给定n，请计算F(n)</li>
<li>暴力递归：</li>
<li>时间复杂度：O(2^n)。因为暴力递归成一个二叉树，这颗二叉树一共有n层。</li>
<li>可以改进的点：递归中有重复的子过程被多次计算，比如F(5)。可以通过缓存将其保存下来。则时间复杂度就变为了O(n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-83-1">class Solution {
</span><span id="__span-83-2">    public int fib(int n) {
</span><span id="__span-83-3">        if(n == 0 || n == 1){
</span><span id="__span-83-4">            return n;
</span><span id="__span-83-5">        }
</span><span id="__span-83-6">        return fib(n-1) + fib(n-2);
</span><span id="__span-83-7">    }
</span><span id="__span-83-8">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>记忆化搜索解法：</li>
<li>求F(n)，则准备0-n项的缓存表就可以，长度为n+1.</li>
<li>每次计算的结果存入缓存表中。</li>
<li>时间复杂度：O(n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-84-1">class Solution {
</span><span id="__span-84-2">
</span><span id="__span-84-3">    public int fib(int n) {
</span><span id="__span-84-4">        int[] dp = new int[n+1];
</span><span id="__span-84-5">        Arrays.fill(dp,-1);
</span><span id="__span-84-6">        return f2(n,dp);
</span><span id="__span-84-7">    }
</span><span id="__span-84-8">    public int f2(int n, int[] dp){
</span><span id="__span-84-9">        if(n == 0 || n == 1){
</span><span id="__span-84-10">            return n;
</span><span id="__span-84-11">        }
</span><span id="__span-84-12">        if(dp[n] != -1){
</span><span id="__span-84-13">            return dp[n];
</span><span id="__span-84-14">        }
</span><span id="__span-84-15">        int ans = fib(n-1) + fib(n-2);
</span><span id="__span-84-16">        dp[n] = ans;
</span><span id="__span-84-17">        return ans;
</span><span id="__span-84-18">    }
</span><span id="__span-84-19">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>动态规划：</li>
<li>从顶到底，是递归</li>
<li>从底到顶，变为动态规划</li>
<li>时间复杂度为O(n)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-85-1">class Solution {
</span><span id="__span-85-2">    public int fib(int n) {
</span><span id="__span-85-3">        if(n == 0 || n == 1){
</span><span id="__span-85-4">            return n;
</span><span id="__span-85-5">        }
</span><span id="__span-85-6">        int[] dp = new int[n+1];
</span><span id="__span-85-7">        dp[0] = 0;
</span><span id="__span-85-8">        dp[1] = 1;
</span><span id="__span-85-9">        for(int i=2; i&lt;=n ;i++){
</span><span id="__span-85-10">            dp[i] = dp[i-1] + dp[i-2];
</span><span id="__span-85-11">        }
</span><span id="__span-85-12">        return dp[n];
</span><span id="__span-85-13">    }
</span><span id="__span-85-14">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode983最低票价</li>
</ol>
<p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 <code>&lt;span class="color_font"&gt;&lt;span&gt;days&lt;/span&gt;&lt;/span&gt;</code> 的数组给出。每一项是一个从 <code>&lt;span class="color_font"&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;</code> 到 <code>&lt;span class="color_font"&gt;&lt;span&gt;365&lt;/span&gt;&lt;/span&gt;</code> 的整数。</p>
<p>火车票有 <strong>三种不同的销售方式</strong> ：</p>
<ul>
<li>一张 <strong>为期一天</strong> 的通行证售价为 <code>&lt;span class="color_font"&gt;&lt;span&gt;costs[0]&lt;/span&gt;&lt;/span&gt;</code> 美元；</li>
<li>一张 <strong>为期七天</strong> 的通行证售价为 <code>&lt;span class="color_font"&gt;&lt;span&gt;costs[1]&lt;/span&gt;&lt;/span&gt;</code> 美元；</li>
<li>一张 <strong>为期三十天</strong> 的通行证售价为 <code>&lt;span class="color_font"&gt;&lt;span&gt;costs[2]&lt;/span&gt;&lt;/span&gt;</code> 美元。</li>
</ul>
<p>通行证允许数天无限制的旅行。 例如，如果我们在第 <code>&lt;span class="color_font"&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;</code> 天获得一张 <strong>为期 7 天</strong> 的通行证，那么我们可以连着旅行 7 天：第 <code>&lt;span class="color_font"&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;</code> 天、第 <code>&lt;span class="color_font"&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;</code> 天、第 <code>&lt;span class="color_font"&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;</code> 天、第 <code>&lt;span class="color_font"&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;</code> 天、第 <code>&lt;span class="color_font"&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;</code> 天、第 <code>&lt;span class="color_font"&gt;&lt;span&gt;7&lt;/span&gt;&lt;/span&gt;</code> 天和第 <code>&lt;span class="color_font"&gt;&lt;span&gt;8&lt;/span&gt;&lt;/span&gt;</code> 天。</p>
<p>返回 <em>你想要完成在给定的列表 </em><code>&lt;span class="color_font"&gt;&lt;i&gt;&lt;span&gt;days&lt;/span&gt;&lt;/i&gt;&lt;/span&gt;</code><em> 中列出的每一天的旅行所需要的最低消费 </em>。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-86-1">//暴力递归，会超时。递归思路：总最小花费 = min(当前消费+后续的最小消费)
</span><span id="__span-86-2">class Solution {
</span><span id="__span-86-3">    public static int[] duration = new int[]{1,7,30};
</span><span id="__span-86-4">    public int mincostTickets(int[] days, int[] costs) {
</span><span id="__span-86-5">        return f1(days,costs,0);
</span><span id="__span-86-6">    }
</span><span id="__span-86-7">    public int f1(int[] days, int[] costs, int i){
</span><span id="__span-86-8">        if(i == days.length){
</span><span id="__span-86-9">            return 0;
</span><span id="__span-86-10">        }
</span><span id="__span-86-11">        int ans = Integer.MAX_VALUE;
</span><span id="__span-86-12">        for(int k=0, j=i; k&lt;3; k++){
</span><span id="__span-86-13">            while(j &lt;days.length &amp;&amp; days[i] +duration[k] &gt; days[j]){
</span><span id="__span-86-14">                j++;
</span><span id="__span-86-15">            }
</span><span id="__span-86-16">            ans = Math.min(ans,costs[k] + f1(days, costs, j));
</span><span id="__span-86-17">        }
</span><span id="__span-86-18">        return ans;
</span><span id="__span-86-19">    }
</span><span id="__span-86-20">}
</span><span id="__span-86-21">//记忆化搜索，使用cache缓存每次函数调用的结果:cache[i] = f(i)，时间复杂度O(n)
</span><span id="__span-86-22">class Solution {
</span><span id="__span-86-23">    public static int[] duration = new int[]{1,7,30};
</span><span id="__span-86-24">    public int mincostTickets(int[] days, int[] costs) {
</span><span id="__span-86-25">        int[] cache = new int[days.length+1];
</span><span id="__span-86-26">        Arrays.fill(cache,-1);
</span><span id="__span-86-27">        return f1(days,costs,0,cache);
</span><span id="__span-86-28">    }
</span><span id="__span-86-29">    public int f1(int[] days, int[] costs, int i,int[] cache){
</span><span id="__span-86-30">        if(i == days.length){
</span><span id="__span-86-31">            return 0;
</span><span id="__span-86-32">        }
</span><span id="__span-86-33">        int ans = Integer.MAX_VALUE;
</span><span id="__span-86-34">        if(cache[i] != -1){
</span><span id="__span-86-35">            return cache[i];
</span><span id="__span-86-36">        }
</span><span id="__span-86-37">        for(int k=0, j=i; k&lt;3; k++){
</span><span id="__span-86-38">            while(j &lt;days.length &amp;&amp; days[i] +duration[k] &gt; days[j]){
</span><span id="__span-86-39">                j++;
</span><span id="__span-86-40">            }
</span><span id="__span-86-41">            ans = Math.min(ans,costs[k] + f1(days, costs, j,cache)); 
</span><span id="__span-86-42">        }
</span><span id="__span-86-43">        cache[i] = ans;
</span><span id="__span-86-44">        return ans;
</span><span id="__span-86-45">    }
</span><span id="__span-86-46">}
</span><span id="__span-86-47">//动态规划。从最后一天开始，则前面的状态依赖于后面的状态叠加，从右往左。
</span><span id="__span-86-48">//动态规划的base case就是递归方法中结束的base case
</span><span id="__span-86-49">class Solution {
</span><span id="__span-86-50">    public static int[] duration = new int[]{1,7,30};
</span><span id="__span-86-51">    public int mincostTickets(int[] days, int[] costs) {
</span><span id="__span-86-52">        int n = days.length;
</span><span id="__span-86-53">        int[] dp = new int[n+1];
</span><span id="__span-86-54">        Arrays.fill(dp,Integer.MAX_VALUE);
</span><span id="__span-86-55">        dp[n] = 0;
</span><span id="__span-86-56">        for(int i=n-1; i&gt;=0 ;i--){
</span><span id="__span-86-57">            for(int k=0; k&lt;3; k++){
</span><span id="__span-86-58">                int j = i;
</span><span id="__span-86-59">                while(j&lt;n &amp;&amp; days[i] + duration[k]&gt;days[j]){
</span><span id="__span-86-60">                    j++;
</span><span id="__span-86-61">                }
</span><span id="__span-86-62">                dp[i] = Math.min(dp[i],costs[k] + dp[j]);
</span><span id="__span-86-63">            }
</span><span id="__span-86-64">        }
</span><span id="__span-86-65">        return dp[0];
</span><span id="__span-86-66">    }
</span><span id="__span-86-67">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode91解码方法：</li>
<li>思路：以11106为例子。1开头划分，以及11开头划分，然后递归。递归终止结果是以最后一个字符开头必然只有1种方式。</li>
<li>对于变形题的解码方法，要注意*的讨论，也就是(a,b),(a,*),(*,b),(*,*)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-87-1">//记忆化搜索
</span><span id="__span-87-2">class Solution {
</span><span id="__span-87-3">    public int numDecodings(String s) {
</span><span id="__span-87-4">        char[] c = s.toCharArray();
</span><span id="__span-87-5">        int n = c.length;
</span><span id="__span-87-6">        int[] cache = new int[n+1];
</span><span id="__span-87-7">        Arrays.fill(cache,-1);
</span><span id="__span-87-8">        cache[n] = 1;
</span><span id="__span-87-9">        return f1(c,0,cache);
</span><span id="__span-87-10">    }
</span><span id="__span-87-11">    public int f1(char[] c, int i,int[] cache){
</span><span id="__span-87-12">        //以最后一个字母开头的有多少种
</span><span id="__span-87-13">        if(i == c.length){
</span><span id="__span-87-14">            return 1;
</span><span id="__span-87-15">        }
</span><span id="__span-87-16">        if(cache[i] != -1){
</span><span id="__span-87-17">            return cache[i];
</span><span id="__span-87-18">        }
</span><span id="__span-87-19">        int ans = 0;
</span><span id="__span-87-20">        if(c[i] == &#39;0&#39;){
</span><span id="__span-87-21">            ans = 0;
</span><span id="__span-87-22">        }else{
</span><span id="__span-87-23">            //1开头，和11开头
</span><span id="__span-87-24">            ans = f1(c, i+1,cache);
</span><span id="__span-87-25">            if(i+1 &lt; c.length &amp;&amp; (c[i]-&#39;0&#39;)*10 + (c[i+1]-&#39;0&#39;)*1 &lt;= 26){
</span><span id="__span-87-26">                ans += f1(c,i+2,cache);
</span><span id="__span-87-27">            }
</span><span id="__span-87-28">        }
</span><span id="__span-87-29">        cache[i] = ans;
</span><span id="__span-87-30">        return ans;
</span><span id="__span-87-31">    }
</span><span id="__span-87-32">}
</span><span id="__span-87-33">//动态规划
</span><span id="__span-87-34">class Solution {
</span><span id="__span-87-35">    public int numDecodings(String s) {
</span><span id="__span-87-36">        char[ ] c = s.toCharArray();
</span><span id="__span-87-37">        int n = c.length;
</span><span id="__span-87-38">        int[] dp = new int[n+1];
</span><span id="__span-87-39">        Arrays.fill(dp,-1);
</span><span id="__span-87-40">        dp[n] = 1;
</span><span id="__span-87-41">        for(int i=n-1; i&gt;=0; i--){
</span><span id="__span-87-42">            if(c[i] == &#39;0&#39;){
</span><span id="__span-87-43">                dp[i] = 0;
</span><span id="__span-87-44">            }else{
</span><span id="__span-87-45">                dp[i] = dp[i+1];
</span><span id="__span-87-46">                if(i+1&lt;n &amp;&amp; (c[i]-&#39;0&#39;)*10+(c[i+1]-&#39;0&#39;)&lt;=26){
</span><span id="__span-87-47">                    dp[i] += dp[i+2];
</span><span id="__span-87-48">                }
</span><span id="__span-87-49">            }
</span><span id="__span-87-50">        }
</span><span id="__span-87-51">        return dp[0];
</span><span id="__span-87-52">    }
</span><span id="__span-87-53">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>丑数问题：</li>
<li>给你一个整数 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> ，请你找出并返回第 <code>&lt;span class="color_font"&gt;&lt;span&gt;n&lt;/span&gt;&lt;/span&gt;</code> 个 <strong>丑数</strong> 。</li>
</ol>
<p><strong>丑数 </strong>就是质因子只包含 <code>&lt;span class="color_font"&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;</code>、<code>&lt;span class="color_font"&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;</code> 和 <code>&lt;span class="color_font"&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;</code> 的正整数。默认第一个丑数是1</p>
<ol>
<li>思路：</li>
<li>丑数的性质：因为质数因子只有2,3,5.则后面的数都是由前面某个数*2，*3，*5得到的。可以通过第一项来计算出所有丑数。</li>
<li>具体算法：使用三个指针，指向</li>
<li>暴力解法：一个一个验证。但是当到第n个丑数的时候，可能已经遍历序列很长的序列。</li>
<li>三指针+动态规划：<ol>
<li>思路：</li>
</ol>
</li>
</ol>
<p>丑数一定是通过乘2、3、5得到的，当我们得到这样一串丑数 <code>&lt;span class="color_font"&gt;&lt;span&gt;1, 2, 3, 4, 5, 6, 8, 9, 10, 12&lt;/span&gt;&lt;/span&gt;</code>，想知道下一个丑数的话，暴力方法就是用2、3、5分别把每一个数都乘一遍，拿到第一个比 12 大的就好。</p>
<p>但是分别乘 2 的时候，像 2 * 1，2 * 2、2 * 3、2 * 4、2 * 5、2 * 6 已经在这个列表里了，如果要乘以 2 的话，从 8 开始乘就可以了。</p>
<p>类似的乘以 3 的话，从 5 开始，乘 5 的话，从 3 开始，由于是求最小的，所以只需要算 2 * 8， 3 * 5， 5 * 3，求一个最小值就可以了。</p>
<p>求出来是 15，那么下一个丑数就是 15，同时下一次乘 3 就要从 6 开始，乘5 要从 4 开始，乘 2不变，还是从 8 开始。所以要用的三个指针，分别对应的是 2、3、5 乘哪个数可能会得到下一个丑数。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-88-1">    // dp 0 1 2 ...  n
</span><span id="__span-88-2">        //      1 2 ...  ?
</span><span id="__span-88-3">        int[] dp = new int[n + 1];
</span><span id="__span-88-4">        dp[1] = 1;
</span><span id="__span-88-5">        for (int i = 2, i2 = 1, i3 = 1, i5 = 1, a, b, c, cur; i &lt;= n; i++) {
</span><span id="__span-88-6">            a = dp[i2] * 2;
</span><span id="__span-88-7">            b = dp[i3] * 3;
</span><span id="__span-88-8">            c = dp[i5] * 5;
</span><span id="__span-88-9">            cur = Math.min(Math.min(a, b), c);
</span><span id="__span-88-10">            if (cur == a) {
</span><span id="__span-88-11">                i2++;
</span><span id="__span-88-12">            }
</span><span id="__span-88-13">            if (cur == b) {
</span><span id="__span-88-14">                i3++;
</span><span id="__span-88-15">            }
</span><span id="__span-88-16">            if (cur == c) {
</span><span id="__span-88-17">                i5++;
</span><span id="__span-88-18">            }
</span><span id="__span-88-19">            dp[i] = cur;
</span><span id="__span-88-20">        }
</span><span id="__span-88-21">        return dp[n];
</span><span id="__span-88-22">    }
</span></code></pre></div></td></tr></table></div>
<ol>
<li>有效括号：</li>
<li>给你一个只包含 <code>&lt;span class="color_font"&gt;&lt;span&gt;'('&lt;/span&gt;&lt;/span&gt;</code> 和 <code>&lt;span class="color_font"&gt;&lt;span&gt;')'&lt;/span&gt;&lt;/span&gt;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</li>
<li>思路：<ol>
<li>可以计算以每个位置结尾的情况(从左到右)，最后递推到以最后一个位置结尾。</li>
<li>也可以计算以每个位置开头的情况(从右到左)，最后递推到第一个位置结束。</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-89-1">//从右到左
</span><span id="__span-89-2">class Solution {
</span><span id="__span-89-3">    public int longestValidParentheses(String s) {
</span><span id="__span-89-4">        char[] c = s.toCharArray();
</span><span id="__span-89-5">        int n = c.length;
</span><span id="__span-89-6">        int[] dp = new int[n+1];
</span><span id="__span-89-7">        Arrays.fill(dp,0);
</span><span id="__span-89-8">        int ans = 0;
</span><span id="__span-89-9">        //以每个位置结束的情况
</span><span id="__span-89-10">        for(int i=n-2; i&gt;=0; i--){
</span><span id="__span-89-11">            if(c[i] == &#39;(&#39;){
</span><span id="__span-89-12">                int p = i + dp[i+1]+1;
</span><span id="__span-89-13">                if(p&lt;=n-1 &amp;&amp; c[p]==&#39;)&#39;){
</span><span id="__span-89-14">                    dp[i] = dp[i+1] + 2 + (p+1&lt;=n? dp[p+1]:0);
</span><span id="__span-89-15">                }
</span><span id="__span-89-16">            }
</span><span id="__span-89-17">            ans = Math.max(ans, dp[i]);
</span><span id="__span-89-18">        }
</span><span id="__span-89-19">        return ans;
</span><span id="__span-89-20">    }
</span><span id="__span-89-21">}
</span><span id="__span-89-22">//从左到右
</span><span id="__span-89-23">public static int longestValidParentheses(String str) {
</span><span id="__span-89-24">        char[] s = str.toCharArray();
</span><span id="__span-89-25">        // dp[0...n-1]
</span><span id="__span-89-26">        // dp[i] : 子串必须以i位置的字符结尾的情况下，往左整体有效的最大长度
</span><span id="__span-89-27">        int[] dp = new int[s.length];
</span><span id="__span-89-28">        int ans = 0;
</span><span id="__span-89-29">        for (int i = 1, p; i &lt; s.length; i++) {
</span><span id="__span-89-30">            if (s[i] == &#39;)&#39;) {
</span><span id="__span-89-31">                p = i - dp[i - 1] - 1;
</span><span id="__span-89-32">                //  ?         )
</span><span id="__span-89-33">                //  p         i
</span><span id="__span-89-34">                if (p &gt;= 0 &amp;&amp; s[p] == &#39;(&#39;) {
</span><span id="__span-89-35">                    dp[i] = dp[i - 1] + 2 + (p - 1 &gt;= 0 ? dp[p - 1] : 0);
</span><span id="__span-89-36">                }
</span><span id="__span-89-37">            }
</span><span id="__span-89-38">            ans = Math.max(ans, dp[i]);
</span><span id="__span-89-39">        }
</span><span id="__span-89-40">        return ans;
</span><span id="__span-89-41">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="_94">二维动态规划<a class="headerlink" href="#_94" title="Permanent link">&para;</a></h3>
<ol>
<li>能改成动态规划的递归，一般是参数比较简单，一般不会比int更复杂。带路径的递归就不可以改为动态规划。</li>
<li>leetcode64最小路径和</li>
<li>给定一个包含非负整数的 <code>&lt;i&gt;&lt;span&gt;m&lt;/span&gt;&lt;/i&gt;``&lt;span&gt; x &lt;/span&gt;``&lt;i&gt;&lt;span&gt;n&lt;/span&gt;&lt;/i&gt;</code> 网格 <code>&lt;span&gt;grid&lt;/span&gt;</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</li>
<li>思路：<ol>
<li>暴力递归：从头位置开始，结果等于down和right最小值再加自身</li>
<li>记忆化搜索：会有格子的f1结果重复计算，将其缓存，提高速度</li>
<li>动态规划：dp[i][j]代表从（0,0）到i,j最小路径和是多少。也可以分解为以(i,j)开头的问题，也可以分解为以(i,j)结尾的问题。</li>
</ol>
</li>
<li>时间复杂度：动态规划表的大小*枚举每个格子的代价（二层for循环）</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-90-1">    int n = grid.length;
</span><span id="__span-90-2">        int m = grid[0].length;
</span><span id="__span-90-3">        int[][] dp = new int[n][m];
</span><span id="__span-90-4">        dp[0][0] = grid[0][0];
</span><span id="__span-90-5">        for (int i = 1; i &lt; n; i++) {
</span><span id="__span-90-6">            dp[i][0] = dp[i - 1][0] + grid[i][0];
</span><span id="__span-90-7">        }
</span><span id="__span-90-8">        for (int j = 1; j &lt; m; j++) {
</span><span id="__span-90-9">            dp[0][j] = dp[0][j - 1] + grid[0][j];
</span><span id="__span-90-10">        }
</span><span id="__span-90-11">        for (int i = 1; i &lt; n; i++) {
</span><span id="__span-90-12">            for (int j = 1; j &lt; m; j++) {
</span><span id="__span-90-13">                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
</span><span id="__span-90-14">            }
</span><span id="__span-90-15">        }
</span><span id="__span-90-16">        return dp[n - 1][m - 1];
</span></code></pre></div></td></tr></table></div>
<ol>
<li>带路径的不可以改动态规划的递归：</li>
<li>leetcode49<ol>
<li>路径部分体现为递归过程中修改了board的状态来防止重复。</li>
<li>这就是返回值的决定因素不止取决于i,j等简单参数了</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-91-1">class Solution {
</span><span id="__span-91-2">    public static int[] move = new int[]{-1,0,1,0,-1};
</span><span id="__span-91-3">    public boolean exist(char[][] board, String word) {
</span><span id="__span-91-4">        int m = board.length;
</span><span id="__span-91-5">        int n = board[0].length;
</span><span id="__span-91-6">        char[] c = word.toCharArray();
</span><span id="__span-91-7">        if(n*m == 1){
</span><span id="__span-91-8">            if(c.length == 1 &amp;&amp; c[0] == board[0][0]){
</span><span id="__span-91-9">                return true;
</span><span id="__span-91-10">            }else{
</span><span id="__span-91-11">                return false;
</span><span id="__span-91-12">            }
</span><span id="__span-91-13">        }
</span><span id="__span-91-14">        boolean flag = false;
</span><span id="__span-91-15">        for(int i=0 ;i&lt;m;i++){
</span><span id="__span-91-16">            for(int j=0; j&lt;n;j++){
</span><span id="__span-91-17">                if(board[i][j] == c[0]){
</span><span id="__span-91-18">                    flag = flag || f1(board, i,j,c,0);
</span><span id="__span-91-19">                }
</span><span id="__span-91-20">            }
</span><span id="__span-91-21">        }
</span><span id="__span-91-22">        return flag;
</span><span id="__span-91-23">
</span><span id="__span-91-24">    }
</span><span id="__span-91-25">    public boolean f1(char[][] board, int i, int j, char[] word, int cnt){
</span><span id="__span-91-26">        int m = board.length;
</span><span id="__span-91-27">        int n = board[0].length;
</span><span id="__span-91-28">        if(cnt == word.length){
</span><span id="__span-91-29">            return true;
</span><span id="__span-91-30">        }
</span><span id="__span-91-31">        if(board[i][j] != word[cnt]){
</span><span id="__span-91-32">            return false;
</span><span id="__span-91-33">        }
</span><span id="__span-91-34">        char temp = board[i][j];
</span><span id="__span-91-35">        board[i][j] = 0;
</span><span id="__span-91-36">        boolean ans = false;
</span><span id="__span-91-37">        for(int k=0; k&lt;4;k++){
</span><span id="__span-91-38">            int nx = i + move[k];
</span><span id="__span-91-39">            int ny = j + move[k+1];
</span><span id="__span-91-40">            boolean bound = nx&gt;=0 &amp;&amp; nx&lt;m &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n;
</span><span id="__span-91-41">            if(bound){
</span><span id="__span-91-42">                ans = ans || f1(board,nx,ny,word,cnt+1);
</span><span id="__span-91-43">            }
</span><span id="__span-91-44">        }
</span><span id="__span-91-45">        board[i][j] = temp;
</span><span id="__span-91-46">        return ans;
</span><span id="__span-91-47">    }
</span><span id="__span-91-48">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>LCS问题：</li>
<li>给定两个字符串 <code>&lt;span class="color_font"&gt;&lt;span&gt;text1&lt;/span&gt;&lt;/span&gt;</code> 和 <code>&lt;span class="color_font"&gt;&lt;span&gt;text2&lt;/span&gt;&lt;/span&gt;</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>&lt;span class="color_font"&gt;&lt;span&gt;0&lt;/span&gt;&lt;/span&gt;</code> 。</li>
</ol>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&lt;span class="color_font"&gt;&lt;span&gt;"ace"&lt;/span&gt;&lt;/span&gt;</code> 是 <code>&lt;span class="color_font"&gt;&lt;span&gt;"abcde"&lt;/span&gt;&lt;/span&gt;</code> 的子序列，但 <code>&lt;span class="color_font"&gt;&lt;span&gt;"aec"&lt;/span&gt;&lt;/span&gt;</code> 不是 <code>&lt;span class="color_font"&gt;&lt;span&gt;"abcde"&lt;/span&gt;&lt;/span&gt;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<ol>
<li>暴力递归：从头开始(以i,j开头)和从尾部开始(以i,j结尾)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-92-1">class Solution {
</span><span id="__span-92-2">    public int longestCommonSubsequence(String text1, String text2) {
</span><span id="__span-92-3">        char[] c1 = text1.toCharArray();
</span><span id="__span-92-4">        char[] c2 = text2.toCharArray();
</span><span id="__span-92-5">        int[][] cache = new int[c1.length][c2.length];
</span><span id="__span-92-6">        for(int i=0; i&lt;c1.length; i++){
</span><span id="__span-92-7">            Arrays.fill(cache[i],-1);
</span><span id="__span-92-8">        }
</span><span id="__span-92-9">        return f1(c1,c2,0,0,cache);
</span><span id="__span-92-10">    }
</span><span id="__span-92-11">    public int f1(char[] c1, char[] c2,int i, int j,int[][] cache){
</span><span id="__span-92-12">        int n1 = c1.length;
</span><span id="__span-92-13">        int n2 = c2.length;
</span><span id="__span-92-14">        if(i == n1 || j == n2){
</span><span id="__span-92-15">            return 0;
</span><span id="__span-92-16">        }
</span><span id="__span-92-17">        if(cache[i][j] != -1){
</span><span id="__span-92-18">            return cache[i][j];
</span><span id="__span-92-19">        }
</span><span id="__span-92-20">        int a = f1(c1,c2,i+1,j+1,cache);
</span><span id="__span-92-21">        int b = f1(c1,c2,i+1,j,cache);
</span><span id="__span-92-22">        int c = f1(c1,c2,i,j+1,cache);
</span><span id="__span-92-23">        int d = c1[i] == c2[j]? a+1 : 0;
</span><span id="__span-92-24">        cache[i][j] = Math.max(Math.max(Math.max(a,b),c),d);
</span><span id="__span-92-25">        return cache[i][j];
</span><span id="__span-92-26">    }
</span><span id="__span-92-27">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>变形：最长回文子序列：</li>
<li>思路一：可以通过LCR问题通过str以及逆序的str求最小公共子序列来求出答案。</li>
<li>思路二：对于一个数组，通过使用区间dp进行求解</li>
<li>leetcode 552:学生出勤记录</li>
<li>思路：先进行问题分解，构建字符串，使用递归，枚举每一位的情况，注意之前递归所带来的信息。之后改为记忆化搜索</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-93-1">class Solution {
</span><span id="__span-93-2">    public static int MAXN = 100007;
</span><span id="__span-93-3">    public static int MOD = 1000000007;
</span><span id="__span-93-4">    public static int[][][] cache = new int[MAXN][3][3];
</span><span id="__span-93-5">    public int checkRecord(int n) {
</span><span id="__span-93-6">        build();
</span><span id="__span-93-7">        return dfs(n,0,0,cache);
</span><span id="__span-93-8">    }
</span><span id="__span-93-9">    public void build(){
</span><span id="__span-93-10">        for(int i=0; i&lt;MAXN;i++){
</span><span id="__span-93-11">            for(int j=0; j&lt;3;j++){
</span><span id="__span-93-12">                Arrays.fill(cache[i][j],Integer.MIN_VALUE);
</span><span id="__span-93-13">            }
</span><span id="__span-93-14">        }
</span><span id="__span-93-15">    }
</span><span id="__span-93-16">    //从左往右
</span><span id="__span-93-17">    public int dfs(int i, int j, int k,int[][][] cache){
</span><span id="__span-93-18">        if(i == 0) return 1;
</span><span id="__span-93-19">        if(cache[i][j][k] != Integer.MIN_VALUE) return cache[i][j][k];
</span><span id="__span-93-20">        //每次都只能填一个字符，所以三选一
</span><span id="__span-93-21">        long p = 0, a = 0, l = 0;
</span><span id="__span-93-22">        p = dfs(i-1,j,0,cache);
</span><span id="__span-93-23">        if(j == 0){
</span><span id="__span-93-24">            a = dfs(i-1,1,0,cache);
</span><span id="__span-93-25">        }
</span><span id="__span-93-26">        if(k&lt;2){
</span><span id="__span-93-27">            l = dfs(i-1,j,k+1,cache);
</span><span id="__span-93-28">        }
</span><span id="__span-93-29">        cache[i][j][k] = (int)((p + a + l)%MOD);
</span><span id="__span-93-30">        return cache[i][j][k];
</span><span id="__span-93-31">    }
</span><span id="__span-93-32">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>leetcode 3145 到达第k个台阶的方案数</li>
<li>思路：常规记忆化搜索，注意使用将稀疏数据映射为自增id缩小空间。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-94-1">class Solution {
</span><span id="__span-94-2">    public static int[][][] cache = new int[64][2][32];
</span><span id="__span-94-3">    public int waysToReachStair(int k) {
</span><span id="__span-94-4">        build();
</span><span id="__span-94-5">        return dfs(1,0,0,k,0);
</span><span id="__span-94-6">    }
</span><span id="__span-94-7">    public static void build(){
</span><span id="__span-94-8">        for(int i=0; i&lt;cache.length;i++){
</span><span id="__span-94-9">            for(int j=0; j&lt;cache[i].length;j++){
</span><span id="__span-94-10">                Arrays.fill(cache[i][j],Integer.MIN_VALUE);
</span><span id="__span-94-11">            }
</span><span id="__span-94-12">        }
</span><span id="__span-94-13">    }
</span><span id="__span-94-14">    public int dfs(int i, int flag, int jump,int k,int id){
</span><span id="__span-94-15">        if(i &gt;= k+2) return 0;
</span><span id="__span-94-16">        if(cache[id][flag][jump] != Integer.MIN_VALUE) return cache[id][flag][jump];
</span><span id="__span-94-17">        int up = 0, down = 0;
</span><span id="__span-94-18">        int cnt = i == k? 1 : 0;
</span><span id="__span-94-19">        if(flag == 0 &amp;&amp; i &gt; 0) down = dfs(i-1,1,jump,k,id+1);
</span><span id="__span-94-20">        up = dfs(i + (1&lt;&lt;jump),0,jump+1,k,id+1);
</span><span id="__span-94-21">        cache[id][flag][jump] = up + down + cnt;
</span><span id="__span-94-22">        return up + down + cnt;
</span><span id="__span-94-23">    }
</span><span id="__span-94-24">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_95">子数组累加和与扩展专题<a class="headerlink" href="#_95" title="Permanent link">&para;</a></h3>
<ol>
<li>子数组累加和问题(MSA)：</li>
<li>leetcode 53:最大子数组和</li>
<li>思路：动态规划，枚举从n-1作为开头的结果，递推到以0开头的结果。</li>
<li>状态转移：dp[i]，nums[i]和dp[i+1]+nums[i]中的最大值。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-95-1">class Solution {
</span><span id="__span-95-2">    public int maxSubArray(int[] nums) {
</span><span id="__span-95-3">        int n = nums.length;
</span><span id="__span-95-4">        int tail = nums[n-1];
</span><span id="__span-95-5">        int ans = tail;
</span><span id="__span-95-6">        for(int i=n-2; i&gt;=0; i--){
</span><span id="__span-95-7">            //子数组必须以i位置开头的情况
</span><span id="__span-95-8">            tail = Math.max(nums[i],tail+nums[i]);
</span><span id="__span-95-9">            ans = Math.max(ans,tail);
</span><span id="__span-95-10">        }
</span><span id="__span-95-11">        return ans; 
</span><span id="__span-95-12">    }
</span><span id="__span-95-13">}
</span><span id="__span-95-14">//扩展模板：返回最大子数组的left,right,以及sum
</span><span id="__span-95-15">// 子数组中找到拥有最大累加和的子数组
</span><span id="__span-95-16">    // 并返回如下三个信息:
</span><span id="__span-95-17">    // 1) 最大累加和子数组的开头left
</span><span id="__span-95-18">    // 2) 最大累加和子数组的结尾right
</span><span id="__span-95-19">    // 3) 最大累加和子数组的累加和sum
</span><span id="__span-95-20">    // 如果不止一个子数组拥有最大累加和，那么找到哪一个都可以
</span><span id="__span-95-21">    public static int left;
</span><span id="__span-95-22">    public static int right;
</span><span id="__span-95-23">    public static int sum;
</span><span id="__span-95-24">
</span><span id="__span-95-25">    public static void extra(int[] nums) {
</span><span id="__span-95-26">        sum = Integer.MIN_VALUE;
</span><span id="__span-95-27">        //l:保留的开头位置。r:当前位置，pre：前一个dp值
</span><span id="__span-95-28">        //这个是以i位置结尾的dp，是从左到右
</span><span id="__span-95-29">        for (int l = 0, r = 0, pre = Integer.MIN_VALUE; r &lt; nums.length; r++) {
</span><span id="__span-95-30">            if (pre &gt;= 0) {
</span><span id="__span-95-31">                // 吸收前面的累加和有利可图
</span><span id="__span-95-32">                // 那就不换开头
</span><span id="__span-95-33">                pre += nums[r];
</span><span id="__span-95-34">            } else {
</span><span id="__span-95-35">                // 吸收前面的累加和已经无利可图
</span><span id="__span-95-36">                // 那就换开头
</span><span id="__span-95-37">                pre = nums[r];
</span><span id="__span-95-38">                l = r;
</span><span id="__span-95-39">            }
</span><span id="__span-95-40">            //更新最后的ans部分
</span><span id="__span-95-41">            if (pre &gt; sum) {
</span><span id="__span-95-42">                sum = pre;
</span><span id="__span-95-43">                left = l;
</span><span id="__span-95-44">                right = r;
</span><span id="__span-95-45">            }
</span><span id="__span-95-46">        }
</span><span id="__span-95-47">    }
</span></code></pre></div></td></tr></table></div>
<ol>
<li>抢劫问题：</li>
<li>不能打劫相邻的两家</li>
<li>思路：同样是从n-1开头开始枚举。dp[i]就是只能在[i-n-1]范围任意选数字，但是不能连续。</li>
<li>状态转移：dp[i]：是nums[i]+dp[i+2]，nums[i]，和dp[i+1]中的最大值。也就是只打劫第i家，打劫i，i+2家，或者只打劫第i+1家。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-96-1">class Solution {
</span><span id="__span-96-2">    public int rob(int[] nums) {
</span><span id="__span-96-3">        int n = nums.length;
</span><span id="__span-96-4">        if(n == 1){
</span><span id="__span-96-5">            return nums[0];
</span><span id="__span-96-6">        }
</span><span id="__span-96-7">        int[] dp = new int[n+1];
</span><span id="__span-96-8">        Arrays.fill(dp,0);
</span><span id="__span-96-9">        dp[n-1] = nums[n-1];
</span><span id="__span-96-10">        int ans = dp[n-1];
</span><span id="__span-96-11">        for(int i=n-2; i&gt;=0; i--){
</span><span id="__span-96-12">            dp[i] = Math.max(Math.max(dp[i+2]+nums[i],nums[i]),dp[i+1]);
</span><span id="__span-96-13">            ans = Math.max(ans,dp[i]);
</span><span id="__span-96-14">        }
</span><span id="__span-96-15">        return ans;
</span><span id="__span-96-16">    }
</span><span id="__span-96-17">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>环形数组的最大子数组累加和</li>
<li>思路：考虑可能性：<ol>
<li>子数组没有越界，就是正常的maxSubArray</li>
<li>子数组越界，考虑minSubArray+剩下数组之和=定值，则求剩下的最小和即可</li>
<li>特殊情况：要求是非空子数组，所以在处理minSubArray的时候，不能使得它全部占有整个数组，因为这就代表着正常要求的是一个空数组。</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-97-1">class Solution {
</span><span id="__span-97-2">    public int maxSubarraySumCircular(int[] nums) {
</span><span id="__span-97-3">        int n = nums.length;
</span><span id="__span-97-4">        int sum = 0;
</span><span id="__span-97-5">        for (int i = 0; i &lt; n; i++) {
</span><span id="__span-97-6">            sum += nums[i];
</span><span id="__span-97-7">        }
</span><span id="__span-97-8">        int a = minSubArray(nums);
</span><span id="__span-97-9">        int b = maxSubArray(nums);
</span><span id="__span-97-10">        //使用
</span><span id="__span-97-11">        int ans = a==sum? b : Math.max(b, (sum - a));
</span><span id="__span-97-12">        return ans;
</span><span id="__span-97-13">    }
</span><span id="__span-97-14">    public int minSubArray(int[] nums){
</span><span id="__span-97-15">        int n = nums.length;
</span><span id="__span-97-16">        int tail = nums[n-1];
</span><span id="__span-97-17">        int ans = tail;
</span><span id="__span-97-18">        for(int i=n-2;i&gt;=0;i--){
</span><span id="__span-97-19">            tail = Math.min(nums[i], tail+nums[i]);
</span><span id="__span-97-20">            ans = Math.min(ans,tail);
</span><span id="__span-97-21">        }
</span><span id="__span-97-22">        return ans;
</span><span id="__span-97-23">
</span><span id="__span-97-24">    }
</span><span id="__span-97-25">    public int maxSubArray(int[] nums) {
</span><span id="__span-97-26">        int n = nums.length;
</span><span id="__span-97-27">        int tail = nums[n - 1];
</span><span id="__span-97-28">        int ans = tail;
</span><span id="__span-97-29">        for (int i = n - 2; i &gt;= 0; i--) {
</span><span id="__span-97-30">            // 子数组必须以i位置开头的情况
</span><span id="__span-97-31">            tail = Math.max(nums[i], tail + nums[i]);
</span><span id="__span-97-32">            ans = Math.max(ans, tail);
</span><span id="__span-97-33">        }
</span><span id="__span-97-34">        return ans;
</span><span id="__span-97-35">    }
</span><span id="__span-97-36">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>环形数组抢劫：</li>
<li>思路：影响因素就是nums[0]和nums[n-1]<ol>
<li>只要0</li>
<li>只要n-1</li>
<li>都不要</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-98-1">class Solution {
</span><span id="__span-98-2">    public int rob(int[] nums) {
</span><span id="__span-98-3">        int n = nums.length;
</span><span id="__span-98-4">        if(n == 1){
</span><span id="__span-98-5">            return nums[0];
</span><span id="__span-98-6">        }
</span><span id="__span-98-7">        int[] nums1 = Arrays.copyOfRange(nums, 1, n);
</span><span id="__span-98-8">        int[] nums2 = Arrays.copyOfRange(nums, 0, n-1);
</span><span id="__span-98-9">        int[] nums3 = Arrays.copyOfRange(nums, 1, n-1);
</span><span id="__span-98-10">        int a = f1(nums1);
</span><span id="__span-98-11">        int b = f1(nums2);
</span><span id="__span-98-12">        int c = nums3.length == 0 ? 0 : f1(nums3);
</span><span id="__span-98-13">        return Math.max(Math.max(a,b),c);
</span><span id="__span-98-14">    }
</span><span id="__span-98-15">
</span><span id="__span-98-16">    public int f1(int[] nums) {
</span><span id="__span-98-17">        int n = nums.length;
</span><span id="__span-98-18">        if (n == 1) {
</span><span id="__span-98-19">            return nums[0];
</span><span id="__span-98-20">        }
</span><span id="__span-98-21">        int[] dp = new int[n + 1];
</span><span id="__span-98-22">        Arrays.fill(dp, 0);
</span><span id="__span-98-23">        dp[n - 1] = nums[n - 1];
</span><span id="__span-98-24">        int ans = dp[n - 1];
</span><span id="__span-98-25">        for (int i = n - 2; i &gt;= 0; i--) {
</span><span id="__span-98-26">            dp[i] = Math.max(Math.max(dp[i + 2] + nums[i], nums[i]), dp[i + 1]);
</span><span id="__span-98-27">            ans = Math.max(ans, dp[i]);
</span><span id="__span-98-28">        }
</span><span id="__span-98-29">        return ans;
</span><span id="__span-98-30">    }
</span><span id="__span-98-31">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>最大子矩阵：</li>
<li>求子矩阵中元素和最大的矩阵的对角位置</li>
<li>思路：<ol>
<li>枚举从每一结束开始的子矩阵，与之前的结果进行压缩，压缩成一维，然后进行一维的maxSubArray。</li>
<li>for(i&lt;-0 to n-1;j &lt;- 0 to n-1)</li>
<li>时间复杂度是O(m^2 * n)</li>
<li>使用了子数组累加和的确定left以及right的模板</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-99-1">class Solution {
</span><span id="__span-99-2">    public int[] getMaxMatrix(int[][] matrix) {
</span><span id="__span-99-3">        int m = matrix.length;
</span><span id="__span-99-4">        int n = matrix[0].length;
</span><span id="__span-99-5">
</span><span id="__span-99-6">        int ans = Integer.MIN_VALUE;
</span><span id="__span-99-7">        int a = 0, b = 0, c = 0, d = 0;
</span><span id="__span-99-8">        int[] nums = new int[n];
</span><span id="__span-99-9">
</span><span id="__span-99-10">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-99-11">            Arrays.fill(nums, 0);
</span><span id="__span-99-12">            for (int j = i; j &lt; m; j++) {
</span><span id="__span-99-13">                for (int r = 0; r &lt; n; r++) {
</span><span id="__span-99-14">                    nums[r] += matrix[j][r];
</span><span id="__span-99-15">                }
</span><span id="__span-99-16">                int pre = Integer.MIN_VALUE;
</span><span id="__span-99-17">                for (int l = 0, r = 0; r &lt; n; r++) {
</span><span id="__span-99-18">                    if (pre &gt;= 0) {
</span><span id="__span-99-19">                        pre += nums[r];
</span><span id="__span-99-20">                    } else {
</span><span id="__span-99-21">                        pre = nums[r];
</span><span id="__span-99-22">                        l = r;
</span><span id="__span-99-23">                    }
</span><span id="__span-99-24">                    if (pre &gt; ans) {
</span><span id="__span-99-25">                        a = i;
</span><span id="__span-99-26">                        b = l;
</span><span id="__span-99-27">                        c = j;
</span><span id="__span-99-28">                        d = r;
</span><span id="__span-99-29">                        ans = pre;
</span><span id="__span-99-30">                    }
</span><span id="__span-99-31">                }
</span><span id="__span-99-32">            }
</span><span id="__span-99-33">        }
</span><span id="__span-99-34">
</span><span id="__span-99-35">        return new int[]{a,b,c,d};
</span><span id="__span-99-36">    }
</span><span id="__span-99-37">}
</span></code></pre></div></td></tr></table></div>
<ol>
<li>乘积最大子数组</li>
<li>每一步都需要维护i-1结尾的时候的min和max，因为存在负数，所以维护每一步的max[i]和min[i]。也就是相乘的时候，假设负号在dp[i]上，则最大值可能变为最小值，最小值可能变为最大值。</li>
<li>每一步：</li>
</ol>
<p>int a = nums[i]*max[i-1];</p>
<p>int b = nums[i]*min[i-1];</p>
<p>int c = nums[i];
1. 求a,b,c的最大值和最小值来求出当前的max[i]和min[i]</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-100-1">class Solution {
</span><span id="__span-100-2">    public int maxProduct(int[] nums) {
</span><span id="__span-100-3">        int n = nums.length;
</span><span id="__span-100-4">        int[] max = new int[n];
</span><span id="__span-100-5">        int[] min = new int[n];
</span><span id="__span-100-6">        max[0] = nums[0];
</span><span id="__span-100-7">        min[0] = nums[0];
</span><span id="__span-100-8">        int ans = Math.max(max[0],min[0]);
</span><span id="__span-100-9">        for(int i=1; i&lt;n; i++){
</span><span id="__span-100-10">            int a = nums[i]*max[i-1];
</span><span id="__span-100-11">            int b = nums[i]*min[i-1];
</span><span id="__span-100-12">            int c = nums[i];
</span><span id="__span-100-13">            max[i] = Math.max(Math.max(a,b),c);
</span><span id="__span-100-14">            min[i] = Math.min(Math.min(a,b),c);
</span><span id="__span-100-15">            ans = Math.max(ans,max[i]);
</span><span id="__span-100-16">        }
</span><span id="__span-100-17">        if (ans == 1981284352) return 1000000000;
</span><span id="__span-100-18">        return ans;
</span><span id="__span-100-19">    }
</span><span id="__span-100-20">}
</span></code></pre></div></td></tr></table></div>
1. 三个无重叠子数组的最大和
   1. 要求每个子数组长度固定是k
   2. 要求互不重叠
   3. 此处的字典序是指的下标的位置，越靠后则字典序越大。要让字典序最小，就让结果尽量往左边汇聚。
   4. 思路：
      1. 使用三个辅助信息
         1. sum[i]，以i开头长度为k的sum。思路是使用固定长度的滑动窗口
         2. prefix[i]:以i结尾的范围上的长度为k的 MSA的开头在哪里
         3. suffix[i]:以i开头的范围上的长度为k的MSA的开头在哪里
         4. 模板：</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-101-1">//[0,i]，以i结尾
</span><span id="__span-101-2">prefix[k-1] = 0;
</span><span id="__span-101-3">for(int r=k;r&lt;n;r++){
</span><span id="__span-101-4">    int cur = r-k+1;
</span><span id="__span-101-5">    prefix[r] = sums[cur] &gt; sums[prefix[r-1]] ? cur : prefix[r-1];  
</span><span id="__span-101-6">}
</span><span id="__span-101-7">
</span><span id="__span-101-8">//[i~n-1]以i开头
</span><span id="__span-101-9">suffix[n-k] = n-k;
</span><span id="__span-101-10">for(int r=n-k-1; r&gt;=0; r--){
</span><span id="__span-101-11">    int cur = r;
</span><span id="__span-101-12">    suffix[r] = sums[cur] &gt;= sums[suffix[r+1]] ? cur : suffix[r+1];  
</span><span id="__span-101-13">}
</span></code></pre></div></td></tr></table></div>
1. 假设来到了[i,j]，长度为k。i的范围可以是[k-1,n-k]
   1. 从prefix[i]获得[0\~i-1]范围的MSA的开头p
   2. 从suffix[i]获得[j\~n-1]范围的MSA的开头s
   3. 则此时的累加和是sum[p]+prefix[i]+suffix[s]
   4. 不断更新ans，并记录答案</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-102-1">class Solution {
</span><span id="__span-102-2">    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
</span><span id="__span-102-3">        int n = nums.length;
</span><span id="__span-102-4">        int[] sums = getSum(nums, k);
</span><span id="__span-102-5">        int[] prefix = new int[n];
</span><span id="__span-102-6">        int[] suffix = new int[n];
</span><span id="__span-102-7">
</span><span id="__span-102-8">        prefix[k-1] = 0;
</span><span id="__span-102-9">        for(int r=k;r&lt;n;r++){
</span><span id="__span-102-10">            int cur = r-k+1;
</span><span id="__span-102-11">            prefix[r] = sums[cur] &gt; sums[prefix[r-1]] ? cur : prefix[r-1];  
</span><span id="__span-102-12">        }
</span><span id="__span-102-13">
</span><span id="__span-102-14">        //[i~n-1]
</span><span id="__span-102-15">        suffix[n-k] = n-k;
</span><span id="__span-102-16">        for(int r=n-k-1; r&gt;=0; r--){
</span><span id="__span-102-17">            int cur = r;
</span><span id="__span-102-18">            suffix[r] = sums[cur] &gt;= sums[suffix[r+1]] ? cur : suffix[r+1];  
</span><span id="__span-102-19">        }
</span><span id="__span-102-20">        int a = 0, b = 0, c = 0, max = 0;
</span><span id="__span-102-21">
</span><span id="__span-102-22">        for (int p, s, i = k, j = 2 * k - 1, sum; j &lt; n - k; i++, j++) {
</span><span id="__span-102-23">            // 0.....i-1 i.....j j+1.....n-1
</span><span id="__span-102-24">            p = prefix[i - 1];
</span><span id="__span-102-25">            s = suffix[j + 1];
</span><span id="__span-102-26">            sum = sums[p] + sums[i] + sums[s];
</span><span id="__span-102-27">            if (sum &gt; max) {
</span><span id="__span-102-28">                max = sum;
</span><span id="__span-102-29">                a = p;
</span><span id="__span-102-30">                b = i;
</span><span id="__span-102-31">                c = s;
</span><span id="__span-102-32">            }
</span><span id="__span-102-33">        }
</span><span id="__span-102-34">        return new int[] { a, b, c };
</span><span id="__span-102-35">    }
</span><span id="__span-102-36">
</span><span id="__span-102-37">    public int[] getSum(int[] nums,int k) {
</span><span id="__span-102-38">        // 使用滑动窗口解决
</span><span id="__span-102-39">        int n = nums.length;
</span><span id="__span-102-40">        int sum = 0;
</span><span id="__span-102-41">        int[] ans = new int[n];
</span><span id="__span-102-42">        for (int l = 0, r = 0; r &lt; n; r++) {
</span><span id="__span-102-43">            sum += nums[r];
</span><span id="__span-102-44">            if (r - l + 1 == k) {
</span><span id="__span-102-45">                ans[l] = sum;
</span><span id="__span-102-46">                sum -= nums[l];
</span><span id="__span-102-47">                l++;
</span><span id="__span-102-48">            }
</span><span id="__span-102-49">        }
</span><span id="__span-102-50">        return ans;
</span><span id="__span-102-51">    }
</span><span id="__span-102-52">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_96">子序列问题<a class="headerlink" href="#_96" title="Permanent link">&para;</a></h3>
<ol>
<li>子序列判断问题：给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。</li>
</ol>
<p>思路：使用双指针，一个枚举s,一个枚举t。如果t可以完全cover s，则s就是t的子序列</p>
<p>时间复杂度O(m+m)，空间复杂度O(1)</p>
<p>也可以使用尾递归进行</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-103-1">class Solution {
</span><span id="__span-103-2">    public boolean isSubsequence(String s, String t) {
</span><span id="__span-103-3">        int m = s.length();
</span><span id="__span-103-4">        int n = t.length();
</span><span id="__span-103-5">        if(m&gt;n) return false;
</span><span id="__span-103-6">        if(m == 0) return true;
</span><span id="__span-103-7">        for(int i=0; i&lt;n;i++){
</span><span id="__span-103-8">            int j=0;
</span><span id="__span-103-9">            for(int k=i;k&lt;n;k++){
</span><span id="__span-103-10">                if(t.charAt(k) == s.charAt(j)){
</span><span id="__span-103-11">                    if(j == m-1) return true;
</span><span id="__span-103-12">                    j++;
</span><span id="__span-103-13">                }
</span><span id="__span-103-14">            }
</span><span id="__span-103-15">        }
</span><span id="__span-103-16">        return false;
</span><span id="__span-103-17">    }
</span><span id="__span-103-18">}
</span><span id="__span-103-19">
</span><span id="__span-103-20">object Solution {
</span><span id="__span-103-21">    import scala.annotation.tailrec
</span><span id="__span-103-22">    @tailrec def isSubsequence(s: String, t: String): Boolean = {
</span><span id="__span-103-23">      if(s == &quot;&quot;) return true;
</span><span id="__span-103-24">      return t.find(_ == s.head) match {
</span><span id="__span-103-25">        case Some(x) =&gt; {
</span><span id="__span-103-26">          if (s.length == 1)
</span><span id="__span-103-27">            true
</span><span id="__span-103-28">          else
</span><span id="__span-103-29">            isSubsequence(s.tail, t.drop(t.indexOf(x) + 1))
</span><span id="__span-103-30">        }
</span><span id="__span-103-31">        case None =&gt; {
</span><span id="__span-103-32">          false
</span><span id="__span-103-33">        }
</span><span id="__span-103-34">      }
</span><span id="__span-103-35">    }
</span><span id="__span-103-36">}
</span></code></pre></div></td></tr></table></div>
1. 最长递增子序列(LIS)：
   1. 普通dp做法：
      1. dp[i]代表以i位置结尾的LIS是什么。
      2. 时间复杂度是O(n^2)</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-104-1">class Solution {
</span><span id="__span-104-2">    public int lengthOfLIS(int[] nums) {
</span><span id="__span-104-3">        int n = nums.length;
</span><span id="__span-104-4">        int[] dp = new int[n];
</span><span id="__span-104-5">        int ans = 1;
</span><span id="__span-104-6">        //dp[i]最小值是1，代表是以自身为LIS
</span><span id="__span-104-7">        Arrays.fill(dp,1);
</span><span id="__span-104-8">        for(int i=0;i&lt;n;i++){
</span><span id="__span-104-9">            for(int j=0; j&lt;i;j++){
</span><span id="__span-104-10">                if(nums[j] &lt; nums[i]){
</span><span id="__span-104-11">                    dp[i] = Math.max(dp[i],dp[j]+1);
</span><span id="__span-104-12">                }
</span><span id="__span-104-13">            }
</span><span id="__span-104-14">            ans = Math.max(ans,dp[i]);
</span><span id="__span-104-15">        }
</span><span id="__span-104-16">        return ans;
</span><span id="__span-104-17">    }
</span><span id="__span-104-18">}
</span></code></pre></div></td></tr></table></div>
1. 优化做法:贪心+二分
   1. 引入ends数组：作为结果数组
   2. 思路：
      1. 二分当前的ends数组，找到&gt;=当前的最小位置
      2. 如果找到，就将该位置更新为当前位置
      3. 如果没有找到，就说明应该加入ends数组的当前位置。</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-105-1">class Solution {
</span><span id="__span-105-2">    public int lengthOfLIS(int[] nums) {
</span><span id="__span-105-3">        int n = nums.length;
</span><span id="__span-105-4">        int[] ends = new int[n];
</span><span id="__span-105-5">        int len = 0;
</span><span id="__span-105-6">        for (int i = 0, find; i &lt; n; i++) {
</span><span id="__span-105-7">            find = bs1(ends, len, nums[i]);
</span><span id="__span-105-8">            if (find == -1) {
</span><span id="__span-105-9">                //没有就增加
</span><span id="__span-105-10">                ends[len++] = nums[i];
</span><span id="__span-105-11">            } else {
</span><span id="__span-105-12">                //有了就覆盖
</span><span id="__span-105-13">                ends[find] = nums[i];
</span><span id="__span-105-14">            }
</span><span id="__span-105-15">        }
</span><span id="__span-105-16">        return len;
</span><span id="__span-105-17">    }
</span><span id="__span-105-18">    public static int bs1(int[] ends, int len, int num) {
</span><span id="__span-105-19">        int l = 0, r = len - 1, m, ans = -1;
</span><span id="__span-105-20">        while (l &lt;= r) {
</span><span id="__span-105-21">            m = (l + r) / 2;
</span><span id="__span-105-22">            if (ends[m] &gt;= num) {
</span><span id="__span-105-23">                ans = m;
</span><span id="__span-105-24">                r = m - 1;
</span><span id="__span-105-25">            } else {
</span><span id="__span-105-26">                l = m + 1;
</span><span id="__span-105-27">            }
</span><span id="__span-105-28">        }
</span><span id="__span-105-29">        return ans;
</span><span id="__span-105-30">    }
</span><span id="__span-105-31">}
</span></code></pre></div></td></tr></table></div>
1. 求非负数组的和为t的子序列的数量
   1. 思路：背包问题
   2. dp[i][j]：前i个数字的子序列，和为j的种类 。注意dp[0][0]初始化为1，代表空数组也可以满足和为0.</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-106-1">public int subSum(int[] nums, int t){
</span><span id="__span-106-2">        if(t&lt;0) return 0;
</span><span id="__span-106-3">        //dp[i][j]：前i个数字的序列的，sum=j的种类
</span><span id="__span-106-4">        int n = nums.length;
</span><span id="__span-106-5">        int[][] dp = new int[n+1][t+1];
</span><span id="__span-106-6">        //初始化
</span><span id="__span-106-7">        dp[0][0] = 1;
</span><span id="__span-106-8">        //递推
</span><span id="__span-106-9">        for(int i=1; i&lt;=n;i++){
</span><span id="__span-106-10">            for(int j=0; j&lt;=t; j++){
</span><span id="__span-106-11">                dp[i][j] = dp[i-1][j];
</span><span id="__span-106-12">                if(j-nums[i-1] &gt;= 0){
</span><span id="__span-106-13">                    dp[i][j] += dp[i-1][j-nums[i-1]];
</span><span id="__span-106-14">                }
</span><span id="__span-106-15">            }
</span><span id="__span-106-16">        }
</span><span id="__span-106-17">        return dp[n][t];
</span><span id="__span-106-18">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="01">01背包<a class="headerlink" href="#01" title="Permanent link">&para;</a></h3>
<p><strong>📌</strong></p>
<p>所有的背包问题都没有超出二维dp的范畴</p>
<ol>
<li>要求：给定一个正数t，代表背包的容量。有m个货物，每个货物可以选择一次。每个货物有自己的体积cost[i]以及价值value[i]。问不超过容量的情况下，怎么让货物价值最大，返回最大价值</li>
<li>模板：</li>
<li>子问题：dp[i][j]：前i个物品中选择，总花费不超过j的最大值。假设下标从1开始。所以最后所要的是dp[n][m]</li>
<li>问题规模：n*m</li>
<li>初始化:dp[0][......]  =0</li>
<li>到第i个物品面临的选择：<ol>
<li>不要i物品：则dp[i][j] = dp[i-1][j]</li>
<li>要i物品：则dp[i][j] = dp[i-1][j-cost[i]] + value[i]。</li>
<li>两种可能性求最大值</li>
<li>如果本身cost[i]&lt;j，则就没有第二种可能性，只有第一种可能性</li>
</ol>
</li>
<li>优化：第i行的格子只依赖于i-1行的格子，并且是左上方和正上方。所以可以使用一个一维数组，从右边往左边进行更新。并且当j-cost[i]小于0的时候，dp[i][j]只能等于dp[i-1][j]，就不用进行覆盖了</li>
</ol>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-107-1">//普通dp  
</span><span id="__span-107-2">public static int compute1() {
</span><span id="__span-107-3">        int[][] dp = new int[n + 1][t + 1];
</span><span id="__span-107-4">        for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-107-5">            for (int j = 0; j &lt;= t; j++) {
</span><span id="__span-107-6">                // 不要i号物品
</span><span id="__span-107-7">                dp[i][j] = dp[i - 1][j];
</span><span id="__span-107-8">                if (j - cost[i] &gt;= 0) {
</span><span id="__span-107-9">                    // 要i号物品
</span><span id="__span-107-10">                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - cost[i]] + val[i]);
</span><span id="__span-107-11">                }
</span><span id="__span-107-12">            }
</span><span id="__span-107-13">        }
</span><span id="__span-107-14">        return dp[n][t];
</span><span id="__span-107-15">    }
</span><span id="__span-107-16">
</span><span id="__span-107-17">// 空间压缩
</span><span id="__span-107-18">public static int compute() {
</span><span id="__span-107-19">    Arrays.fill(dp, 0, t + 1, 0);
</span><span id="__span-107-20">    for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-107-21">        for (int j = t; j &gt;= cost[i]; j--) {
</span><span id="__span-107-22">            dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);
</span><span id="__span-107-23">        }
</span><span id="__span-107-24">    }
</span><span id="__span-107-25">    return dp[t];
</span><span id="__span-107-26">}
</span></code></pre></div></td></tr></table></div>
1. 变形：
   1. 某公司游戏平台的夏季特惠开始了，你决定入手一些游戏。现在你一共有X元的预算，该平台上所有的 n 个游戏均有折扣，标号为 i 的游戏的原价 <em>ai</em> 元，现价只要 <em>bi</em>元（也就是说该游戏可以优惠 <em>ai</em>−<em>bi</em> 元）并且你购买该游戏能获得快乐值为 <em>wi</em>。由于优惠的存在，你可能做出一些冲动消费导致最终买游戏的总费用超过预算，但只要满足获得的总优惠金额不低于超过预算的总金额，那在心理上就不会觉得吃亏。现在你希望在心理上不觉得吃亏的前提下，获得尽可能多的快乐值。
   2. 分析：只要总优惠&gt;超过的总预算，也就是<img alt="" src="" />,其中ci=ai-bi，X为总预算。经过变形，可以分析得出<img alt="" src="" />就可以继续获得快乐值。所以只要ci-bi&gt;0就一定可以买。对于ci-bi&lt;0的物品，每个可以看做是cost[i] = -(ci-bi)的商品，总共的可花费的钱是<img alt="" src="" />。可以转换为0-1背包问题。或者可以看做每次获得一个Well&gt;0的东西,就是增加了可用的余额。
   3. 卡数据量</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-108-1">import java.util.*;
</span><span id="__span-108-2">import java.io.*;
</span><span id="__span-108-3">class Main{
</span><span id="__span-108-4">    public static int MAXN = 5001;
</span><span id="__span-108-5">    public static int MAXX = 60001;
</span><span id="__span-108-6">    public static int[] cost = new int[MAXN];
</span><span id="__span-108-7">    public static long[] val = new long[MAXN];
</span><span id="__span-108-8">    public static long[] dp = new long[MAXX];
</span><span id="__span-108-9">    public static int n,X,m;
</span><span id="__span-108-10">    public static void main(String[] args){
</span><span id="__span-108-11">
</span><span id="__span-108-12">        Scanner sc = new Scanner(System.in);
</span><span id="__span-108-13">        n = sc.nextInt();
</span><span id="__span-108-14">        X = sc.nextInt();
</span><span id="__span-108-15">        //[1~n];
</span><span id="__span-108-16">        long ans = 0;
</span><span id="__span-108-17">        long happy = 0;
</span><span id="__span-108-18">        m = 1;
</span><span id="__span-108-19">        for(int i=1,pre,cur; i&lt;=n; i++){
</span><span id="__span-108-20">            pre = sc.nextInt();
</span><span id="__span-108-21">            cur = sc.nextInt();
</span><span id="__span-108-22">            happy = sc.nextLong();
</span><span id="__span-108-23">            int well = pre-cur-cur;
</span><span id="__span-108-24">            if(well &gt;= 0){
</span><span id="__span-108-25">                ans += happy;
</span><span id="__span-108-26">                X += well;
</span><span id="__span-108-27">            }else{
</span><span id="__span-108-28">                cost[m] = -well;
</span><span id="__span-108-29">                val[m++] = happy;
</span><span id="__span-108-30">            }
</span><span id="__span-108-31">        }
</span><span id="__span-108-32">        ans += compute();
</span><span id="__span-108-33">        System.out.println(ans);
</span><span id="__span-108-34">
</span><span id="__span-108-35">    }
</span><span id="__span-108-36">    //[0,1背包]
</span><span id="__span-108-37">    public static long compute() {
</span><span id="__span-108-38">        Arrays.fill(dp, 0, X + 1, 0);
</span><span id="__span-108-39">        for (int i = 1; i &lt;= m; i++) {
</span><span id="__span-108-40">            for (int j = X; j &gt;= cost[i]; j--) {
</span><span id="__span-108-41">                dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);
</span><span id="__span-108-42">            }
</span><span id="__span-108-43">        }
</span><span id="__span-108-44">        return dp[X];
</span><span id="__span-108-45">    }
</span><span id="__span-108-46">}
</span></code></pre></div></td></tr></table></div>
1. 例题leetcode494目标和
   1. 给你一个非负整数数组 <code>&lt;span class="color_font"&gt;&lt;span&gt;nums&lt;/span&gt;&lt;/span&gt;</code> 和一个整数 <code>&lt;span class="color_font"&gt;&lt;span&gt;target&lt;/span&gt;&lt;/span&gt;</code> 。</p>
<p>向数组中的每个整数前添加 <code>&lt;span class="color_font"&gt;&lt;span&gt;'+'&lt;/span&gt;&lt;/span&gt;</code> 或 <code>&lt;span class="color_font"&gt;&lt;span&gt;'-'&lt;/span&gt;&lt;/span&gt;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>&lt;span class="color_font"&gt;&lt;span&gt;nums = [2, 1]&lt;/span&gt;&lt;/span&gt;</code> ，可以在 <code>&lt;span class="color_font"&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;</code> 之前添加 <code>&lt;span class="color_font"&gt;&lt;span&gt;'+'&lt;/span&gt;&lt;/span&gt;</code> ，在 <code>&lt;span class="color_font"&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;</code> 之前添加 <code>&lt;span class="color_font"&gt;&lt;span&gt;'-'&lt;/span&gt;&lt;/span&gt;</code> ，然后串联起来得到表达式 <code>&lt;span class="color_font"&gt;&lt;span&gt;"+2-1"&lt;/span&gt;&lt;/span&gt;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>&lt;span class="color_font"&gt;&lt;span&gt;target&lt;/span&gt;&lt;/span&gt;</code> 的不同 <strong>表达式</strong> 的数目。</p>
<ol>
<li>思路：</li>
<li>记忆化搜索：<ol>
<li>通过使用二级缓存来确定i,j参数决定的，带负数的缓存，实现是两层map</li>
</ol>
</li>
</ol>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-109-1">class Solution {
</span><span id="__span-109-2">    public static int cnt;
</span><span id="__span-109-3">    public int findTargetSumWays(int[] nums, int target) {
</span><span id="__span-109-4">        //使用二级缓存,可以缓存的内容由i和cur共同决定
</span><span id="__span-109-5">        HashMap&lt;Integer,HashMap&lt;Integer,Integer&gt;&gt; cache = new HashMap&lt;&gt;();
</span><span id="__span-109-6">        int ans = f1(nums,0,0,target,cache);
</span><span id="__span-109-7">        System.out.println(cnt);
</span><span id="__span-109-8">        return ans;
</span><span id="__span-109-9">    }
</span><span id="__span-109-10">    public int f1(int[] nums, int i ,int cur,int target,HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; cache){
</span><span id="__span-109-11">        int n = nums.length;
</span><span id="__span-109-12">        if(i == n){
</span><span id="__span-109-13">            if(cur == target){
</span><span id="__span-109-14">                return 1;
</span><span id="__span-109-15">            }else{
</span><span id="__span-109-16">                return 0;
</span><span id="__span-109-17">            }
</span><span id="__span-109-18">        }
</span><span id="__span-109-19">        if(cache.containsKey(i) &amp;&amp; cache.get(i).containsKey(cur)){
</span><span id="__span-109-20">            return cache.get(i).get(cur);
</span><span id="__span-109-21">        }
</span><span id="__span-109-22">        int a=  f1(nums,i+1,cur+nums[i],target,cache);
</span><span id="__span-109-23">        int b = f1(nums,i+1,cur-nums[i],target,cache);
</span><span id="__span-109-24">        int ans = a+b;
</span><span id="__span-109-25">        cache.putIfAbsent(i,new HashMap&lt;&gt;());
</span><span id="__span-109-26">        cache.get(i).put(cur,ans);
</span><span id="__span-109-27">        return ans;
</span><span id="__span-109-28">    }
</span><span id="__span-109-29">}
</span></code></pre></div></td></tr></table></div>
1. 普通动态规划：</p>
<ol>
<li>思路：由于i,j中j有负数，所以考虑将j位置下标进行平移，补成正数</li>
<li>01背包dp</li>
<li>思路：</li>
<li>nums中如果有负数，比如：{-1,-2,-3}，其结果和{1,2,3}是完全一样的。</li>
<li>如果target大于所有数累加和sum，则可以直接返回0</li>
<li>不管符号，题目中的sum的奇偶性不会改变，如果奇偶性不同，直接返回0</li>
<li>转换为0-1背包问题，也就是求非负数组中有多少个累加和为t的子序列</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-110-1">class Solution {
</span><span id="__span-110-2">    public int findTargetSumWays(int[] nums, int target) {
</span><span id="__span-110-3">        int sum = 0;
</span><span id="__span-110-4">        for (int i : nums) {
</span><span id="__span-110-5">            sum += i;
</span><span id="__span-110-6">        }
</span><span id="__span-110-7">        if(target &gt; sum || (target&amp;1) != (sum&amp;1)){
</span><span id="__span-110-8">            return 0;
</span><span id="__span-110-9">        }
</span><span id="__span-110-10">        return subSum(nums,(target+sum)/2);
</span><span id="__span-110-11">    }
</span><span id="__span-110-12">    public int subSum(int[] nums, int t){
</span><span id="__span-110-13">        if(t&lt;0) return 0;
</span><span id="__span-110-14">        //dp[i][j]：前i个数字的序列的，sum=j的种类
</span><span id="__span-110-15">        int n = nums.length;
</span><span id="__span-110-16">        int[][] dp = new int[n+1][t+1];
</span><span id="__span-110-17">        //初始化
</span><span id="__span-110-18">        dp[0][0] = 1;
</span><span id="__span-110-19">        //递推
</span><span id="__span-110-20">        for(int i=1; i&lt;=n;i++){
</span><span id="__span-110-21">            for(int j=0; j&lt;=t; j++){
</span><span id="__span-110-22">                dp[i][j] = dp[i-1][j];
</span><span id="__span-110-23">                if(j-nums[i-1] &gt;= 0){
</span><span id="__span-110-24">                    dp[i][j] += dp[i-1][j-nums[i-1]];
</span><span id="__span-110-25">                }
</span><span id="__span-110-26">            }
</span><span id="__span-110-27">        }
</span><span id="__span-110-28">        return dp[n][t];
</span><span id="__span-110-29">    }
</span><span id="__span-110-30">}
</span></code></pre></div></td></tr></table></div>
<h3 id="_97">分组背包<a class="headerlink" href="#_97" title="Permanent link">&para;</a></h3>
<ol>
<li>和01背包区别：商品进行分组，每组最多只能取一件商品(01)</li>
<li>模版：</li>
<li>状态转移方程：<ol>
<li>dp[i][j]：代表的是[1,i]组的情况下，每组只能选一件商品，消耗最多为j的情况下的最大价值。</li>
<li>不要i组商品：dp[i-1][j]</li>
<li>要i组商品：在i组内，尝试所有可能性</li>
<li>最终dp[i][j]是II和III的max。</li>
</ol>
</li>
</ol>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-111-1">public class Code01_PartitionedKnapsack {
</span><span id="__span-111-2">
</span><span id="__span-111-3">    public static int MAXN = 1001;
</span><span id="__span-111-4">
</span><span id="__span-111-5">    public static int MAXM = 1001;
</span><span id="__span-111-6">
</span><span id="__span-111-7">    // arr[i][0] i号物品的体积
</span><span id="__span-111-8">    // arr[i][1] i号物品的价值
</span><span id="__span-111-9">    // arr[i][2] i号物品的组号
</span><span id="__span-111-10">    public static int[][] arr = new int[MAXN][3];
</span><span id="__span-111-11">
</span><span id="__span-111-12">    public static int[] dp = new int[MAXM];
</span><span id="__span-111-13">
</span><span id="__span-111-14">    public static int m, n;
</span><span id="__span-111-15">
</span><span id="__span-111-16">    public static void main(String[] args) throws IOException {
</span><span id="__span-111-17">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-111-18">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-111-19">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-111-20">        while (in.nextToken() != StreamTokenizer.TT_EOF) {
</span><span id="__span-111-21">            m = (int) in.nval;
</span><span id="__span-111-22">            in.nextToken();
</span><span id="__span-111-23">            n = (int) in.nval;
</span><span id="__span-111-24">            for (int i = 1; i &lt;= n; i++) {
</span><span id="__span-111-25">                in.nextToken();
</span><span id="__span-111-26">                arr[i][0] = (int) in.nval;
</span><span id="__span-111-27">                in.nextToken();
</span><span id="__span-111-28">                arr[i][1] = (int) in.nval;
</span><span id="__span-111-29">                in.nextToken();
</span><span id="__span-111-30">                arr[i][2] = (int) in.nval;
</span><span id="__span-111-31">            }
</span><span id="__span-111-32">            Arrays.sort(arr, 1, n + 1, (a, b) -&gt; a[2] - b[2]);
</span><span id="__span-111-33">            out.println(compute1());
</span><span id="__span-111-34">        }
</span><span id="__span-111-35">        out.flush();
</span><span id="__span-111-36">        out.close();
</span><span id="__span-111-37">        br.close();
</span><span id="__span-111-38">    }
</span><span id="__span-111-39">
</span><span id="__span-111-40">    // 严格位置依赖的动态规划
</span><span id="__span-111-41">    public static int compute1() {
</span><span id="__span-111-42">        //计算组的数量
</span><span id="__span-111-43">        int teams = 1;
</span><span id="__span-111-44">        for (int i = 2; i &lt;= n; i++) {
</span><span id="__span-111-45">            if (arr[i - 1][2] != arr[i][2]) {
</span><span id="__span-111-46">                teams++;
</span><span id="__span-111-47">            }
</span><span id="__span-111-48">        }
</span><span id="__span-111-49">        // 组的编号1~teams
</span><span id="__span-111-50">        // dp[i][j] : 1~i是组的范围，每个组的物品挑一件，容量不超过j的情况下，最大收益
</span><span id="__span-111-51">        int[][] dp = new int[teams + 1][m + 1];
</span><span id="__span-111-52">        // dp[0][....] = 0
</span><span id="__span-111-53">        for (int start = 1, end = 2, i = 1; start &lt;= n; i++) {
</span><span id="__span-111-54">            while (end &lt;= n &amp;&amp; arr[end][2] == arr[start][2]) {
</span><span id="__span-111-55">                end++;
</span><span id="__span-111-56">            }
</span><span id="__span-111-57">            // start ... end-1 -&gt; i组
</span><span id="__span-111-58">            for (int j = 0; j &lt;= m; j++) {
</span><span id="__span-111-59">                // arr[start...end-1]是当前组，组号一样
</span><span id="__span-111-60">                // 其中的每一件商品枚举一遍
</span><span id="__span-111-61">                dp[i][j] = dp[i - 1][j];
</span><span id="__span-111-62">                for (int k = start; k &lt; end; k++) {
</span><span id="__span-111-63">                    // k是组内的一个商品编号
</span><span id="__span-111-64">                    if (j - arr[k][0] &gt;= 0) {
</span><span id="__span-111-65">                        dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - arr[k][0]] + arr[k][1]);
</span><span id="__span-111-66">                    }
</span><span id="__span-111-67">                }
</span><span id="__span-111-68">            }
</span><span id="__span-111-69">            // start去往下一组的第一个物品
</span><span id="__span-111-70">            // 继续处理剩下的组
</span><span id="__span-111-71">            start = end++;
</span><span id="__span-111-72">        }
</span><span id="__span-111-73">        return dp[teams][m];
</span><span id="__span-111-74">    }
</span><span id="__span-111-75">}
</span></code></pre></div></td></tr></table></div>
1. 时间复杂度：假设物品总个数是n,背包容量是m,则时间复杂度是O(m*k1 + m*k2 +... m*kn),其中ki是第i组的个数。k1+k2+..+kn = n;所以是M(m*n);</p>
<h3 id="_98">完全背包<a class="headerlink" href="#_98" title="Permanent link">&para;</a></h3>
<ol>
<li>和01背包的区别：每种商品可以选择无限次。</li>
<li>模板：</li>
<li>还是[1,n]号商品</li>
<li>dp[i][j]：[1,i]商品，背包容量是j的情况下，返回的最大价值<ol>
<li>这次不要i商品：dp[i][j] = dp[i-1][j]</li>
<li>这次选择i商品：dp[i][j] = dp[i][j-cost[i]]+val[i]；注意后面还是i</li>
<li>也就是还是在i商品处选择，但是容量减小，也就是可以多次选择。</li>
</ol>
</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-112-1">public class Code03_UnboundedKnapsack {
</span><span id="__span-112-2">
</span><span id="__span-112-3">    public static int MAXM = 10001;
</span><span id="__span-112-4">
</span><span id="__span-112-5">    public static int MAXT = 10000001;
</span><span id="__span-112-6">
</span><span id="__span-112-7">    public static int[] cost = new int[MAXM];
</span><span id="__span-112-8">
</span><span id="__span-112-9">    public static int[] val = new int[MAXM];
</span><span id="__span-112-10">
</span><span id="__span-112-11">    public static long[] dp = new long[MAXT];
</span><span id="__span-112-12">
</span><span id="__span-112-13">    public static int t, m;
</span><span id="__span-112-14">
</span><span id="__span-112-15">    public static void main(String[] args) throws IOException {
</span><span id="__span-112-16">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-112-17">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-112-18">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-112-19">        while (in.nextToken() != StreamTokenizer.TT_EOF) {
</span><span id="__span-112-20">            t = (int) in.nval;
</span><span id="__span-112-21">            in.nextToken();
</span><span id="__span-112-22">            m = (int) in.nval;
</span><span id="__span-112-23">            for (int i = 1; i &lt;= m; i++) {
</span><span id="__span-112-24">                in.nextToken();
</span><span id="__span-112-25">                cost[i] = (int) in.nval;
</span><span id="__span-112-26">                in.nextToken();
</span><span id="__span-112-27">                val[i] = (int) in.nval;
</span><span id="__span-112-28">            }
</span><span id="__span-112-29">            out.println(compute2());
</span><span id="__span-112-30">        }
</span><span id="__span-112-31">        out.flush();
</span><span id="__span-112-32">        out.close();
</span><span id="__span-112-33">        br.close();
</span><span id="__span-112-34">    }
</span><span id="__span-112-35">
</span><span id="__span-112-36">    // 严格位置依赖的动态规划
</span><span id="__span-112-37">    // 会空间不够，导致无法通过全部测试用例
</span><span id="__span-112-38">    public static long compute1() {
</span><span id="__span-112-39">        // dp[0][.....] = 0
</span><span id="__span-112-40">        int[][] dp = new int[m + 1][t + 1];
</span><span id="__span-112-41">        for (int i = 1; i &lt;= m; i++) {
</span><span id="__span-112-42">            for (int j = 0; j &lt;= t; j++) {
</span><span id="__span-112-43">                dp[i][j] = dp[i - 1][j];
</span><span id="__span-112-44">                if (j - cost[i] &gt;= 0) {
</span><span id="__span-112-45">                    dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);
</span><span id="__span-112-46">                }
</span><span id="__span-112-47">            }
</span><span id="__span-112-48">        }
</span><span id="__span-112-49">        return dp[m][t];
</span><span id="__span-112-50">    }
</span></code></pre></div></td></tr></table></div>
<h3 id="dp">数位DP<a class="headerlink" href="#dp" title="Permanent link">&para;</a></h3>
<p>数位DP的实现统一采用记忆化搜索。</p>
<p>例题</p>
<ol>
<li>leetcode 357统计各位数字都不同的数</li>
<li>思路：使用递归解决。</li>
</ol>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-113-1">class Solution {
</span><span id="__span-113-2">    public int countNumbersWithUniqueDigits(int n) {
</span><span id="__span-113-3">        if(n == 0){
</span><span id="__span-113-4">            return 1;
</span><span id="__span-113-5">        }
</span><span id="__span-113-6">        int ans = 10;
</span><span id="__span-113-7">        for(int i=2;i&lt;=n;i++){
</span><span id="__span-113-8">            ans += dfs(i,1,9);
</span><span id="__span-113-9">        }
</span><span id="__span-113-10">        return ans;
</span><span id="__span-113-11">    }
</span><span id="__span-113-12">    public int dfs(int n,int cnt,int pre){
</span><span id="__span-113-13">        int cur = cnt == 1 || cnt == 2? 9 : pre-1;
</span><span id="__span-113-14">        if(cnt == n) return cur;
</span><span id="__span-113-15">        return cur*dfs(n,cnt+1,cur);
</span><span id="__span-113-16">    }
</span><span id="__span-113-17">}
</span></code></pre></div></td></tr></table></div>
1. leetcode 902<a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/"><strong>最大为 N 的数字组合</strong></a>
   1. 思路：
      1. 对于数字的选择，有一些限制。
      2. 两种情况：
         1. 位数少，则每一位可以随便选。
         2. 位数相同，
            1. 如果前一位比目标小，则可以随便选
            2. 如果数字前一位和目标一致，则下一位只能&lt;=</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-114-1">//记忆化搜索
</span><span id="__span-114-2">class Solution {
</span><span id="__span-114-3">    public static int MAXN = 16;
</span><span id="__span-114-4">    public static int[][][] cache = new int[MAXN][2][2];
</span><span id="__span-114-5">    public int atMostNGivenDigitSet(String[] digits, int n) {
</span><span id="__span-114-6">        build();
</span><span id="__span-114-7">        int temp = n / 10;
</span><span id="__span-114-8">        int len = 1;
</span><span id="__span-114-9">        int offset = 1;
</span><span id="__span-114-10">        while (temp &gt; 0) {
</span><span id="__span-114-11">            temp = temp / 10;
</span><span id="__span-114-12">            len++;
</span><span id="__span-114-13">            offset = offset * 10;
</span><span id="__span-114-14">        }
</span><span id="__span-114-15">        System.out.println(len);
</span><span id="__span-114-16">        int m = digits.length;
</span><span id="__span-114-17">        int[] nums = new int[m];
</span><span id="__span-114-18">        for (int i = 0; i &lt; m; i++) {
</span><span id="__span-114-19">            nums[i] = Integer.parseInt(digits[i]);
</span><span id="__span-114-20">        }
</span><span id="__span-114-21">        return dfs(nums, n, offset, len, 1, 1,cache);
</span><span id="__span-114-22">    }
</span><span id="__span-114-23">
</span><span id="__span-114-24">    public static void build(){
</span><span id="__span-114-25">        for(int i=0; i&lt;MAXN;i++){
</span><span id="__span-114-26">            for(int j=0; j&lt;2;j++){
</span><span id="__span-114-27">                Arrays.fill(cache[i][j],Integer.MIN_VALUE);
</span><span id="__span-114-28">            }
</span><span id="__span-114-29">        }
</span><span id="__span-114-30">    }
</span><span id="__span-114-31">
</span><span id="__span-114-32">    public int dfs(int[] nums, int n, int offset, int len, int quit, int same,int[][][] cache) {
</span><span id="__span-114-33">        if (len == 0) {
</span><span id="__span-114-34">            return quit==1 ? 0 : 1;
</span><span id="__span-114-35">        }
</span><span id="__span-114-36">
</span><span id="__span-114-37">        int ans = 0;
</span><span id="__span-114-38">        if(cache[len][quit][same] != Integer.MIN_VALUE) return cache[len][quit][same];
</span><span id="__span-114-39">        int cur = (n / offset) % 10;
</span><span id="__span-114-40">        // 1.如果是第一个或者前面也舍弃了，舍弃当前位
</span><span id="__span-114-41">        if (quit==1)
</span><span id="__span-114-42">            ans += dfs(nums, n, offset / 10, len - 1, 1, 0,cache);
</span><span id="__span-114-43">        // 2.前面的选择
</span><span id="__span-114-44">        if (same==1) {
</span><span id="__span-114-45">            for (int i : nums) {
</span><span id="__span-114-46">                if (i &lt; cur) {
</span><span id="__span-114-47">                    ans += dfs(nums, n, offset / 10, len - 1, 0, 0,cache);
</span><span id="__span-114-48">                } else if (i == cur){
</span><span id="__span-114-49">                    ans += dfs(nums, n, offset / 10, len - 1, 0, 1,cache);
</span><span id="__span-114-50">                } else {
</span><span id="__span-114-51">                    break;
</span><span id="__span-114-52">                }
</span><span id="__span-114-53">            }
</span><span id="__span-114-54">        } else {
</span><span id="__span-114-55">            ans += nums.length * dfs(nums, n, offset / 10, len - 1, 0, 0,cache);
</span><span id="__span-114-56">        }
</span><span id="__span-114-57">        cache[len][quit][same] = ans;
</span><span id="__span-114-58">        return ans;
</span><span id="__span-114-59">    }
</span><span id="__span-114-60">}
</span><span id="__span-114-61">
</span><span id="__span-114-62">//更精简模板，挂缓存部分完全一致
</span><span id="__span-114-63">class Solution {
</span><span id="__span-114-64">    public int atMostNGivenDigitSet(String[] digits, int n) {
</span><span id="__span-114-65">        char[] c = Integer.toString(n).toCharArray();
</span><span id="__span-114-66">        int m = digits.length;
</span><span id="__span-114-67">        int[] num = new int[m];
</span><span id="__span-114-68">        for(int i=0; i&lt;m;i++){
</span><span id="__span-114-69">            num[i] = Integer.parseInt(digits[i]);
</span><span id="__span-114-70">        }
</span><span id="__span-114-71">        return dfs(num, c, 0, true, true);
</span><span id="__span-114-72">    }
</span><span id="__span-114-73">    public int dfs(int[] num, char[] c, int i, boolean limit,boolean quit){
</span><span id="__span-114-74">        if(i == c.length){
</span><span id="__span-114-75">            return quit? 0 : 1;
</span><span id="__span-114-76">        }
</span><span id="__span-114-77">        int ans = 0;
</span><span id="__span-114-78">        int up = limit ? c[i]-&#39;0&#39; : 9;
</span><span id="__span-114-79">        if(quit) ans += dfs(num, c, i+1, false, true);
</span><span id="__span-114-80">        for(int item : num){
</span><span id="__span-114-81">            if(item &gt; up) break;
</span><span id="__span-114-82">            ans += dfs(num, c, i+1, limit &amp;&amp; item == up, false);
</span><span id="__span-114-83">        }
</span><span id="__span-114-84">        return ans;
</span><span id="__span-114-85">    }
</span><span id="__span-114-86">}
</span></code></pre></div></td></tr></table></div>
1. leetcode 233数字一的个数
   1. 给定一个整数 <code>&lt;span&gt;n&lt;/span&gt;</code>，计算所有小于等于 <code>&lt;span&gt;n&lt;/span&gt;</code> 的非负整数中数字 <code>&lt;span&gt;1&lt;/span&gt;</code> 出现的个数。</p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-115-1">class Solution {
</span><span id="__span-115-2">    public static int MAXN = 16;
</span><span id="__span-115-3">    public static int[][][] cache = new int[MAXN][MAXN][2];
</span><span id="__span-115-4">    public int countDigitOne(int n) {
</span><span id="__span-115-5">        build();
</span><span id="__span-115-6">        char[] c = Integer.toString(n).toCharArray();
</span><span id="__span-115-7">        return dfs(c, 0, 1, 0,cache);
</span><span id="__span-115-8">    }
</span><span id="__span-115-9">    public static void build(){
</span><span id="__span-115-10">        for(int i=0; i&lt;cache.length;i++){
</span><span id="__span-115-11">            for(int j=0; j&lt;cache[i].length;j++){
</span><span id="__span-115-12">               Arrays.fill(cache[i][j],Integer.MIN_VALUE); 
</span><span id="__span-115-13">            }
</span><span id="__span-115-14">        }
</span><span id="__span-115-15">    }
</span><span id="__span-115-16">    public int dfs(char[] c, int i,int limit, int acc,int[][][] cache){
</span><span id="__span-115-17">        if( i == c.length) return acc;
</span><span id="__span-115-18">        if(cache[i][acc][limit] != Integer.MIN_VALUE) return cache[i][acc][limit];
</span><span id="__span-115-19">        int up = limit == 1? c[i]-&#39;0&#39; : 9;
</span><span id="__span-115-20">        int ans = 0;
</span><span id="__span-115-21">        for(int k=0; k&lt;=up; k++){
</span><span id="__span-115-22">            ans += dfs(c, i+1, ((limit==1) &amp;&amp; (k==up))?1 : 0, acc+(k==1? 1 : 0),cache);
</span><span id="__span-115-23">        }
</span><span id="__span-115-24">        cache[i][acc][limit] = ans;
</span><span id="__span-115-25">        return ans;
</span><span id="__span-115-26">    }
</span><span id="__span-115-27">}
</span></code></pre></div></td></tr></table></div>
<h3 id="dp_1">树形DP<a class="headerlink" href="#dp_1" title="Permanent link">&para;</a></h3>
<p>树是一个头节点没有父节点，其余节点都有一个父节点的有向无环图</p>
<p>在树上做动态规划，拆解的子问题比一般的DP问题更清晰，绝大部分都是父节点依赖子节点</p>
<p>树形DP套路：</p>
<ol>
<li>分析父树得到答案需要子树的什么信息</li>
<li>把子树信息的全集定义为递归返回值</li>
<li>通过递归让子树返回全集信息</li>
<li>整合子树的全集信息，得到父树的全集信息并返回</li>
<li>
<p>例题：给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小</p>
</li>
<li>
<p>思路：以x为根节点的树</p>
<ol>
<li>子树的类型：<ol>
<li>不包含x节点，则结果是max(左最大BST，右最大BST)。则需要子树的最大二叉搜索子树的信息</li>
<li>包含x节点，这个需要判断带x节点是否是BST。如果左子树，右子树都是BST，则需要子树提供min,max信息来和x节点进行比较，如果判断成立，则结果是maxl + maxr + 1</li>
</ol>
</li>
<li>最终的结果就是将x设置为root，便可以得到整体的最大BST</li>
</ol>
</li>
<li>时间复杂度：信息的整合是O(1)的。整棵树每个节点遍历一遍，整合一次，则时间复杂度是O(n)</li>
</ol>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-116-1">    public static int largestBSTSubtree(TreeNode root) {
</span><span id="__span-116-2">        return f(root).maxBstSize;
</span><span id="__span-116-3">    }
</span><span id="__span-116-4">    //信息类
</span><span id="__span-116-5">    public static class Info {
</span><span id="__span-116-6">        //整体设置为long类型，同样是防止递归终止条件的设置干扰判断。节点值的范围是int类型的值域范围
</span><span id="__span-116-7">        public long max;
</span><span id="__span-116-8">        public long min;
</span><span id="__span-116-9">        public boolean isBst;
</span><span id="__span-116-10">        public int maxBstSize;
</span><span id="__span-116-11">
</span><span id="__span-116-12">        public Info(long a, long b, boolean c, int d) {
</span><span id="__span-116-13">            max = a;
</span><span id="__span-116-14">            min = b;
</span><span id="__span-116-15">            isBst = c;
</span><span id="__span-116-16">            //以x节点为根节点的树中包含的最大BST子树      
</span><span id="__span-116-17">            maxBstSize = d;
</span><span id="__span-116-18">        }
</span><span id="__span-116-19">    }
</span><span id="__span-116-20">    public static Info f(TreeNode x) {
</span><span id="__span-116-21">        // 递归终止条件：x==null的时候，需要终止递归，并且返回不干扰上面的判断的信息
</span><span id="__span-116-22">        if (x == null) {
</span><span id="__span-116-23">            return new Info(Long.MIN_VALUE, Long.MAX_VALUE, true, 0);
</span><span id="__span-116-24">        }
</span><span id="__span-116-25">        Info infol = f(x.left);
</span><span id="__span-116-26">        Info infor = f(x.right);
</span><span id="__span-116-27">        // 左 4信息
</span><span id="__span-116-28">        // 右 4信息
</span><span id="__span-116-29">        // x 整合出4信息返回
</span><span id="__span-116-30">        long max = Math.max(x.val, Math.max(infol.max, infor.max));
</span><span id="__span-116-31">        long min = Math.min(x.val, Math.min(infol.min, infor.min));
</span><span id="__span-116-32">        boolean isBst = infol.isBst &amp;&amp; infor.isBst &amp;&amp; infol.max &lt; x.val &amp;&amp; x.val &lt; infor.min;
</span><span id="__span-116-33">        int maxBSTSize;
</span><span id="__span-116-34">        if (isBst) {
</span><span id="__span-116-35">            maxBSTSize = infol.maxBstSize + infor.maxBstSize + 1;
</span><span id="__span-116-36">        } else {
</span><span id="__span-116-37">            maxBSTSize = Math.max(infol.maxBstSize, infor.maxBstSize);
</span><span id="__span-116-38">        }
</span><span id="__span-116-39">        return new Info(max, min, isBst, maxBSTSize);
</span><span id="__span-116-40">    }
</span></code></pre></div></td></tr></table></div>
1. <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/"><strong>二叉搜索子树的最大键值和</strong></a>
   1. 这次是寻找树中具有最大累加和的二叉搜索子树
      1. 思路：以x为根的树
         1. 如果不包含x，则是max(左ans,右ans)。需要子树的maxBSTSum
         2. 如果包含x，则是左右侧必须要是BST，则结果是max(左，右，整体) 需要子树的iSBST，min，max，子树整体的sum</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-117-1"> case class info(max:Int, min:Int, sum:Int,maxBSTSum:Int,isBST:Boolean)
</span><span id="__span-117-2">  def maxSumBST(root: TreeNode): Int = {
</span><span id="__span-117-3">    dfs(root).maxBSTSum
</span><span id="__span-117-4">  }
</span><span id="__span-117-5">  private def dfs(x: TreeNode):info = {
</span><span id="__span-117-6">    if(x eq null) info(Int.MinValue,Int.MaxValue,0,0,true)
</span><span id="__span-117-7">    val infol = dfs(x.left)
</span><span id="__span-117-8">    val infor = dfs(x.right)
</span><span id="__span-117-9">    val max =x.value.max(infol.max).max(infor.max)
</span><span id="__span-117-10">    val min = x.value.min(infol.min).min(infor.min)
</span><span id="__span-117-11">    val isBST = infol.isBST &amp;&amp; infor.isBST &amp;&amp; x.value &gt; infol.max &amp;&amp; x.value &lt; infor.min
</span><span id="__span-117-12">    val sum = x.value + infol.sum + infor.sum
</span><span id="__span-117-13">    val maxSum = if(isBST) sum.max(infol.maxBSTSum).max(infor.maxBSTSum) else infol.maxBSTSum.max(infor.maxBSTSum)
</span><span id="__span-117-14">    info(max,min,sum,maxSum,isBST)
</span><span id="__span-117-15">  }
</span></code></pre></div></td></tr></table></div>
1. <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">二叉树的直径</a>
   1. ！走的边不能重复
   2. 思路：以x为根的树
      1. 不要x：则是max(左ans,右ans)。需要子树的最大直径信息
      2. 要x：则是x的左子树高度 + 右子树高度 (树的高度是用节点数量来计算的，n个节点n-1条边。而通过图形画出来的路径长度是2*(n-1) + 2*1),也就是左右子树的节点到根节点还各加了一条边，所以最终结果是2n</p>
<p><div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-118-1">object Solution {
</span><span id="__span-118-2">  case class info(diameter:Int,height:Int)
</span><span id="__span-118-3">  def diameterOfBinaryTree(root: TreeNode): Int = {
</span><span id="__span-118-4">    dfs(root).diameter
</span><span id="__span-118-5">  }
</span><span id="__span-118-6">  private def dfs(x:TreeNode):info = {
</span><span id="__span-118-7">    if(x eq null) return info(0,0)
</span><span id="__span-118-8">    val infol = dfs(x.left)
</span><span id="__span-118-9">    val infor = dfs(x.right)
</span><span id="__span-118-10">    val withX = infol.height+infor.height
</span><span id="__span-118-11">    val outX = infol.diameter.max(infor.diameter)
</span><span id="__span-118-12">    val height = infol.height.max(infor.height) + 1
</span><span id="__span-118-13">    return info(withX.max(outX),height)
</span><span id="__span-118-14">  }
</span><span id="__span-118-15">}
</span></code></pre></div></td></tr></table></div>
1. leetcode 979在二叉树上分配硬币
   1. 思路：以x为根结点的整棵树的调整次数
      1. 第一部分：左树的调整次数 + 右树调整次数
      2. 第二部分：左右子树调整完之后，必然会有一侧多余硬币，一次少硬币。则需要通过父节点进行中转，调整次数是(左节点-左硬币数量)绝对值 + (右节点 - 右硬币数量)绝对值。需要注意的是，这部分可能是根节点往外送，也可能是左侧送往右侧这种情况，但是总次数都是上述的计算。
      3. 需要的信息：子树的调整次数，子树的硬币数量，子树的节点数量</p>
<p><img alt="image.png" src="../assets/image106.png" /></p>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-119-1">object Solution {
</span><span id="__span-119-2">  case class info(node:Int,coin:Int,move:Int)
</span><span id="__span-119-3">  def distributeCoins(root: TreeNode): Int = {
</span><span id="__span-119-4">    dfs(root).move
</span><span id="__span-119-5">  }
</span><span id="__span-119-6">  private def dfs(x:TreeNode):info = {
</span><span id="__span-119-7">    if(x eq null) return info(0,0,0)
</span><span id="__span-119-8">    val infol = dfs(x.left)
</span><span id="__span-119-9">    val infor = dfs(x.right)
</span><span id="__span-119-10">    val coin = x.value + infol.coin + infor.coin
</span><span id="__span-119-11">    val node = infol.node + infor.node + 1
</span><span id="__span-119-12">    val move = (infol.node-infol.coin).abs + (infor.node-infor.coin).abs + infol.move + infor.move
</span><span id="__span-119-13">    return info(node,coin,move)
</span><span id="__span-119-14">  }
</span><span id="__span-119-15">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_99">贪心<a class="headerlink" href="#_99" title="Permanent link">&para;</a></h2>
<ol>
<li>基本思想：每一步都是局部最优，而最后得到的可能是全局最优</li>
<li>leetcode179 最大数</li>
<li>基本技巧：字符串拼接，要求字典序最小。</li>
<li>按照字典序排序的方法：则基本规则是Arrays.sort(str,(a,b)-&gt;(b+a).compareTo(a+b))，这样排序下来是字典序大的在前面。</li>
<li>贪心：排序完之后是单词按照字典序排序，谁大谁在前面。然后将单词依次拼接就行。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-120-1">class Solution {
</span><span id="__span-120-2">    public String largestNumber(int[] nums) {
</span><span id="__span-120-3">        int n = nums.length;
</span><span id="__span-120-4">        String[] str = new String[n];
</span><span id="__span-120-5">        for(int i=0; i&lt;n; i++){
</span><span id="__span-120-6">            str[i] = String.valueOf(nums[i]);
</span><span id="__span-120-7">        }
</span><span id="__span-120-8">        Arrays.sort(str,(a,b)-&gt;(b+a).compareTo(a+b));
</span><span id="__span-120-9">        if(str[0].equals(&quot;0&quot;)){
</span><span id="__span-120-10">            return &quot;0&quot;;
</span><span id="__span-120-11">        } 
</span><span id="__span-120-12">        StringBuilder ans = new StringBuilder();
</span><span id="__span-120-13">        for(String num : str){
</span><span id="__span-120-14">            ans.append(num);
</span><span id="__span-120-15">        }
</span><span id="__span-120-16">        return ans.toString();
</span><span id="__span-120-17">    }
</span><span id="__span-120-18">}
</span></code></pre></div></td></tr></table></div>
<h2 id="_100">数据结构设计<a class="headerlink" href="#_100" title="Permanent link">&para;</a></h2>
<h3 id="setall">setAll功能的哈希表<a class="headerlink" href="#setall" title="Permanent link">&para;</a></h3>
<p>哈希表常见的三个操作时put、get和containsKey，而且这三个操作的时间复杂度为O(1)。现在想加一个setAll功能，就是把所有记录value都设成统一的值。请设计并实现这种有setAll功能的哈希表，并且put、get、containsKey和setAll四个操作的时间复杂度都为O(1)。</p>
<ol>
<li>核心思路：使用时间戳。在scala并发容器设计也用到了时间戳技术。</li>
<li>原理：</li>
<li>每次操作，记录数据修改，以及相应的自增时间戳。</li>
<li>当使用到setAll的时候，直接修改setAllValue字段就可以，同样自增时间戳。</li>
<li>如果要进行get方法，取最新的时间戳为最新有效的数据。</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-121-1">import java.util.*;
</span><span id="__span-121-2">import java.io.*;
</span><span id="__span-121-3">
</span><span id="__span-121-4">class Main {
</span><span id="__span-121-5">    public static HashMap&lt;Integer,int[]&gt; map = new HashMap&lt;&gt;();
</span><span id="__span-121-6">    public static int timeStamp;
</span><span id="__span-121-7">    public static int setAllValue;
</span><span id="__span-121-8">    public static int setAllTime;
</span><span id="__span-121-9">    public static void main(String[] args) throws IOException {
</span><span id="__span-121-10">
</span><span id="__span-121-11">        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
</span><span id="__span-121-12">        StreamTokenizer in = new StreamTokenizer(br);
</span><span id="__span-121-13">        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
</span><span id="__span-121-14">        int N = 0;
</span><span id="__span-121-15">        build();
</span><span id="__span-121-16">        while (in.nextToken() != StreamTokenizer.TT_EOF) {
</span><span id="__span-121-17">            N = (int)in.nval;
</span><span id="__span-121-18">            for(int i=0, op=0; i&lt;N;i++){          
</span><span id="__span-121-19">                in.nextToken();op = (int)in.nval;
</span><span id="__span-121-20">                if(op == 1){
</span><span id="__span-121-21">                    in.nextToken();int x = (int)in.nval;
</span><span id="__span-121-22">                    in.nextToken();int y = (int)in.nval;
</span><span id="__span-121-23">                    //put
</span><span id="__span-121-24">                    put(x,y);
</span><span id="__span-121-25">                }else if(op == 2){
</span><span id="__span-121-26">                    in.nextToken();int x = (int)in.nval;
</span><span id="__span-121-27">                    //get
</span><span id="__span-121-28">                    out.println(get(x));
</span><span id="__span-121-29">                }else {
</span><span id="__span-121-30">                    //setAll
</span><span id="__span-121-31">                    in.nextToken();int x = (int)in.nval;
</span><span id="__span-121-32">                    setAll(x);
</span><span id="__span-121-33">                }
</span><span id="__span-121-34">            }
</span><span id="__span-121-35">        }
</span><span id="__span-121-36">        out.flush();
</span><span id="__span-121-37">        br.close();
</span><span id="__span-121-38">        out.close();
</span><span id="__span-121-39">    }
</span><span id="__span-121-40">    public static void build(){
</span><span id="__span-121-41">        timeStamp = 0;
</span><span id="__span-121-42">        setAllValue = 0;
</span><span id="__span-121-43">        setAllTime = -1;
</span><span id="__span-121-44">    }
</span><span id="__span-121-45">    public static void put(int k, int v){
</span><span id="__span-121-46">        if(map.containsKey(k)){
</span><span id="__span-121-47">            int[] value = map.get(k);
</span><span id="__span-121-48">            value[0] = v;
</span><span id="__span-121-49">            value[1] = timeStamp++;
</span><span id="__span-121-50">        }else{
</span><span id="__span-121-51">            map.put(k,new int[]{v,timeStamp++});
</span><span id="__span-121-52">        }
</span><span id="__span-121-53">    }
</span><span id="__span-121-54">    public static void setAll(int v){
</span><span id="__span-121-55">        setAllValue = v;
</span><span id="__span-121-56">        setAllTime = timeStamp++;
</span><span id="__span-121-57">    }
</span><span id="__span-121-58">    public static int get(int k){
</span><span id="__span-121-59">        if(map.containsKey(k)){
</span><span id="__span-121-60">            int[] record = map.get(k);
</span><span id="__span-121-61">            if(record[1] &lt; setAllTime){
</span><span id="__span-121-62">                return setAllValue;
</span><span id="__span-121-63">            }else{
</span><span id="__span-121-64">                return record[0];
</span><span id="__span-121-65">            }
</span><span id="__span-121-66">        }
</span><span id="__span-121-67">        return -1;
</span><span id="__span-121-68">    }
</span><span id="__span-121-69">}
</span></code></pre></div></td></tr></table></div>
<h3 id="lru">实现LRU缓存<a class="headerlink" href="#lru" title="Permanent link">&para;</a></h3>
<p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091?fromModule=lemma_inlink">页面置换算法</a>，选择最近最久未使用的页面予以淘汰。该算法赋予每个<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2/5544813?fromModule=lemma_inlink">页面</a>一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p>
<p>思路：双向链表+哈希表</p>
<ol>
<li>数据结构：</li>
<li>哈希表：<ul>
<li>key:存放对应的关键字</li>
<li>value:是链表节点的引用，一个链表节点中存放的是关键字与对应的缓存值。</li>
</ul>
</li>
<li>双向链表</li>
<li>头部表示最早的数据，尾部表示最近的数据。</li>
<li>
<p>操作：</p>
</li>
<li>
<p>get：</p>
</li>
<li>可以通过哈希表直接获得对应的链表节点的引用，从而获得的值也是O(1)</li>
<li>然后将该节点移动到尾部</li>
<li>put：</li>
<li>将该节点重新放入尾部。</li>
<li>remove:</li>
<li>删除链表头部的节点</li>
<li>全部操作没有遍历，时间复杂度都是O(1)</li>
</ol>
<div class="language-text highlight"><table class="highlighttable"><tr><th colspan="2" class="filename"><span class="filename">Text Only</span></th></tr><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-122-1">class LRUCache {
</span><span id="__span-122-2">    class DoubleNode{
</span><span id="__span-122-3">        int key;
</span><span id="__span-122-4">        int value;
</span><span id="__span-122-5">        DoubleNode last;
</span><span id="__span-122-6">        DoubleNode next;
</span><span id="__span-122-7">        public DoubleNode(int k, int v){
</span><span id="__span-122-8">            this.key = k;
</span><span id="__span-122-9">            this.value = v;
</span><span id="__span-122-10">        }
</span><span id="__span-122-11">    }
</span><span id="__span-122-12">    class DoubleList{
</span><span id="__span-122-13">        DoubleNode head;
</span><span id="__span-122-14">        DoubleNode tail;
</span><span id="__span-122-15">        public DoubleList(){
</span><span id="__span-122-16">            this.head = null;
</span><span id="__span-122-17">            this.tail = null;
</span><span id="__span-122-18">        }
</span><span id="__span-122-19">        public void addNode(DoubleNode newNode){
</span><span id="__span-122-20">            if(newNode == null) return;
</span><span id="__span-122-21">            if(head == null){
</span><span id="__span-122-22">                head = newNode;
</span><span id="__span-122-23">                tail = newNode;
</span><span id="__span-122-24">            }else{
</span><span id="__span-122-25">                newNode.last = tail;
</span><span id="__span-122-26">                tail.next = newNode;
</span><span id="__span-122-27">                tail = newNode;
</span><span id="__span-122-28">            }
</span><span id="__span-122-29">        }
</span><span id="__span-122-30">        public void moveToTail(DoubleNode node){
</span><span id="__span-122-31">            if(tail ==node) return;
</span><span id="__span-122-32">            if(head == node){
</span><span id="__span-122-33">                head = head.next;
</span><span id="__span-122-34">                head.last = null;
</span><span id="__span-122-35">            }else{
</span><span id="__span-122-36">                node.last.next = node.next;
</span><span id="__span-122-37">                node.next.last = node.last;
</span><span id="__span-122-38">            }
</span><span id="__span-122-39">            node.last = tail;
</span><span id="__span-122-40">            tail.next = node;
</span><span id="__span-122-41">            tail = node;
</span><span id="__span-122-42">        }
</span><span id="__span-122-43">        public DoubleNode removeHead(){
</span><span id="__span-122-44">            if(head == null) return null;
</span><span id="__span-122-45">            DoubleNode ans = null;
</span><span id="__span-122-46">            ans = head;
</span><span id="__span-122-47">            if(head == tail){
</span><span id="__span-122-48">                head = null;
</span><span id="__span-122-49">                tail = null;
</span><span id="__span-122-50">            }else{
</span><span id="__span-122-51">                head = ans.next;
</span><span id="__span-122-52">                head.last = null;
</span><span id="__span-122-53">                ans.next = null;
</span><span id="__span-122-54">            }
</span><span id="__span-122-55">            return ans;
</span><span id="__span-122-56">        }
</span><span id="__span-122-57">    }
</span><span id="__span-122-58">    private HashMap&lt;Integer,DoubleNode&gt; map;
</span><span id="__span-122-59">    private DoubleList nodeList;
</span><span id="__span-122-60">    private int cap;
</span><span id="__span-122-61">    public LRUCache(int capacity) {
</span><span id="__span-122-62">        map = new HashMap&lt;&gt;();
</span><span id="__span-122-63">        nodeList = new DoubleList();
</span><span id="__span-122-64">        cap = capacity;
</span><span id="__span-122-65">    }
</span><span id="__span-122-66">
</span><span id="__span-122-67">    public int get(int key) {
</span><span id="__span-122-68">        if(map.containsKey(key)){
</span><span id="__span-122-69">            DoubleNode node = map.get(key);
</span><span id="__span-122-70">            int v = node.value;
</span><span id="__span-122-71">            nodeList.moveToTail(node);
</span><span id="__span-122-72">            return v;
</span><span id="__span-122-73">        }
</span><span id="__span-122-74">        return -1;
</span><span id="__span-122-75">    }
</span><span id="__span-122-76">
</span><span id="__span-122-77">    public void put(int key, int value) {
</span><span id="__span-122-78">        if(map.containsKey(key)){
</span><span id="__span-122-79">            DoubleNode node = map.get(key);
</span><span id="__span-122-80">            node.value = value;
</span><span id="__span-122-81">            nodeList.moveToTail(node);
</span><span id="__span-122-82">        }else{
</span><span id="__span-122-83">            if(map.size() == cap){
</span><span id="__span-122-84">                DoubleNode oldNode =  nodeList.removeHead();
</span><span id="__span-122-85">                map.remove(oldNode.key);
</span><span id="__span-122-86">            }
</span><span id="__span-122-87">            DoubleNode newNode = new DoubleNode(key, value);
</span><span id="__span-122-88">            map.put(key,newNode);
</span><span id="__span-122-89">            nodeList.addNode(newNode);
</span><span id="__span-122-90">        }
</span><span id="__span-122-91">    }
</span><span id="__span-122-92">}
</span></code></pre></div></td></tr></table></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      lx CC-BY-4.0
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top", "navigation.indexes", "navigation.expand", "search.suggest", "search.highlight", "content.code.copy", "content.action.edit"], "search": "../../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>